;; file warmelt-outobj.melt -*- Lisp -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright (C) 2008 - 2013 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-outobj.melt and 
;; to the generated file  warmelt-outobj*.c
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])
;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; the limit for our [generated C code] implementation and declaration
;; buffer length. The biggest file is often one of
;; melt-stage2/warmelt*c or one of melt-sources/xtramelt*c. 9Mbytes is
;; not enough!
(definstance buffer_limit_cont class_reference
  :referenced_value '33554432)		;; 2^25


(defun get_code_buffer_limit () 
  :doc #{Function to retrieve the generated code buffer limit. 
See also $PUT_CODE_BUFFER_LIMIT}#
  !buffer_limit_cont)

(defun put_code_buffer_limit (lim)
  :doc #{Function to verbosely change the generated code buffer limit
between 2Mb and 64Mb.  See also $GET_CODE_BUFFER_LIMIT.}#
  (let ( (:long l (get_int lim))
	 )
    (debug "put_buffer_limit l=" l)
    (if (and (>=i l 2097152) 		;; 2097152 == 2^21 = 2Mbytes
	     (<=i l 134217728) 		;; 134217728 = 2^27 = 128Mbytes
	     )
	(let ( (vlim (make_integerbox discr_constant_integer l))
	       ) 
	  (code_chunk informbuflimchk 
		      #{ /*$INFORMBUFLIMCHK*/ inform (UNKNOWN_LOCATION, 
			 "MELT code buffer limit set to %ld Kb = %ld Mb", 
			 ($L) >>10, ($L) >> 20);
		      }#)
	  (set_ref buffer_limit_cont vlim)
	  )
      )))


;;;;;;;;;;;;;;;;
(defun code_buffer_limit_optset (optsymb :cstring csopt)
  (let ( (:long lim 0) )
    (code_chunk getlimchk
		#{/*$GETLIMCHK*/ $LIM = atoi($CSOPT);
		}#)
    (if (>i lim 0)
	(put_code_buffer_limit (make_integerbox discr_constant_integer 
						(*i lim 1024))))))

(register_option 'code_buffer_limit
		 '"set limit in kilobytes for the generated code buffer size"
		 code_buffer_limit_optset)



;;;;;;
;; utility function to output the enum index of a module variable binding
(defun out_enumix_modvarbind (out mvarbind)
  (assert_msg "check out" (is_out out) out)
  (assert_msg "check mvarbind" (is_a mvarbind class_normal_module_variable_binding) mvarbind)
  (let ( (binder (get_field :binder mvarbind))
	 (outnam (lambda (nam) (add2out_cident out nam)))
	 )
    (cond ( (is_a binder class_cloned_symbol)
	    (let ( (csymnam (get_field :named_name binder))
		   (crank (get_field :csym_urank binder))
		   )
	      (add2out out "meltmodvarix_") 
	      (add2out_cident out csymnam)
	      (add2out out "_clon" crank)
	    ))
	  ( (== (discrim binder) class_symbol)
	    (let ( (symnam (get_field :named_name binder))
		   )
	      (add2out out "meltmodvarix_")
	      (add2out_cident out symnam)
	      (add2out out "_symb")
	    ))
	  (:else
	   (debug "out_enumix_modvarbind bad binder in mvarbind=" mvarbind)
	   (assert_msg "out_enumix_modvarbind bad binder" () binder))
  )))


;;;;;; utility function for the initial classy frame
;;; we need the classy frame name to be unique, otherwise dlopen seems to mess things..
(defun initial_classy_frame_name (obj)
  (debug "initial_classy_frame_name obj=" obj)
  (assert_msg "check obj" (is_a obj class_initialroutineobj) obj)
  (let ( (name (string4out discr_verbatim_string "Melt_InitialClassyFrame_" 
			   (lambda (out o) (add2out_cident out (get_field :oirout_modulename o))) obj
			   "_h" (obj_hash obj))
	       )
	 )
    (debug "initial_classy_frame_name name=" name)
    (return name)))

;;;;;;
(defun outdeclinit_root (recv sbuf)
  (debug "outdeclinit_root recv=" recv)
  (let ( (dis (discrim recv))
	 (disname (get_field :named_name dis))
	 )
    (errormsg_strv "unexpected object to output initial declaration for" disname)
    (assert_msg "outdeclinit_root unimplemented catchall" () recv)
    ))
(install_method class_root output_c_declinit outdeclinit_root)


(defun outpucod_objinielem (obielem  declbuf implbuf :long depth)
  (assert_msg "check obelem" (is_a obielem class_objinitelem) obielem)
  (let ( (olocvar (unsafe_get_field :oie_locvar obielem))
	 (cnam (unsafe_get_field :oie_cname obielem)) )
    (assert_msg "check cnam" (is_string cnam) cnam)
    (assert_msg "check olocvar"  olocvar)
    (output_c_code olocvar declbuf implbuf depth)
    ;;
    (cond ( (>i (strbuf_usedlength declbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outpucod_objinielem huge declbuf" 10)
	    (debug "outpucod_objinielem huge declbuf=" declbuf)
	    (assert_msg "check limited declbuf" 
		      (<i (strbuf_usedlength declbuf) (get_int !buffer_limit_cont)) declbuf)))
    ;;
    (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outpucod_objinielem huge implbuf" 10)
	    (debug "outpucod_objinielem huge implbuf=" implbuf)
	    (assert_msg "check limited implbuf" 
			(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
    )
  )
(install_method class_objinitelem output_c_code outpucod_objinielem)

(defun outcinitfill_root (recv implbuf ptrstr :long depth)
  (debug "outcinitfill_root recv=" recv)
  (assert_msg "outcinitfill_root unimplemented catchall" () recv)
  )
(install_method class_root output_c_initial_fill outcinitfill_root)



(defun outcinitpredef_root (recv sbuf ptrstr :long depth)
  (debug  "outcinitfill_root recv=" recv)
  (return)
  )
(install_method class_root output_c_initial_predef outcinitpredef_root)

;;; output a predef
(defun output_predef (obpr implbuf :long depth)
  (cond 
   ( (is_integerbox obpr)
     (add2sbuf_strconst implbuf "melt_fetch_predefined(")
     (add2sbuf_longdec implbuf (get_int obpr))
     (add2sbuf_strconst implbuf ")")
     )
   ( (is_a obpr class_symbol)
     (add2sbuf_strconst implbuf "((melt_ptr_t)(MELT_PREDEF(")
     (add2sbuf_string implbuf (unsafe_get_field :named_name obpr))
     (add2sbuf_strconst implbuf ")))")
     )
   ( :else
     (debug " output_predef bad obpr=" obpr)
     (assert_msg "invalid obpr" () obpr)
     )
   )
  ;;
    (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "output_predef huge implbuf" 10)
	    (debug "output_predef huge implbuf=" implbuf)
	    (assert_msg "check limited implbuf" 
			(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
  )

;;; output code for a predef
(defun outpucod_predef (obpred declbuf implbuf :long depth)
  (assert_msg "check obpredef" (is_a obpred class_objpredef) obpred)
  (let ( (obpr (unsafe_get_field :obpredef obpred)) )
    (assert_msg "check obpr" obpr obpred)
    (output_predef obpr implbuf depth)))
(install_method class_objpredef output_c_code outpucod_predef)

;;;; output a nil
(defun outpucod_nil (obnil  declbuf implbuf :long depth)
  (assert_msg "check obnil" (is_a obnil class_objnil) obnil)
  (add2sbuf_strconst implbuf "(/*nil*/NULL)"))
(install_method class_objnil output_c_code outpucod_nil)

;;; output code for a objexpandpureval
(defun outpucod_objexpandpureval (obx declbuf implbuf :long depth)
  (debug "outpucod_objexpandpureval obx=" obx)
  (assert_msg "check obx" (is_a obx class_objexpandpureval) obx)
  (let ( (oloc (get_field :oxpurval_loc obx))
	 (ocomm (get_field :oxpurval_comm obx))
	 (ocont (get_field :oxpurval_cont obx))
	 (otyp (get_field :obv_type obx))
	 )
    (assert_msg "check ocont" (is_multiple_or_null ocont) ocont)
    (assert_msg "check otyp" (is_a otyp class_ctype) otyp)
    (cond
     ((== otyp ctype_void)
      (shortbacktrace_dbg "outpucod_objexpandpureval pure void" 15)
      (if oloc
	  (let ( (:cstring comstr (the_null_cstring))
		 )
	    (warning_plain oloc "strange pure value with :void ctype")
	    (code_chunk 
	     fillcomstr_chk
	     #{ /* outpucod_objexpandpureval void $FILLCOMSTR_CHK */
	     static char buf_$FILLCOMSTR_CHK [80] ;
	     const char* comstr_$FILLCOMSTR_CHK = 
	        melt_string_str ((melt_ptr_t)$OCOMM) ;
	     if (comstr_$FILLCOMSTR_CHK)
	     snprintf(buf_$FILLCOMSTR_CHK, 
		      sizeof(buf_$FILLCOMSTR_CHK),
		      "xpurvalvoid: %s", comstr_$FILLCOMSTR_CHK) ;
	     else
	     snprintf(buf_$FILLCOMSTR_CHK, 
		      sizeof(buf_$FILLCOMSTR_CHK),
		      "[xpurvalvoid/%lx]", melt_obj_hash ((melt_ptr_t) $OBX)) ;
	     $COMSTR = buf_$FILLCOMSTR_CHK ;
	     /* outpucod_objexpandpureval void end $FILLCOMSTR_CHK */
	     }#)
	    (output_location oloc implbuf depth comstr))
	(add2sbuf_indentnl implbuf depth)
	)
      (when (and (null oloc) (is_string ocomm))
	(add2out implbuf "/*xpurval!")
	(add2sbuf_ccomstring implbuf ocomm)
	(add2out implbuf "*/ ")
	)
      (add2out implbuf "{")
      (foreach_in_multiple 
       (ocont)
       (comp :long ix)
       (output_c_code comp declbuf implbuf (+i depth 1)))
      (add2sbuf_indentnl implbuf (+i depth 1))
      (add2out implbuf "}")
      (add2sbuf_indentnl implbuf depth)
      )
     (:else
      ;; non-void ctype
      (if oloc
	  (let ( (:cstring comstr (the_null_cstring))
		 )
	    (code_chunk 
	     fillcomstr_chk
	     #{ /* outpucod_objexpandpureval nonvoid $FILLCOMSTR_CHK */
	     static char buf_$FILLCOMSTR_CHK [80] ;
	     const char* comstr_$FILLCOMSTR_CHK 
	        = melt_string_str ((melt_ptr_t)$OCOMM) ;
	     if (comstr_$FILLCOMSTR_CHK)
	     snprintf(buf_$FILLCOMSTR_CHK, 
		      sizeof(buf_$FILLCOMSTR_CHK),
		      "xpurval: %s", comstr_$FILLCOMSTR_CHK) ;
	     else
	     snprintf(buf_$FILLCOMSTR_CHK, 
		      sizeof(buf_$FILLCOMSTR_CHK),
		      "[xpurval/%lx]", melt_obj_hash ((melt_ptr_t) $OBX)) ;
	     $COMSTR = buf_$FILLCOMSTR_CHK ;
	     /* outpucod_objexpandpureval nonvoid end $FILLCOMSTR_CHK */
	     }#)
	    (output_raw_location oloc implbuf depth comstr))
	)
      (add2out implbuf "(")
      (foreach_in_multiple 
       (ocont)
       (comp :long ix)
       (output_c_code comp declbuf implbuf (+i depth 1)))
      (add2out implbuf ")")
      ))    
    ))
(install_method class_objexpandpureval output_c_code outpucod_objexpandpureval)



;;; output code for hook nth value
(defun outpucod_objhooknth (obh declbuf implbuf :long depth)
  (debug "outpucod_objhooknth obh=" obh)
  (assert_msg "check obh" (is_a obh class_objhooknth) obh)
  (assert_msg "check type" (== (get_field :obv_type obh) ctype_value) obh) 
  (let ( (ohook (unsafe_get_field :ohknth_hook obh))
	 (off (unsafe_get_field :ohknth_off obh))
	 (hknam (or (get_field :obl_cname ohook) (get_field :oie_cname ohook)))
	 )
    (cond ( (is_string hknam)
	    (add2out implbuf "/*hooknth*/MELT_HOOK_NTH_SLOT(\" fromhook ")
	    (add2sbuf_cencstring implbuf hknam)
	    (if (is_integerbox off)
		(add2out implbuf " #" off))
	    (add2out implbuf "\", (")
	    (output_c_code ohook declbuf implbuf depth)
	    (add2out implbuf "), /*rank=*/(")
	    (output_c_code off declbuf implbuf depth)
	    (add2out implbuf ")) "))
	  (:else
	   (add2out implbuf "/*hooknth*/MELT_HOOK_NTH_SLOT(\"anonhook\", (")
	   (output_c_code ohook declbuf implbuf depth)
	   (add2out implbuf "), /*rank=*/(")
	   (output_c_code off declbuf implbuf depth)
	   (add2out implbuf ")) "))
	  )
    )
  )
(install_method class_objhooknth output_c_code outpucod_objhooknth)
  

;;;

(defun outdeclinit_objinitobject (recv sbuf)
  (add2sbuf_strconst sbuf " struct MELT_OBJECT_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")		;
  )
(install_method class_objinitobject output_c_declinit outdeclinit_objinitobject)



;; initial fill for both objinitobject & its objinituniqueobject subclass
(defun outcinitfill_objinitobject (recv sbuf ptrstr :long depth)
  (debug "outcinitfill_objinitobject recv=" recv " ptrstr=" ptrstr)
  (assert_msg "outcinitfill_objinitobject check recv" (is_a recv class_objinitobject) recv)
  (assert_msg "outcinitfill_objinitobject check ptrstr" (is_string ptrstr) ptrstr)
  (let ( (odata (unsafe_get_field :oie_data recv)) 
	 (odiscr (unsafe_get_field :oie_discr recv))
	 (oname (unsafe_get_field :oie_cname recv))
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (oiopredef (unsafe_get_field :oio_predef recv))
	 (oclass (get_field :oio_class recv))
	 (:long depthp1 (+i depth 1))
	 )
    (debug "outcinitfill_objinitobject odata=" odata)
    (if odata (assert_msg "check odata" (is_a odata class_nrep_datainstance) odata))
    (let ( (odloc (if odata (unsafe_get_field :nrep_loc odata)))
	   (odhash (if odata (unsafe_get_field :ninst_hash odata)))
	   (odslots (if odata (unsafe_get_field :ninst_slots odata)))
	   (odobnum (if odata (unsafe_get_field :ninst_objnum odata)))
	   (:long nbslots
		  (cond  ( (is_multiple odslots)
			   (multiple_length odslots))
			 ( (is_a oclass class_class)
			   (multiple_length (get_field :class_fields oclass)))
			 (:else
			  (assert_msg "outcinitfill_objinitobject cannot compute nbslots" () odslots oclass)
			  0)))
	   )
      (if odloc (output_location odloc sbuf depthp1 "iniobj"))
      (add2sbuf_indentnl sbuf depth)
      (add2sbuf_strconst sbuf "/*iniobj ")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf "*/")
      (add2sbuf_indentnl sbuf depth)
      (if oiopredef
	  (progn
	    (add2sbuf_strconst sbuf "if (")
	    (output_predef oiopredef sbuf depth)
	    (add2sbuf_strconst sbuf " != (melt_ptr_t)&")
	    (add2sbuf_string sbuf ptrstr)
	    (add2sbuf_strconst sbuf "->")
	    (add2sbuf_string sbuf oname)
	    (add2sbuf_strconst sbuf ") {")
	    (add2sbuf_indentnl sbuf depthp1)
	    (if nbslots
		(progn
		  (add2sbuf_strconst sbuf "melt_assertmsg(\"check.predef length ")
		  (output_predef oiopredef sbuf depthp1)
		  (add2sbuf_strconst sbuf "\", melt_object_length((melt_ptr_t)(")
		  (output_predef oiopredef sbuf depthp1)
		  (add2sbuf_strconst sbuf ")) >= ")
		  (add2sbuf_longdec sbuf nbslots)
		  (add2sbuf_strconst sbuf ");")
		  (add2sbuf_indentnl sbuf depthp1)))
	    (add2sbuf_strconst sbuf "};")
	    (add2sbuf_indentnl sbuf depth)
	    (output_c_code olocvar () sbuf depth)
	    (add2sbuf_strconst sbuf " = ")
	    (output_predef oiopredef sbuf depth)
	    (add2sbuf_strconst sbuf ";")
	    (add2sbuf_indentnl sbuf depth)
	    )
	(progn
	  ;; for unique objects, only set locvar if it was not set;
	  ;; hence already existing symbols are not recreated
	  (if (is_a recv class_objinituniqueobject)
	      (progn
		(add2sbuf_strconst sbuf "/*uniqueobj*/ if (!")
		(output_c_code olocvar () sbuf depth)
		(add2sbuf_strconst sbuf ") ")
		(add2sbuf_indentnl sbuf depth)
		))
	  (output_c_code olocvar () sbuf (+i depth 1))
	  (add2sbuf_strconst sbuf " = (melt_ptr_t )&")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf oname)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf depth)
	  ))
      ;; Generate the check that odiscr is an object.  We generate a
      ;; test for melt_prohibit_garbcoll because code generated for
      ;; warmelt-first.melt temporarily violate the check, since all
      ;; major classes are not initialized at that time.
      (add2sbuf_strconst sbuf " if (MELT_LIKELY(!melt_prohibit_garbcoll)) melt_assertmsg(\"iniobj check.discr isobj ")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf "\", melt_magic_discr ((melt_ptr_t) (")
      (output_c_code odiscr () sbuf depth)
      (add2sbuf_strconst sbuf ")) == MELTOBMAG_OBJECT);")
      (add2sbuf_indentnl sbuf (+i depth 1)) 
      ;; generate the check of the objnum of odiscr
      (add2sbuf_strconst sbuf " if (MELT_LIKELY(!melt_prohibit_garbcoll)) melt_assertmsg(\"iniobj check.discr objmagic ")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf "\", ((meltobject_ptr_t) (")
      (output_c_code odiscr () sbuf depth)
      (add2sbuf_strconst sbuf "))->meltobj_magic == MELTOBMAG_OBJECT);")
      (add2sbuf_indentnl sbuf (+i depth 1))
      ;; generate the initialization of the class
      (add2sbuf_string sbuf ptrstr)
      (add2sbuf_strconst sbuf "->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".meltobj_class = (meltobject_ptr_t)(")
      (output_c_code odiscr () sbuf depth)
      (add2sbuf_strconst sbuf ");")
      (add2sbuf_indentnl sbuf depth)
      (if odobnum
	  (progn
	    (add2sbuf_strconst sbuf " ")
	    (add2sbuf_string sbuf ptrstr)
	    (add2sbuf_strconst sbuf "->")
	    (add2sbuf_string sbuf oname)
	    (add2sbuf_strconst sbuf ".obj_num = ")
	    (cond ( (is_integerbox odobnum)
		    (add2sbuf_longdec sbuf (get_int odobnum)))
		  ( (is_a odobnum class_symbol)
		    (add2sbuf_string sbuf (unsafe_get_field :named_name odobnum)))
		  (:else 
		   (debug "outcinitfill_objinitobject unexpected odobnum=" odobnum)
		   (assert_msg "outcinitfill_objinitobject unexpected odobnum" () odobnum)
		   ))
	    (add2sbuf_strconst sbuf ";")
	    (add2sbuf_indentnl sbuf depth)
	    ))
      (add2sbuf_strconst sbuf " ")
      (add2sbuf_string sbuf ptrstr)
      (add2sbuf_strconst sbuf "->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".obj_hash = ")
      (if odhash 
	  (add2sbuf_longdec sbuf (get_int odhash))
	(add2sbuf_strconst sbuf "melt_nonzerohash ()"))
      (add2sbuf_strconst sbuf ";")
      (add2sbuf_indentnl sbuf depth)
      (add2sbuf_strconst sbuf " ")
      (add2sbuf_string sbuf ptrstr)
      (add2sbuf_strconst sbuf "->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".obj_len = ")
      (add2sbuf_longdec sbuf nbslots)
      (add2sbuf_strconst sbuf ";")
      (add2sbuf_indentnl sbuf depth)
      ;; output the fill
      )
    (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (debug "outcinitfill_objinitobject huge sbuf=" sbuf)
	    (assert_msg "check limited sbuf" 
			(<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
    )
  )
(install_method class_objinitobject output_c_initial_fill outcinitfill_objinitobject)




(defun outcinitpredef_objinitobject (recv sbuf ptrstr :long depth)
  (debug recv "outcinitpredef_objinitobject recv=" recv " ptrstr=" ptrstr)
  (assert_msg "check recv" (is_a recv class_objinitobject) recv)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (assert_msg "check ptrstr" (is_string ptrstr) ptrstr)
  (let ( (odata (unsafe_get_field :oie_data recv)) 
	 (odiscr (unsafe_get_field :oie_discr recv))
	 (oname (unsafe_get_field :oie_cname recv))
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (oiopredef (unsafe_get_field :oio_predef recv))
	 )
    (assert_msg "check odata" (is_a odata class_nrep_datainstance) odata)
    (debug "outcinitpredef_objinitobject oiopredef=" oiopredef)
    (if (null oiopredef) (return ()))
    (if (is_a oiopredef class_nrep_nil) (return ()))
    (let ( (odloc (unsafe_get_field :nrep_loc odata))
	   )
      (output_location odloc sbuf depth "inipredef")
      (add2sbuf_strconst sbuf "/*inipredef ")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf "*/")
      (add2sbuf_indentnl sbuf depth)
      ;;
      (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	      (debug "outcinitpredef_objinitobject huge implbuf=" sbuf)
	      (assert_msg "check limited sbuf" 
			  (<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
      ;; we really initialize the predefined only if it was not initialized
      (cond
       ( (is_a oiopredef class_symbol)
	 (add2sbuf_strconst sbuf "if (!MELT_PREDEF(")
	 (add2sbuf_string sbuf (unsafe_get_field :named_name oiopredef))
	 (add2sbuf_strconst sbuf ")) MELT_STORE_PREDEF(")
	 (add2sbuf_string sbuf (unsafe_get_field :named_name oiopredef))
	 (add2sbuf_strconst sbuf ", (melt_ptr_t)&")
	 (add2sbuf_string sbuf ptrstr)
	 (add2sbuf_strconst sbuf "->")
	 (add2sbuf_string sbuf oname)
	 (add2sbuf_strconst sbuf ");")
	 (add2sbuf_indentnl sbuf 1)
	 (add2sbuf_strconst sbuf "else {")
	 (add2sbuf_indentnl sbuf 2)
	 (add2sbuf_strconst sbuf "MELTPREDEFIX(meltpredefinited,")
	 (add2sbuf_string sbuf (unsafe_get_field :named_name oiopredef))
	 (add2sbuf_strconst sbuf ") = 1;")
	 (add2sbuf_indentnl sbuf 2)
	 (add2sbuf_strconst sbuf "fnotice(stderr, \"MELT: predefined object %s already defined <%s:%d>\\n\", \"")
	 (add2sbuf_string sbuf (unsafe_get_field :named_name oiopredef))
	 (add2sbuf_strconst sbuf "\", __FILE__, __LINE__);")
	 (add2sbuf_indentnl sbuf 2)
	 (add2sbuf_strconst sbuf "};")
	 (add2sbuf_indentnl sbuf 1)
	 )
       ( (is_integerbox oiopredef)
	 (add2sbuf_strconst sbuf "if (!melt_fetch_predefined(")
	 (add2sbuf_longdec sbuf (get_int oiopredef))
	 (add2sbuf_strconst sbuf ")) melt_store_predefined(")
	 (add2sbuf_longdec sbuf (get_int oiopredef))
	 (add2sbuf_strconst sbuf ", (melt_ptr_t)&")
	 (add2sbuf_string sbuf ptrstr)
	 (add2sbuf_strconst sbuf "->")
	 (add2sbuf_string sbuf oname)
	 (add2sbuf_strconst sbuf ");")
	 (add2sbuf_indentnl sbuf 1)
	 (add2sbuf_strconst sbuf "else {")
	 (add2sbuf_indentnl sbuf 2)
	 (add2sbuf_strconst sbuf "meltpredefinited[")
	 (add2sbuf_longdec sbuf (get_int oiopredef))
	 (add2sbuf_strconst sbuf "] = 1;")
	 (add2sbuf_indentnl sbuf 2)
	 (add2sbuf_strconst sbuf "fnotice(\"MELT: predefined #%d already defined <%s:%d>\\n\", ")
	 (add2sbuf_longdec sbuf (get_int oiopredef))
	 (add2sbuf_strconst sbuf ", __FILE__, __LINE__);")
	 (add2sbuf_indentnl sbuf 2)
	 (add2sbuf_strconst sbuf "};")
	 (add2sbuf_indentnl sbuf 1)
;;;
	 )
       ( (null oiopredef)
	 (return ()))
       ( :else
	 (debug "outcinitpredef_objinitobject unexpected oiopredef=" oiopredef)
	 (assert_msg "outcinitpredef_objinitobject unexpected oiopredef" () oiopredef)
	 )))
    )
  )

(install_method class_objinitobject output_c_initial_predef outcinitpredef_objinitobject)

;;;;;;;;;;;;;;;;
(defun outcinitpredef_objinithook (recv sbuf ptrstr :long depth)
  (debug recv "outcinitpredef_objinithook recv=" recv " ptrstr=" ptrstr)
  (assert_msg "outcinitpredef_objinithook check recv" (is_a recv class_objinithook) recv)
  (assert_msg "outcinitpredef_objinithook check sbuf" (is_strbuf sbuf) sbuf)
  (assert_msg "outcinitpredef_objinithook check ptrstr" (is_string ptrstr) ptrstr)
  (let ( (odata (get_field :oie_data recv)) 
	 (odiscr (get_field :oie_discr recv))
	 (oname (get_field :oie_cname recv))
	 (olocvar (get_field :oie_locvar recv))
	 (opredef (get_field :oihk_predef recv))
	 (modvarbind (get_field :oihk_modvarbind recv))
	 (odloc (get_field :nrep_loc odata))
	 )
    (debug "outcinitpredef_objinithook opredef=" opredef "\n odata=" odata "\n oname=" oname)
    (if (null opredef) (return ()))
    (output_location odloc sbuf depth "inipredefhook")
    (add2out sbuf "/*inipredefhook " oname " */")
    (add2sbuf_indentnl sbuf depth)
    (cond
     ( (is_a opredef class_symbol)
       (let ( 
	     (opredname (get_field :named_name opredef))
	     )
	 (add2out sbuf 
		  ##{if (!MELT_PREDEF($OPREDNAME)) 
		  MELT_STORE_PREDEF($OPREDNAME, (melt_ptr_t)& $PTRSTR->$ONAME) ;
		  else {
		  MELTPREDEFIX(meltpredefinited,$OPREDNAME) = 1	;
		  fnotice(stderr, "MELT: predefined hook %s already defined <%s:%d>\n",
				  "$OPREDNAME", __FILE__, __LINE__) ;
		  }						    ;
		  }#)
	 (add2sbuf_indentnl sbuf 1)
	 ))
     ( (is_integerbox opredef)
       (let ( (:long predefnum (get_int opredef))
	      )
	 (add2out sbuf 
		  ##{if (!melt_fetch_predefined($PREDEFNUM))
		  melt_store_predefined($PREDEFNUM, (melt_ptr_t)& $PTRSTR->$ONAME) ;
		  else {
		  meltpredefinited[$PREDEFNUM] = 1 ;
		  fnotice(stderr, "MELT: predefined hook #%d already defined <%s:%d>\n",
				  $PREDEFNUM, __FILE__, __LINE__) ;
		  }
		  }#)
	 (add2sbuf_indentnl sbuf 1)
	 ))
     (:else
      (debug "outcinitpredef_objinithook unexpected opredef=" opredef)
      (assert_msg "outcinitpredef_objinithook bad predefined" () opredef)
      ))
    ))

(install_method class_objinithook output_c_initial_predef outcinitpredef_objinithook)


;;;;;;;;;;;;;;;;
(defun outdeclinit_objinitmultiple (recv sbuf)
  (add2sbuf_strconst sbuf " struct MELT_MULTIPLE_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinitmultiple output_c_declinit outdeclinit_objinitmultiple)


(defun outcinitfill_objinitmultiple (recv sbuf ptrstr :long depth)
  (debug "outcinitfill_objinitmultiple recv=" recv " ptrstr=" ptrstr)
  (assert_msg "outcinitfill_objinitmultiple check recv" (is_a recv class_objinitmultiple) recv)
  (assert_msg "outcinitfill_objinitmultiple check ptrstr" (is_string ptrstr) ptrstr)
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 )
    (add2sbuf_strconst sbuf "/*inimult ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf 1)
    (if olocvar
	(progn
	  (output_c_code olocvar () sbuf 1)
	  (add2sbuf_strconst sbuf " = (melt_ptr_t) &")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf 1)
	  ))
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = (meltobject_ptr_t)(")
    (output_c_code (unsafe_get_field :oie_discr recv) () sbuf 1)
    (add2sbuf_strconst sbuf ");")
    (add2sbuf_indentnl sbuf 1)
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".nbval = ")
    (add2sbuf_longdec sbuf (get_int recv))
    (add2sbuf_strconst sbuf ";")
    ;;
    (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outcinitfill_objinitmultiple huge sbuf" 15)
	    (debug "outcinitfill_objinitmultiple huge sbuf=" sbuf)
	    (assert_msg "check limited sbuf" 
			(<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
    ))
(install_method class_objinitmultiple output_c_initial_fill outcinitfill_objinitmultiple)

(defun outdeclinit_objinitclosure (recv sbuf)
  (add2sbuf_strconst sbuf " struct MELT_CLOSURE_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :oie_cname recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinitclosure output_c_declinit outdeclinit_objinitclosure)

(defun outcinitfill_objinitclosure (recv sbuf ptrstr :long depth)
  (debug "outcinitfill_objinitclosure recv=" recv " ptrstr=" ptrstr)
  (assert_msg "check recv" (is_a recv class_objinitclosure) recv)
  (assert_msg "check ptrstr" (is_string ptrstr) ptrstr)
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (orout (unsafe_get_field :oiclo_rout recv))
	 (:long depthp1 (+i 1 depth))
	 )
    (add2sbuf_strconst sbuf "/*iniclos ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf depthp1)
    (if olocvar
	(progn
					; (add2sbuf_strconst sbuf "/*inicloslocvar*/ ")
	  (output_c_code olocvar () sbuf depthp1)
	  (add2sbuf_strconst sbuf " = (melt_ptr_t) &")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf depthp1)
	  ))
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = (meltobject_ptr_t)(")
    (output_c_code (unsafe_get_field :oie_discr recv) () sbuf depthp1)
    (add2sbuf_strconst sbuf ");")
    (add2sbuf_indentnl sbuf depthp1)
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".nbval = ")
    (add2sbuf_longdec sbuf (get_int recv))
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf depthp1)
    (if orout
	(progn
	  (add2sbuf_strconst sbuf " ")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ".rout = (meltroutine_ptr_t) (")
	  (output_c_code orout () sbuf depthp1)
	  (add2sbuf_strconst sbuf ");")
	  (add2sbuf_indentnl sbuf depthp1)
	  ))
    ;;
    (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (debug "outcinitfill_objinitclosure huge sbuf=" sbuf)
	    (shortbacktrace_dbg "outcinitfill_objinitclosure huge sbuf" 15)
	    (assert_msg "check limited sbuf" 
			(<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
    ))
(install_method class_objinitclosure output_c_initial_fill outcinitfill_objinitclosure)


(defun outdeclinit_objinitroutine (recv sbuf)
  (add2sbuf_strconst sbuf " struct MELT_ROUTINE_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :oie_cname recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinitroutine output_c_declinit outdeclinit_objinitroutine)


(defun outcinitfill_objinitroutine (recv sbuf ptrstr :long depth)
  (debug recv "outcinitfill_objinitroutine recv=" recv " ptrstr=" ptrstr)
  (assert_msg "heck recv" (is_a recv class_objinitroutine) recv)
  (assert_msg "heck ptrstr" (is_string ptrstr) ptrstr)
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (ipro (unsafe_get_field :oir_procroutine recv))
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (ndatr (unsafe_get_field :oie_data recv))
	 )
    (add2sbuf_strconst sbuf "/*inirout ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf 1)
    (when olocvar
      (add2sbuf_strconst sbuf "/*iniroutlocvar*/ ")
      (output_c_code olocvar () sbuf 1)
      (add2sbuf_strconst sbuf " = (melt_ptr_t) &")
      (add2sbuf_string sbuf ptrstr)
      (add2sbuf_strconst sbuf "->")
      (add2sbuf_string sbuf cnam)
      (add2sbuf_strconst sbuf ";")
      (add2sbuf_indentnl sbuf 1)
      )
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = (meltobject_ptr_t)(")
    (output_c_code (unsafe_get_field :oie_discr recv) () sbuf 1)
    (add2sbuf_strconst sbuf ");")
    (add2sbuf_indentnl sbuf 1)
    (add2sbuf_strconst sbuf " strncpy (")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".routdescr, \"")
    (if (is_a ndatr class_nrep_dataroutine)
	(let ( (dnam (unsafe_get_field :ndata_name ndatr))
	       (dpro (unsafe_get_field :ndrou_proc ndatr))
	       )
	  (debug ndatr "outcinitfill_objinitroutine ndatr=" ndatr " dpro=" dpro)
	  (if (is_a dnam class_named)
	      (add2sbuf_cencstring sbuf (unsafe_get_field :named_name dnam)))
	  (if (is_a dpro class_nrep_routproc)
	      (let (  (dloc (unsafe_get_field :nrep_loc dpro))
		      (locfil (or (mixint_val dloc) (mixloc_val dloc)))
		      )
		(add2sbuf_strconst sbuf " @")
		(add2sbuf_cencstring sbuf locfil)
		(add2sbuf_strconst sbuf ":")
		(add2sbuf_longdec sbuf (get_int dloc))
		)
	    )
	  )
      (add2sbuf_cencstring sbuf cnam))
    (add2sbuf_strconst sbuf "\",  MELT_ROUTDESCR_LEN - 1);")
    (add2sbuf_indentnl sbuf 1)   
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".nbval = ")
    (add2sbuf_longdec sbuf (get_int recv))
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    (if ipro
	(progn
	  (debug "outcinitfill_objinitroutine ipro=" ipro)
	  (assert_msg "check ipro" (is_a ipro class_named) ipro)
	  (add2sbuf_strconst sbuf "MELT_ROUTINE_SET_ROUTCODE(&")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ", ")
	  (add2sbuf_string sbuf (unsafe_get_field :named_name ipro))
	  (add2sbuf_strconst sbuf ");")
	  (add2sbuf_indentnl sbuf 1)
	  )
      (progn
	(debug "outcinitfill_objinitroutine (noipro) recv=" recv)
	(shortbacktrace_dbg "outcinitfill_objinitroutine noipro" 12)
	(add2sbuf_strconst sbuf "#warning no procedure in objinitroutine ")
	(add2sbuf_string sbuf cnam)
	(add2sbuf_indentnl sbuf 1)
	)
      )
    )
  ;;
  (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	  (debug "outcinitfill_objinitroutine huge sbuf=" sbuf)
	  (shortbacktrace_dbg "outcinitfill_objinitroutine huge sbuf" 12)
	  (assert_msg "check limited sbuf" 
		      (<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
  )
(install_method class_objinitroutine output_c_initial_fill outcinitfill_objinitroutine)


;;;;;;;;;; hooks

(defun outdeclinit_objinithook (recv sbuf)
  (debug "outdeclinit_objinithook recv=" recv)
  (add2sbuf_strconst sbuf " struct MELT_HOOK_STRUCT(")
  (add2sbuf_longdec sbuf (multiple_length (get_field :oihk_cloval recv)))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (get_field :oie_cname recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinithook output_c_declinit outdeclinit_objinithook)



;;;; initial hooks
(defun outcinitfill_objinithook (recv sbuf ptrstr :long depth)
  (debug "outcinitfill_objinithook recv=" recv 
	 "\n.. of discrim:" (discrim recv) "\n.. ptrstr=" ptrstr)
  (assert_msg "check recv" (is_a recv class_objinithook) recv)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (let ( (cname (get_field :oie_cname recv))
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (ndatr (unsafe_get_field :oie_data recv))
	 (hkdata (get_field :oihk_data recv))
	 (hkproc (get_field :oihk_prochook recv))
	 (oclovaltup (get_field :oihk_cloval recv))
	 (opredef (get_field :oihk_predef recv))
	 (:long nbcloval (multiple_length oclovaltup))
	 (hkname (get_field :nrclop_name hkproc))
	 )
    (debug "outcinitfill_objinithook hkproc=" hkproc
	   "\n .. hkdata=" hkdata "\n .. opredef=" opredef)
    (add2sbuf_indentnl sbuf depth)
    (add2out sbuf ##{/*inihook $CNAME fromline $(this_line) */}#)
    (add2sbuf_indentnl sbuf (+i depth 1))
    (add2out sbuf " " ptrstr "->" cname ".discr = /*fromline " (this_line) "*/ (meltobject_ptr_t)(")
     (output_c_code (get_field :oie_discr recv) () sbuf (+i depth 1))
     (add2out sbuf ");")
     (add2sbuf_indentnl sbuf (+i depth 1))
     (add2out 
      sbuf 
      ##{   /*inihook $HKNAME data fromline $(this_line) */
      $PTRSTR->$CNAME.nbval = $NBCLOVAL				 ;
      MELT_HOOK_SET_ROUTCODE (&$PTRSTR->$CNAME, melthook_$HKNAME) ;
      $PTRSTR->$CNAME.hookdata = }#
      )
     (output_c_code hkdata () sbuf 1)
     (add2out sbuf ";")
     (add2sbuf_indentnl sbuf (+i depth 1))    
     (add2out sbuf "strncpy (" ptrstr "->" cname ".hookname, \"")
     (add2sbuf_cencstring sbuf hkname)
     (add2out sbuf "\", sizeof(" ptrstr "->" cname ".hookname)-1);")
     (add2sbuf_indentnl sbuf depth)
     (when opredef
       (add2out 
	sbuf 
	##{/*predefinedhook $OPREDEF for $CNAME*/
	if (!MELT_PREDEF($OPREDEF))
	MELT_STORE_PREDEF($OPREDEF, (melt_ptr_t) &$PTRSTR->$CNAME) ;
	}#)
       (add2sbuf_indentnl sbuf depth)
       )
     (when olocvar
       (output_c_code olocvar () sbuf 1)
       (add2out sbuf 
		##{ = /*inihooklocvar $HKNAME*/ (melt_ptr_t) &$PTRSTR->$CNAME ;
		}#)
       (add2sbuf_indentnl sbuf 1)
       )
     (add2out sbuf ##{/*done inihook $CNAME */}#)
     (add2sbuf_indentnl sbuf depth)
     ))
(install_method class_objinithook  output_c_initial_fill outcinitfill_objinithook)



;;;; strings
(defun outdeclinit_objinitstring (recv sbuf)
  (add2sbuf_strconst sbuf " struct MELT_STRING_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinitstring output_c_declinit outdeclinit_objinitstring)


(defun outcinitfill_objinitstring (recv sbuf ptrstr :long depth)
  (debug  "outcinitfill_objinitstring recv=" recv " ptrstr=" ptrstr)
  (assert_msg "check recv" (is_a recv class_objinitstring) recv)
  (assert_msg "check ptrstr" (is_string ptrstr) ptrstr)
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (strdata (unsafe_get_field :oie_data recv))
	 (:long datalen (string_length strdata))
	 )
    (add2sbuf_indentnl sbuf depth)
    (add2sbuf_strconst sbuf "/*inistring ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf (+i depth 1))
    (when olocvar
      (output_c_code olocvar () sbuf 1)
      (add2sbuf_strconst sbuf " = (melt_ptr_t) &")
      (add2sbuf_string sbuf ptrstr)
      (add2sbuf_strconst sbuf "->")
      (add2sbuf_string sbuf cnam)
      (add2sbuf_strconst sbuf ";")
      (add2sbuf_indentnl sbuf 1)
      )
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = (meltobject_ptr_t)(")
    (output_c_code (unsafe_get_field :oie_discr recv) () sbuf 1)
    (add2sbuf_strconst sbuf ");")
    (add2sbuf_indentnl sbuf 1)
    ;; we handle big enough strings specially
    (if (<i datalen 256)
	(progn 
	  (add2sbuf_strconst sbuf "/*small inistring*/ strncpy(")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ".val, \"")
	  (add2sbuf_cencstring sbuf strdata)
	  (add2sbuf_strconst sbuf "\", sizeof (") 
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ".val)-1);")
	  )
      ;; else datalen > 256
;;;;;;;;;;;;;;;;
      ;; the C standard gives some limitation on constant strings. We
      ;; avoid generating a huge constant string as single source to a
      ;; strcpy. We break that in a sequence of memcpy on big chunks
      ;; ended by a smaller strcpy.
      (let ( (:long ix 0)
	     )
	(debug "outcinitfill_objinitstring big datalen=" datalen)
	(add2sbuf_strconst sbuf "/*big inistring*/")
	(add2sbuf_indentnl sbuf 1)
	(forever
	 inistrloop
	 (debug "outcinitfill_objinitstring ix=" ix " sbuflen=" (strbuf_usedlength sbuf))
	 ;;
	 (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
		 (shortbacktrace_dbg "outcinitfill_objinitstring huge sbuf" 10)
		 (debug "outcinitfill_objinitstring huge sbuf=" sbuf)
		 (assert_msg "check limited sbuf" 
			     (<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
	 ;;
	 (cond
	  ;; end reached
	  ((>=i ix datalen) 
	   (exit inistrloop))
	  ;; end nearly reached
	  ((>i (+i ix 72) datalen)
	   (add2sbuf_strconst sbuf "/*end big inistring*/ strncpy(")
	   (add2sbuf_string sbuf ptrstr)
	   (add2sbuf_strconst sbuf "->")
	   (add2sbuf_string sbuf cnam)
	   (add2sbuf_strconst sbuf ".val + ")
	   (add2sbuf_longdec sbuf ix)
	   (add2sbuf_strconst sbuf ", \"")
	   (add2out_cencsubstring sbuf strdata ix (-i datalen ix))
	   (add2sbuf_strconst sbuf "\", sizeof (") 
	   (add2sbuf_string sbuf ptrstr)
	   (add2sbuf_strconst sbuf "->")
	   (add2sbuf_string sbuf cnam)
	   (add2sbuf_strconst sbuf ".val) - ")
	   (add2sbuf_longdec sbuf (+i ix 1))
	   (add2sbuf_strconst sbuf ");")
	   (add2sbuf_indentnl sbuf 1)
	   (exit inistrloop)
	   )
	  ;; very big remaining
	  ((<i ix (-i datalen 256))
	   (add2sbuf_strconst sbuf "/*really big chunk inistring*/")
	   (add2sbuf_indentnl sbuf 1)
	   (add2sbuf_strconst sbuf "memcpy (")
	   (add2sbuf_string sbuf ptrstr)
	   (add2sbuf_strconst sbuf "->")
	   (add2sbuf_string sbuf cnam)
	   (add2sbuf_strconst sbuf ".val + ")
	   (add2sbuf_longdec sbuf ix)
	   (add2sbuf_strconst sbuf ",")
	   ;; compile time catanation of constant string
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf "\"")
	   (add2out_cencsubstring sbuf strdata ix 64)
	   (add2sbuf_strconst sbuf "\"")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf "\"")
	   (add2out_cencsubstring sbuf strdata (+i 64 ix) 64)
	   (add2sbuf_strconst sbuf "\"")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf "\"")
	   (add2out_cencsubstring sbuf strdata (+i 128 ix) 64)
	   (add2sbuf_strconst sbuf "\"")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf "\"")
	   (add2out_cencsubstring sbuf strdata (+i 192 ix) 64)
	   (add2sbuf_strconst sbuf "\",")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf " /*big*/ 256);")
	   (add2sbuf_indentnl sbuf 1)
	   ;;(setq ix (+i ix 256))
	   (increment ix 256)
	   (void)
	   )
	  ;; less big remaining
	  ((<i ix (-i datalen 128))
	   (add2sbuf_strconst sbuf "/*quite big chunk inistring*/")
	   (add2sbuf_indentnl sbuf 1)
	   (add2sbuf_strconst sbuf "memcpy (")
	   (add2sbuf_string sbuf ptrstr)
	   (add2sbuf_strconst sbuf "->")
	   (add2sbuf_string sbuf cnam)
	   (add2sbuf_strconst sbuf ".val + ")
	   (add2sbuf_longdec sbuf ix)
	   (add2sbuf_strconst sbuf ",")
	   ;; compile time catanation of constant string
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf "\"")
	   (add2out_cencsubstring sbuf strdata ix 64)
	   (add2sbuf_strconst sbuf "\"")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf "\"")
	   (add2out_cencsubstring sbuf strdata (+i 64 ix) 64)
	   (add2sbuf_strconst sbuf "\",")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf " /*lessbig*/ 128);")
	   (add2sbuf_indentnl sbuf 1)
	   (increment ix 128)
	   ;;(setq ix (+i ix 128))
	   (void)
	   )
	  ;; even less big remaining
	  ((<i ix (-i datalen 64))
	   (add2sbuf_strconst sbuf "/*almost big chunk inistring*/")
	   (add2sbuf_indentnl sbuf 1)
	   (add2sbuf_strconst sbuf "memcpy (")
	   (add2sbuf_string sbuf ptrstr)
	   (add2sbuf_strconst sbuf "->")
	   (add2sbuf_string sbuf cnam)
	   (add2sbuf_strconst sbuf ".val + ")
	   (add2sbuf_longdec sbuf ix)
	   (add2sbuf_strconst sbuf ",")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf "\"")
	   (add2out_cencsubstring sbuf strdata ix 64)
	   (add2sbuf_strconst sbuf "\",")
	   (add2sbuf_indentnl sbuf 8)
	   (add2sbuf_strconst sbuf " /*evenlessbig*/ 64);")
	   (add2sbuf_indentnl sbuf 1)
	   (increment ix 64)
	   ;;(setq ix (+i ix 64))
	   (void)
	   )
	  )
	 (void)
	 )
	;;
	;;
	;;
	(cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
		(shortbacktrace_dbg "outcinitfill_objinitstring huge sbuf" 10)
		(debug "outcinitfill_objinitstring huge declbuf=" sbuf)
		(assert_msg "check limited sbuf" 
			    (<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont))
			    sbuf)))
	))
    (add2sbuf_indentnl sbuf 1)
    (add2out sbuf ##{$PTRSTR->$CNAM.val[$DATALEN] = (char)0 ; }#
	     )
    (add2sbuf_indentnl sbuf 1)
    (add2out sbuf ##{$PTRSTR->$CNAM.slen = $DATALEN ; }#
	     )
    (add2sbuf_indentnl sbuf 1)
    ))
(install_method class_objinitstring output_c_initial_fill outcinitfill_objinitstring)


;;;; boxed integers
(defun outdeclinit_objinitboxedinteger (recv sbuf)
  (add2sbuf_strconst sbuf " struct meltint_st ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinitboxinteger output_c_declinit outdeclinit_objinitboxedinteger)


(defun outcinitfill_objinitboxedinteger (recv sbuf ptrstr :long depth)
  (debug "outcinitfill_objinitboxedinteger recv=" recv " ptrstr=" ptrstr)
  (assert_msg "check recv" (is_a recv class_objinitboxinteger) recv)
  (assert_msg "check ptrstr" (is_string ptrstr) ptrstr)
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (odata (unsafe_get_field :oie_data recv))
	 (:long depthp1 (+i 1 depth))
	 )
    (add2sbuf_strconst sbuf "/*iniboxint ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf depthp1)
    (if olocvar
	(progn
	  (output_c_code olocvar () sbuf depthp1)
	  (add2sbuf_strconst sbuf " = (melt_ptr_t) &")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf depthp1)
	  ))
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = (meltobject_ptr_t)(")
    (output_c_code (unsafe_get_field :oie_discr recv) () sbuf depthp1)
    (add2sbuf_strconst sbuf ");")
    (add2sbuf_indentnl sbuf depthp1)
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".val = ")
    (add2sbuf_longdec sbuf (get_int odata))
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf depthp1)
    ;;
    (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outcinitfill_objinitboxedinteger huge sbuf" 10)
	    (debug "outcinitfill_objinitboxedinteger huge sbuf=" sbuf)
	    (assert_msg "check limited sbuf" 
			(<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
    ))
(install_method class_objinitboxinteger output_c_initial_fill outcinitfill_objinitboxedinteger)




;;;; pairs
(defun outdeclinit_objinitpair (recv sbuf)
  (add2sbuf_strconst sbuf " struct meltpair_st ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinitpair output_c_declinit outdeclinit_objinitpair)


(defun outcinitfill_objinitpair (recv sbuf ptrstr :long depth)
  (debug "outcinitfill_objinitpair recv=" recv " ptrstr=" ptrstr)
  (assert_msg "check recv" (is_a recv class_objinitpair) recv)
  (assert_msg "check ptrstr" (is_string ptrstr) ptrstr)
  (let  ( (cnam (unsafe_get_field :oie_cname recv)) 
	  (olocvar (unsafe_get_field :oie_locvar recv))
	  (odata (unsafe_get_field :oie_data recv))
	  (:long depthp1 (+i 1 depth))
	  )
    (add2sbuf_strconst sbuf "/*inipair ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf depthp1)
    (if olocvar
	(progn
	  (output_c_code olocvar () sbuf depthp1)
	  (add2sbuf_strconst sbuf " = (melt_ptr_t) &")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf depthp1)
	  ))
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = (meltobject_ptr_t)(")
    (output_c_code (unsafe_get_field :oie_discr recv) () sbuf depthp1)
    (add2sbuf_strconst sbuf ");")
    (add2sbuf_indentnl sbuf depth)
    ;;
    (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outcinitfill_objinitpair huge sbuf" 10)
	    (debug "outcinitfill_objinitpair huge sbuf=" sbuf)
	    (assert_msg "check limited sbuf" 
			(<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
    ))
(install_method class_objinitpair output_c_initial_fill outcinitfill_objinitpair)
;;;;;;;;;;;;;;;;

;;;; lists
(defun outdeclinit_objinitlist (recv sbuf)
  (add2sbuf_strconst sbuf " struct meltlist_st ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")
  )
(install_method class_objinitlist output_c_declinit outdeclinit_objinitlist)


(defun outcinitfill_objinitlist (recv sbuf ptrstr :long depth)
  (debug "outcinitfill_objinitlist recv=" recv " ptrstr=" ptrstr)
  (assert_msg "check recv" (is_a recv class_objinitlist) recv)
  (assert_msg "check ptrstr" (is_string ptrstr) ptrstr) 
  (let  ( (cnam (unsafe_get_field :oie_cname recv)) 
	  (olocvar (unsafe_get_field :oie_locvar recv))
	  (odata (unsafe_get_field :oie_data recv))
	  (:long depthp1 (+i 1 depth))
	  )
    (add2sbuf_strconst sbuf "/*inilist ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf depthp1)
    (if olocvar
	(progn
	  (output_c_code olocvar () sbuf depthp1)
	  (add2sbuf_strconst sbuf " = (melt_ptr_t) &")
	  (add2sbuf_string sbuf ptrstr)
	  (add2sbuf_strconst sbuf "->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf depthp1)
	  ))
    (add2sbuf_strconst sbuf " ")
    (add2sbuf_string sbuf ptrstr)
    (add2sbuf_strconst sbuf "->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = (meltobject_ptr_t)(")
    (output_c_code (unsafe_get_field :oie_discr recv) () sbuf depthp1)
    (add2sbuf_strconst sbuf ");")
    (add2sbuf_indentnl sbuf depth)
    ;;
    (cond ( (>i (strbuf_usedlength sbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outcinitfill_objinitlist huge sbuf" 10)
	    (debug "outcinitfill_objinitlist huge sbuf=" sbuf)
	    (assert_msg "check limited sbuf" 
			(<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)))
    )
  )
(install_method class_objinitlist output_c_initial_fill outcinitfill_objinitlist)
;;;;;;;;;;;;;;;;

(defun outpucod_anydiscr (any declbuf implbuf :long depth)
  (debug "outpucod_anydiscr any=" any)
  (outcstring_err "* output_c_code unimplemented receiver discriminator ")
  (let ( (discr (discrim any)) ) 
    (outstr_err (unsafe_get_field :named_name discr))
    (outnewline_err)
    (debug  "outpucod_anydiscr discr=" discr))
  (assert_msg "@@ outpucod_anydiscr not able to output" () any)
  )
(install_method discr_any_receiver output_c_code outpucod_anydiscr)


  ;;
(defun outpucod_null (nul declbuf implbuf :long depth)
  (shortbacktrace_dbg "outpucod_null" 12)
  (add2out implbuf ##{ /*reallynil*/ NULL }#)
  )
(install_method discr_null_receiver output_c_code outpucod_null)

;;; catchall for outputting any stuff
(defun outpucod_catchall_root (anyr declbuf implbuf :long depth)
  (debug anyr "outpucod_catchall_root anyr=" anyr)
  (display_debug_message anyr "outpucod_catchall_root anyr")
  (outcstring_err "* output_c_code unimplemented receiver class ")
  (let ( (discr (discrim anyr)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@ outpucod_catchall_root not able to output" () anyr)
  )
(install_method class_root output_c_code outpucod_catchall_root)

;;; common code to output a location

;;; just output the #line directive
(defun output_raw_location (loc implbuf :long depth :cstring msg)
  (when loc
    (add2sbuf_indentnl implbuf 0)
    (cond ( (is_mixint loc) 
	    (add2sbuf_strconst implbuf "#ifndef MELTGCC_NOLINENUMBERING")
	    (add2sbuf_indentnl implbuf 0)
;;; we don't output #line in a single draw to make
;;; grep -v '#line' work better even without the
;;; start-of-line caret...
	    (add2sbuf_strconst implbuf "#")
	    (add2sbuf_strconst implbuf "line ")
	    (add2sbuf_longdec implbuf (get_int loc))
	    (add2sbuf_strconst implbuf " \"")
	    (add2sbuf_string implbuf (mixint_val loc))
	    (add2sbuf_strconst implbuf "\""))
	  ( (is_mixloc loc)
	    (add2sbuf_strconst implbuf "#ifndef MELTGCC_NOLINENUMBERING")
	    (add2sbuf_indentnl implbuf 0)
	    (add2sbuf_strconst implbuf "#")
	    (add2sbuf_strconst implbuf "line ")
	    (add2sbuf_longdec implbuf (mixloc_locline loc))
	    (add2sbuf_strconst implbuf "   \"")
	    (add2sbuf_strconst implbuf (mixloc_locbasefile loc))
	    (add2sbuf_strconst implbuf "\""))
	  (:else
	   (assert_msg "unexpected loc" () loc)
	   )
	  )
    (when msg 
      (add2sbuf_strconst implbuf " /**::")
      (add2sbuf_ccomconst implbuf msg)
      (add2sbuf_strconst implbuf "::**/")
      )
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#endif /*MELTGCC_NOLINENUMBERING*/")
    (add2sbuf_indentnl implbuf depth)
    ;;
    (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "output_raw_location huge implbuf" 12)
	    (debug "output_raw_location huge implbuf=" implbuf)
	    (assert_msg "check limited implbuf" 
			(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
    ))

  ;; we really want to avoid outputing the same location twice, so we
  ;; keep the previous location and implbuf

(definstance prevloc_container class_reference)
(definstance previmplbuf_container class_reference)

  ;; return the line number and file name of a location
(defun line_and_file_of_location (loc)
  (cond
   ( (is_mixint loc) 
     (return (make_integerbox discr_integer (get_int loc))
	     (mixint_val loc))
     )
   ( (is_mixloc loc)
     (return (make_integerbox discr_integer  (mixloc_locline loc))
	     (make_string_mixloc_file discr_string loc)))
   ( :else
     (return () ()))
   )
  )

;; output the location & set the frame's location
(defun output_location (loc implbuf :long depth :cstring msg)
  (let ( (prevloc (unsafe_get_field :referenced_value prevloc_container))
	 (prevbuf (unsafe_get_field :referenced_value previmplbuf_container))
	 )
    (if (== prevbuf implbuf)
	(if (or (== prevloc loc)
		(and (==i (get_int loc) (get_int prevloc))
		     (== (mixloc_val loc) (mixloc_val prevloc))))
	    (progn
	      (if msg (progn 
			(add2sbuf_strconst implbuf "/*^")
			(add2sbuf_ccomconst implbuf msg)
			(add2sbuf_strconst implbuf "*/")
			))
	      (add2sbuf_indentnl implbuf 0)
	      (add2sbuf_strconst implbuf "#ifndef MELTGCC_NOLINENUMBERING")
	      (add2sbuf_indentnl implbuf 0)
	      (cond ( (is_mixint loc) 
;;; we don't output #line in a single draw to make
;;; grep -v '#line' work better even without the
;;; start-of-line caret...
		      (add2sbuf_strconst implbuf "#")
		      (add2sbuf_strconst implbuf "line ")
		      (add2sbuf_longdec implbuf (get_int loc))
		      )
		    ( (is_mixloc loc)
		      (add2sbuf_strconst implbuf "#")
		      (add2sbuf_strconst implbuf "line ")
		      (add2sbuf_longdec implbuf (mixloc_locline loc))
		      )
		    )
	      (add2sbuf_indentnl implbuf 0)
	      (add2sbuf_strconst implbuf "#endif")
	      (add2sbuf_indentnl implbuf depth)
	      ;;
	      (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
		      (shortbacktrace_dbg "output_location huge implbuf" 12)
		      (debug "output_location huge implbuf=" implbuf)
		      (assert_msg "check limited implbuf" 
				  (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
	      (return)
	      )
	  )
      )
    (unsafe_put_fields  prevloc_container :referenced_value loc)
    (unsafe_put_fields  previmplbuf_container :referenced_value implbuf)
    ;;
    (cond
     ( (is_mixint loc) 
       (add2sbuf_strconst implbuf "MELT_LOCATION(\"")
       (add2sbuf_string implbuf (mixint_val loc))
       (add2sbuf_strconst implbuf ":")
       (add2sbuf_longdec implbuf (get_int loc))
       (if msg (progn
		 (add2sbuf_strconst implbuf ":/ ")
		 (add2sbuf_strconst implbuf msg)
		 ))
       (add2sbuf_strconst implbuf "\");")
       )
     ( (is_mixloc loc)
       (add2sbuf_strconst implbuf "MELT_LOCATION(\"")
       (add2sbuf_string implbuf (mixloc_val loc))
       (add2sbuf_strconst implbuf ":")
       (add2sbuf_longdec implbuf (get_int loc))
       (if msg (progn
		 (add2sbuf_strconst implbuf ":/ ")
		 (add2sbuf_strconst implbuf msg)
		 ))
       (add2sbuf_strconst implbuf "\");")
       )
     )
    (output_raw_location loc implbuf depth msg)
    ))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; output the code for declaring the current frame struct
(defun output_curframe_declstruct (rou dsbuf)
  (debug "output_curframe_declstruct rou=" rou)
  (let (
	(obody (unsafe_get_field :obrout_body rou))
	(onbval (unsafe_get_field :obrout_nbval rou))
	(onblong (unsafe_get_field :obrout_nblong rou))
	(:long nbval (get_int onbval))
	(:long nblong (get_int onblong))
	(:long isinitial 
	       (or (is_a rou class_initialroutineobj)
		   (is_a rou class_initial_extension_routineobj)
		   ))
	(others (unsafe_get_field :obrout_others rou))
	)       
    (add2sbuf_indentnl dsbuf 0)
    (add2out dsbuf "/** start of frame for " (get_field :named_name rou) 
	     " of " (get_field :named_name (discrim rou))
	     " from " (this_line) "**/")
    (add2sbuf_indentnl dsbuf 0)    (add2sbuf_indentnl dsbuf 0)
    (let ( (classyframename 
	    (cond
	     (isinitial
	      (initial_classy_frame_name rou))
	     ((is_a rou class_named)
	      (string4out discr_verbatim_string "MeltFrame_" (unsafe_get_field :named_name rou)))
	     (:else
	      (debug "output_curframe_declstruct bad routine rou=" rou)
	      (assert_msg "unexpected routine" () rou)
	      )))
	   )
      (add2out dsbuf " /*curframdeclclassy*/ class " classyframename "// fromline " (this_line))
      (add2sbuf_indentnl dsbuf 1)
      (add2out dsbuf " : public Melt_CallFrameWithValues<" nbval "> {")
      (add2sbuf_indentnl dsbuf 1)
      (add2out dsbuf "public: /* fromline " (this_line) "*/")
      (add2sbuf_indentnl dsbuf 1)
      (when nblong 
	(add2out dsbuf "long mcfr_varnum[" nblong "];")
	(add2sbuf_indentnl dsbuf 1))
      (when (not nblong)
	(add2out dsbuf "// no classy longs")
	(add2sbuf_indentnl dsbuf 1))
      (when others
	(add2out dsbuf "/*classy others*/")
	(add2sbuf_indentnl dsbuf 1)
	(foreach_pair_component_in_list
	 (others)
	 (curpair oloc)
	 (assert_msg "check other oloc" (is_a oloc class_objlocv) oloc)
	 (let ( (octyp (unsafe_get_field :obv_type oloc))
		(oname (unsafe_get_field :obl_cname oloc))
		)
	   (assert_msg "check octyp" (is_a octyp class_ctype) octyp)
	   (add2sbuf_string dsbuf (unsafe_get_field :ctype_cname octyp))
	   (add2sbuf_strconst dsbuf " ")
	   (add2sbuf_string dsbuf oname)
	   (add2sbuf_strconst dsbuf ";")
	   (add2sbuf_indentnl dsbuf 1))))
      ;;
      (when (null others)
	(add2out dsbuf "// no classy others")
	(add2sbuf_indentnl dsbuf 1))
      (add2out dsbuf "long _meltsparel;")
      (add2sbuf_indentnl dsbuf 1)
      ;;
      (add2out dsbuf "void melt_mark_stuff (void) {")
      (add2sbuf_indentnl dsbuf 2)
      (foreach_pair_component_in_list
       (others)
       (curpair oloc)
       (let ( (octyp (unsafe_get_field :obv_type oloc))
	      (oname (unsafe_get_field :obl_cname oloc))
	      )
	 (when (is_a octyp class_ctype_gty)
	   (let ( (ctymark (unsafe_get_field :ctype_marker octyp))
		  )
	     (when ctymark
	       (add2out dsbuf "/*marking " (get_field :ctype_cname octyp) "*/")
	       (add2sbuf_indentnl dsbuf 2)
	       (add2out dsbuf ctymark " (" oname ");")
	       (add2sbuf_indentnl dsbuf 2))))
	 ))
      (add2out dsbuf "} /*end melt_mark_stuff*/")
      (add2sbuf_indentnl dsbuf 1)
      (add2out dsbuf "virtual void melt_mark_ggc_data (void) {")
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf "melt_mark_values ();")
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf "melt_mark_stuff ();")
      (add2sbuf_indentnl dsbuf 1)
      (add2out dsbuf "}; /*end melt_mark_ggc_data*/")
      (add2sbuf_indentnl dsbuf 1)
      (add2out dsbuf classyframename "(meltclosure_ptr_t clos) //the closure constructor fromline " (this_line))
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf " : Melt_CallFrameWithValues<" nbval "> (")
      (add2sbuf_indentnl dsbuf 0)
      (add2out dsbuf "#if ENABLE_CHECKING /*fromline " (this_line) "*/")
      (add2sbuf_indentnl dsbuf 3)
      (add2out dsbuf " __FILE__, __LINE__,")
      (add2sbuf_indentnl dsbuf 0)
      (add2out dsbuf "#endif /* ENABLE_CHECKING fromline " (this_line) "*/")
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf " sizeof(" classyframename "), clos) {};")
      (add2sbuf_indentnl dsbuf 1)
      (add2out dsbuf classyframename "() //the constructor fromline " (this_line))
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf " : Melt_CallFrameWithValues<" nbval "> (")
      (add2sbuf_indentnl dsbuf 0)
      (add2out dsbuf "#if ENABLE_CHECKING /*fromline " (this_line) "*/")
      (add2sbuf_indentnl dsbuf 3)
      (add2out dsbuf " __FILE__, __LINE__,")
      (add2sbuf_indentnl dsbuf 0)
      (add2out dsbuf "#endif /* ENABLE_CHECKING fromline " (this_line) "*/")
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf " sizeof(" classyframename ")) {};")
      (add2sbuf_indentnl dsbuf 0)
      (add2out dsbuf "#if ENABLE_CHECKING /*fromline " (this_line) "*/")
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf classyframename "(const char*fil, int lin) //the constructor fromline " (this_line))
      (add2sbuf_indentnl dsbuf 2)
      (add2out dsbuf " : Melt_CallFrameWithValues<" nbval "> (fil,lin, sizeof(" classyframename ")) {};")
      (when (is_a rou class_procroutineobj)
	(add2sbuf_indentnl dsbuf 2)
	(add2out dsbuf classyframename "(const char*fil, int lin, meltclosure_ptr_t clos) //the closure constructor fromline " (this_line))
	(add2sbuf_indentnl dsbuf 2)
	(add2out dsbuf " : Melt_CallFrameWithValues<" nbval "> (fil,lin, sizeof(" classyframename "), clos) {};")
	)
      (add2sbuf_indentnl dsbuf 0)
      (add2out dsbuf "#endif /* ENABLE_CHECKING fromline " (this_line) "*/")
      (add2sbuf_indentnl dsbuf 2)
      (when (is_a rou class_hookroutineobj)
	(add2sbuf_indentnl dsbuf 1)
	(add2out dsbuf classyframename "(melthook_ptr_t hook) //the hook constructor fromline " (this_line))
	(add2sbuf_indentnl dsbuf 2)
	(add2out dsbuf " : Melt_CallFrameWithValues<" nbval "> (")
	(add2sbuf_indentnl dsbuf 0)
	(add2out dsbuf "#if ENABLE_CHECKING /*fromline " (this_line) "*/")
	(add2sbuf_indentnl dsbuf 3)
	(add2out dsbuf " __FILE__, __LINE__,")
	(add2sbuf_indentnl dsbuf 0)
	(add2out dsbuf "#endif /* ENABLE_CHECKING fromline " (this_line) "*/")
	(add2sbuf_indentnl dsbuf 2)
	(add2out dsbuf " sizeof(" classyframename "), hook) {};")
	(add2sbuf_indentnl dsbuf 0)
	(add2out dsbuf "#if ENABLE_CHECKING /*fromline " (this_line) "*/")
	(add2sbuf_indentnl dsbuf 2)
	(add2out dsbuf classyframename "(const char*fil, int lin, melthook_ptr_t hook) //the hook constructor fromline " (this_line))
	(add2sbuf_indentnl dsbuf 2)
	(add2out dsbuf " : Melt_CallFrameWithValues<" nbval "> (fil,lin, sizeof(" classyframename "), hook) {};")
	(add2sbuf_indentnl dsbuf 0)
	(add2out dsbuf "#endif /* ENABLE_CHECKING fromline " (this_line) "*/")
	(add2sbuf_indentnl dsbuf 2)
	)
      (add2sbuf_indentnl dsbuf 0)
      (add2out dsbuf "}; // end  class " classyframename)
      (add2sbuf_indentnl dsbuf 0)
      (add2sbuf_indentnl dsbuf 0)
      )
    (add2sbuf_indentnl dsbuf 0)
    (add2out dsbuf "/** end of frame for " (get_field :named_name rou) " fromline " (this_line)"**/")
    (add2sbuf_indentnl dsbuf 0)
    ;; end of curframe
    ))



;;; output the code for declaring and initializing the current frame 
(defun output_curframe_declstruct_init (declstruct rou implbuf)
  (debug "output_curframe_declstruct_init declstruct= " declstruct 
	 "\n.. rou=" rou
	 "\n .. of discrim=" (discrim rou))
  (assert_msg "check rou" (is_a rou class_routineobj) rou)
  (assert_msg "check declstruct" (is_closure declstruct) declstruct)
  (assert_msg "check implbuf" (is_strbuf implbuf) implbuf)
  (let (
	(obody (unsafe_get_field :obrout_body rou))
	(onbval (unsafe_get_field :obrout_nbval rou))
	(onblong (unsafe_get_field :obrout_nblong rou))
	(:long nbval (get_int onbval))
	(:long nblong (get_int onblong))
	(:long isinitial 
	       (or (is_a rou class_initialroutineobj)
		   (is_a rou class_hookroutineobj)
		   (is_a rou class_initial_extension_routineobj)
		   ))
	(:long minihash
	       (if isinitial (+i 1 (%iraw (obj_hash rou) 4096)) 0))
	(others (unsafe_get_field :obrout_others rou))
	(rouname (get_field :named_name rou))
	)       
    ;; output call counter for debugging
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#if MELT_HAVE_DEBUG")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " static long melt_call_counter__;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " long melt_thiscallcounter__ ATTRIBUTE_UNUSED = ++ melt_call_counter__;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef meltcallcount")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#define meltcallcount melt_thiscallcounter__")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#else")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef meltcallcount")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#define meltcallcount 0L")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#endif")
    (add2sbuf_indentnl implbuf 0)
    (debug "output_curframe_declstruct_init declstruct=" declstruct)
    (add2out implbuf "//// emitted by output_curframe_declstruct_init using "
	     (routine_descr (closure_routine declstruct)) "\n")
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf "/* start of frame for routine " rouname " fromline " (this_line) " */")
    (add2sbuf_indentnl implbuf 0)
    (declstruct rou implbuf)
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf "/* end of frame for routine " rouname " fromline " (this_line) " */")
    (add2sbuf_indentnl implbuf 0)
    ;;
    (add2sbuf_indentnl implbuf 0)
    (cond 
     ( (is_a rou class_procroutineobj)
       (add2out implbuf "/* classy proc frame " rouname " */ MeltFrame_" rouname " "))
     ( (is_a rou class_hookroutineobj)
       (add2out implbuf "/* classy hook frame " rouname " */ MeltFrame_" rouname " "))  
     ( (is_a rou class_initial_extension_routineobj)
       (add2out implbuf "/* classy extension frame " rouname " */\n"
		(initial_classy_frame_name rou)  " ")
       )     
     ( (is_a rou class_initialroutineobj)
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf "debugeprintf(\"sizeof Melt_InitialFrame in " rouname "=%d\", (int) sizeof(Melt_InitialFrame));")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf "/* classy initial frame " rouname " fromline " (this_line) "*/ Melt_InitialFrame "))
     ( :else
       (debug "output_curframe_declstruct_init classy bad routine=" rou)
       (assert_msg "unexpected routine for classy frame declaration" () rou))
     )
     ;;
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf "    meltfram__ /*declfrastruct fromline " (this_line) "*/")
    (add2sbuf_indentnl implbuf 0)
    (debug "output_curframe_declstruct_init classy rou=" rou)
    (cond 
     ( (is_a rou class_procroutineobj)
       (add2out implbuf "/*classyprocarg " rouname " fromline " (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#if ENABLE_CHECKING")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf " (__FILE__, __LINE__, meltclosp_) /* fromline " (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#else /*ENABLE_CHECKING */")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf " (meltclosp_) /* fromline " (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#endif /*ENABLE_CHECKING */")
       (add2sbuf_indentnl implbuf 0)
       (void)
       )
     ( (is_a rou class_hookroutineobj)
       (add2out implbuf "/*classyhookarg " rouname  " fromline " (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#if ENABLE_CHECKING")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf " (__FILE__, __LINE__, (meltcast_melthook_st(melthookdatap)) /* fromline " (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#else ENABLE_CHECKING")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf " (meltcast_melthook_st(melthookdatap)) /* fromline " (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#endif /*ENABLE_CHECKING */")
       (add2sbuf_indentnl implbuf 0)
       (void)
       )
     ( (is_a rou class_initial_extension_routineobj)
       (add2out implbuf "/*classyinitextensionarg " rouname " fromline " (this_line) "*/")
       (void)
       )
     ( (is_a rou class_initialroutineobj)
       (add2out implbuf "/*classyinitroutinearg " rouname " fromline " (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#if ENABLE_CHECKING")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf "/*classyinitroutfram fromline " (this_line) ":*/ (__FILE__, __LINE__)")
       (add2sbuf_indentnl implbuf 0)
       (add2out implbuf "#endif /*ENABLE_CHECKING fromline" (this_line) "*/")
       (add2sbuf_indentnl implbuf 0)
       (void)
       )
     )
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf "#define meltframe meltfram__")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))




;;; output code for a procroutine
(defun outpucod_procroutine (prou declbuf implbuf :long depth)
  (assert_msg "check prou" (is_a prou class_procroutineobj) prou)
  (let ( (onam (unsafe_get_field :named_name prou)) 
	 (obody (unsafe_get_field :obrout_body prou))
	 (onbval (unsafe_get_field :obrout_nbval prou))
	 (onblong (unsafe_get_field :obrout_nblong prou))
	 (:long nbval (get_int onbval))
	 (:long nblong (get_int onblong))
	 (others (unsafe_get_field :obrout_others prou))
	 (ogargs (unsafe_get_field :oprout_getargs prou))
	 (oretval (unsafe_get_field :obrout_retval prou))
	 (orloc (unsafe_get_field :oprout_loc prou))
	 (ofunam (unsafe_get_field :oprout_funam prou))
	 (orestnam (unsafe_get_field :oprout_restnam prou))
	 )
    (if (not (is_string ofunam)) 
	(setq ofunam '"**"))
    ;; output the declaration
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (output_raw_location orloc implbuf 0 "proc")
    (add2sbuf_indentnl declbuf 0)
    (if (or (is_mixint orloc) (is_mixloc orloc))
	(output_raw_location orloc declbuf 0 "procdecl")
      )
    (add2sbuf_strconst declbuf "MELT_EXTERN melt_ptr_t MELT_MODULE_VISIBILITY ")
    (add2sbuf_string declbuf onam)
    (add2sbuf_strconst declbuf "(meltclosure_ptr_t meltclosp_,")
    (add2sbuf_strconst declbuf " melt_ptr_t meltfirstargp_,")
    (add2sbuf_strconst declbuf " const melt_argdescr_cell_t meltxargdescr_[],")
    (add2sbuf_strconst declbuf " union meltparam_un *meltxargtab_,")
    (add2sbuf_strconst declbuf " const melt_argdescr_cell_t meltxresdescr_[],")
    (add2sbuf_strconst declbuf " union meltparam_un *meltxrestab_);")
    (add2sbuf_indentnl declbuf 0)
    ;; output the implementation
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "melt_ptr_t MELT_MODULE_VISIBILITY ")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_string implbuf onam)
    (add2sbuf_strconst implbuf "(meltclosure_ptr_t meltclosp_,")
    (add2sbuf_strconst implbuf " melt_ptr_t meltfirstargp_,")
    (add2sbuf_strconst implbuf " const melt_argdescr_cell_t meltxargdescr_[],")
    (add2sbuf_strconst implbuf " union meltparam_un *meltxargtab_,")
    (add2sbuf_indentnl implbuf 5)
    (add2sbuf_strconst implbuf " const melt_argdescr_cell_t meltxresdescr_[],")
    (add2sbuf_strconst implbuf " union meltparam_un *meltxrestab_)")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "{")
    (if orestnam
	(let ( (ovariadicindex  (variadic_index_idstr orestnam))
	       (ovariadiclength (variadic_length_idstr orestnam))
	       )
	  (add2sbuf_indentnl implbuf 1)
	  (add2sbuf_strconst implbuf "/*variadic*/ int ")
	  (add2sbuf_string implbuf ovariadicindex)
	  (add2sbuf_strconst implbuf " = 0, ")
	  (add2sbuf_string implbuf ovariadiclength)
	  (add2sbuf_strconst implbuf " = melt_argdescr_length (meltxargdescr_);")
	  (add2sbuf_indentnl implbuf 0)
	  ;; we generate (0+$ORESTNAM_len) to ensure that it cannot be
	  ;; set. 
	  ;;
	  ;; The melt_variadic_length & melt_variadic_index are used
	  ;; by primitives from warmelt-base.melt like variadic_index,
	  ;; variadic_length, ...
	  (add2sbuf_strconst implbuf "#define melt_variadic_length  (0+")
	  (add2sbuf_string implbuf ovariadiclength)
	  (add2sbuf_strconst implbuf ")")
	  (add2sbuf_indentnl implbuf 0)
	  (add2sbuf_strconst implbuf "#define melt_variadic_index ")
	  (add2sbuf_string implbuf ovariadicindex)
	  (add2sbuf_indentnl implbuf 0)
	  ))
 
    (add2sbuf_indentnl implbuf 2)
    (add2out implbuf "long current_blocklevel_signals_" onam "_melt =  melt_blocklevel_signals;")
    (add2sbuf_indentnl implbuf 1)
    (output_curframe_declstruct_init output_curframe_declstruct prou implbuf)
    (add2sbuf_strconst implbuf "melt_trace_start(\"")
    (add2sbuf_string implbuf ofunam)
    (add2sbuf_strconst implbuf "\", meltcallcount);")
    (add2sbuf_indentnl implbuf 1)
    (add2out implbuf "/*use arguments*/ (void) meltclosp_; (void)meltfirstargp_; (void)meltxargdescr_;\n"
	     "   (void)meltxargtab_; (void)meltxresdescr_; (void)meltxrestab_;")
    (add2sbuf_indentnl implbuf 0)
    ;; output the argument getting
    (add2sbuf_strconst implbuf "/*getargs*/")
    (add2sbuf_indentnl implbuf 0)
    (assert_msg "check ogargs" (is_multiple_or_null ogargs) ogargs)
    (foreach_in_multiple
     (ogargs)
     (curget :long curank) 
     (add2sbuf_indentnl implbuf 1)
     (add2sbuf_strconst implbuf "/*getarg#")
     (add2sbuf_longdec implbuf curank)
     (add2sbuf_strconst implbuf "*/")
     (add2sbuf_indentnl implbuf 1)
     (output_c_code curget declbuf implbuf 1)
     ;;
     (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	     (shortbacktrace_dbg "outpucod_procroutine huge implbuf" 10)
	     (debug "outpucod_procroutine huge implbuf=" implbuf)
	     (assert_msg "check limited implbuf" 
			 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
     )					;end foreach ogargs
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " goto meltlab_endgetargs;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "meltlab_endgetargs:;")
    (add2sbuf_indentnl implbuf 0)
    ;; output the body
    (assert_msg "check obody" (is_list obody) obody)
    (add2sbuf_strconst implbuf "/*body*/")
    (add2sbuf_indentnl implbuf 0)
    (foreach_pair_component_in_list
     (obody)
     (curpair curbody)
     (if (and curbody (not (is_a curbody class_objpurevalue)))
	 (progn
	   (output_c_code curbody declbuf implbuf 0)
	   (add2sbuf_indentnl implbuf 0)))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    ;; end of implementation
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " goto meltlabend_rout;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "meltlabend_rout:")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "melt_trace_end(\"")
    (add2sbuf_string implbuf ofunam)
    (add2sbuf_strconst implbuf "\", meltcallcount);")
    (add2sbuf_indentnl implbuf 1)
    (add2out implbuf " melt_blocklevel_signals = current_blocklevel_signals_" onam "_melt;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " return (melt_ptr_t)(")
    (if oretval 
	(output_c_code oretval declbuf implbuf 1)
      (add2sbuf_strconst implbuf "/*noretval*/ NULL"))
    (add2sbuf_strconst implbuf ");")
    (if orestnam
	(progn
	  (add2sbuf_indentnl implbuf 0)
	  (add2sbuf_strconst implbuf "#undef melt_variadic_length")
	  (add2sbuf_indentnl implbuf 0)
	  (add2sbuf_strconst implbuf "#undef melt_variadic_index")
	  (add2sbuf_indentnl implbuf 0)))
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef meltcallcount")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef meltfram__")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef MELTFRAM_NBVARNUM")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef MELTFRAM_NBVARPTR")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "} /*end ")
    (add2sbuf_string implbuf onam)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    ;;
    (cond ( (>i (strbuf_usedlength declbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outpucod_procroutine huge declbuf" 10)
	    (debug "outpucod_procroutine huge declbuf=" declbuf)
	    (assert_msg "check limited declbuf" 
			(<i (strbuf_usedlength declbuf) (get_int !buffer_limit_cont)) declbuf)))
    ;;
    (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	    (shortbacktrace_dbg "outpucod_procroutine huge implbuf" 10)
	    (debug "outpucod_procroutine huge implbuf=" implbuf)
	    (assert_msg "check limited implbuf" 
			(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
    ))
(install_method class_procroutineobj output_c_code outpucod_procroutine)




;;; output the cdata structure
(defun output_curframe_cdat_struct (idatup implbuf)
  (add2sbuf_indentnl implbuf 1)
  (add2sbuf_strconst implbuf "/* curframe_cdat_struct */ struct meltcdata_st {")
  (add2sbuf_indentnl implbuf 1)
  (add2sbuf_strconst implbuf "void* meltcdata_inigap[2]; /* could help debugging */")
  (add2sbuf_indentnl implbuf 1)
  (foreach_in_multiple
   (idatup)
   (curdat :long curk) 
   (add2sbuf_indentnl implbuf 1)
   (output_c_declinit curdat implbuf))
  (add2sbuf_indentnl implbuf 0)
  (add2sbuf_strconst implbuf " long spare_;")
  (add2sbuf_indentnl implbuf 0)
  (add2sbuf_strconst implbuf "}")
  (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	  (shortbacktrace_dbg "output_curframe_cdat_struct huge implbuf" 10)
	  (debug "output_curframe_cdat_struct huge implbuf=" implbuf)
	  (assert_msg "check limited implbuf" 
		      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
  )



;;; output the cdata structure fill
(defun output_curframe_cdat_fill (idatup implbuf)
  ;; generate the allocation of cdat
  (add2sbuf_strconst implbuf " /*curframe_cdat_fill */ ")
  (add2sbuf_indentnl implbuf 1)
  (add2sbuf_strconst implbuf " meltcdat = (struct meltcdata_st*) meltgc_allocate(sizeof(*meltcdat),0);")
  (add2sbuf_indentnl implbuf 1)
  (add2sbuf_strconst implbuf " melt_prohibit_garbcoll = TRUE;")
  (add2sbuf_indentnl implbuf 1)
;;;
;;; generate the initial predef of cdat
  (add2sbuf_strconst implbuf "/*initial routine predef*/")
  (add2sbuf_indentnl implbuf 1)
  (foreach_in_multiple
   (idatup)
   (curpdat :long curk) 
   (output_c_initial_predef curpdat implbuf '"meltcdat" 1))
;;;
;;; generate the initial filling of cdat
  (add2sbuf_strconst implbuf "/*initial routine fill*/")
  (add2sbuf_indentnl implbuf 1)
  (foreach_in_multiple
   (idatup)
   (curfil :long curk) 
   (add2sbuf_indentnl implbuf 1)
   (output_c_initial_fill curfil implbuf '"meltcdat" 0))
;;;;;;;
;;; initialize the variables
;;;
;;; clear the meltcdat for safety and renable GC
  (add2sbuf_strconst implbuf " meltcdat = NULL;")
  (add2sbuf_indentnl implbuf 0)
  (add2sbuf_strconst implbuf " melt_prohibit_garbcoll = FALSE;")
  (add2sbuf_indentnl implbuf 0)
;;;
  (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	  (shortbacktrace_dbg "output_curframe_cdat_fill implbuf" 10)
	  (debug "output_curframe_cdat_fill huge implbuf=" implbuf)
	  (assert_msg "check limited implbuf" 
		      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))
  )





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for the initial module routine
(defun outpucod_initialmoduleroutine (pini declbuf implbuf :long depth)
  (debug "outpucod_initialmoduleroutine start pini=" pini
	 "\n of discrim=" (discrim pini))
  (assert_msg "check pini" (is_a pini class_initial_module_routineobj) pini)
  (let ( 
	(idatup (unsafe_get_field :oirout_data pini)) 
	(irfill (unsafe_get_field :oirout_fill pini))
	(iprolog (unsafe_get_field :oirout_prolog pini))
	(oretval (unsafe_get_field :obrout_retval pini))
	(omodnam (unsafe_get_field :oirout_modulename pini))
	(onbval (get_field :obrout_nbval pini))
	(:long nbval (get_int onbval))
	(:long minihash (+i 1 (%iraw (obj_hash pini) 4096)))
	) 
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2out declbuf "MELT_EXTERN void* melt_start_this_module (void*); /*mandatory start of module*/")
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2out declbuf "/*declare opaque initial frame: */")
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2out declbuf "typedef " (initial_classy_frame_name pini) " /*opaqueinitialclassy*/ meltinitial_frame_t;")
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_strconst implbuf "/* the frame for initial routine */")
    (output_curframe_declstruct pini implbuf)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "static void melt_initialize_module_meltdata_")
    (add2sbuf_cident implbuf omodnam)
    (add2sbuf_strconst implbuf " (meltinitial_frame_t *iniframp__, char meltpredefinited[])")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "{")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#define meltfram__  (*iniframp__)")
    (add2sbuf_indentnl implbuf 1)
    (output_curframe_cdat_struct idatup implbuf)
    (add2sbuf_strconst implbuf " *meltcdat = NULL;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " dbgprintf (\"start melt_initialize_module_meltdata_")
    (add2sbuf_cident implbuf omodnam)
    (add2sbuf_strconst implbuf " iniframp__=%p\", (void*) iniframp__);")
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf "(void) meltpredefinited; /* avoid warning if non-used. */")
    (add2sbuf_indentnl implbuf 1)
;;; fill the meltcdat
    (output_curframe_cdat_fill idatup implbuf)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef meltfram__")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "} /*end melt_initialize_module_meltdata_")
    (add2sbuf_cident implbuf omodnam)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    ;; emit code to tell if we have debug
    (progn
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf
			 "/* define different names when debugging or not */")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf "#if MELT_HAVE_DEBUG")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf "MELT_EXTERN ")
      (add2sbuf_strconst declbuf "const char meltmodule_")
      (add2sbuf_cident declbuf omodnam)
      (add2sbuf_strconst declbuf "__melt_have_debug_enabled[];")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf "#define melt_have_debug_string meltmodule_")
      (add2sbuf_cident declbuf omodnam)
      (add2sbuf_strconst declbuf "__melt_have_debug_enabled")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf "#else /*!MELT_HAVE_DEBUG*/")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf "MELT_EXTERN const char meltmodule_")
      (add2sbuf_cident declbuf omodnam)
      (add2sbuf_strconst declbuf "__melt_have_debug_disabled[];")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf "#define melt_have_debug_string meltmodule_")
      (add2sbuf_cident declbuf omodnam)
      (add2sbuf_strconst declbuf "__melt_have_debug_disabled")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_strconst declbuf "#endif /*!MELT_HAVE_DEBUG*/")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_indentnl declbuf 0)
      ;;
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_strconst implbuf "#if MELT_HAVE_DEBUG")
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_strconst implbuf "const char meltmodule_")
      (add2sbuf_cident implbuf omodnam)
      (add2sbuf_strconst implbuf "__melt_have_debug_enabled[] = \"MELT module ")
      (add2sbuf_cencstring implbuf omodnam)
      (add2sbuf_strconst implbuf " have debug enabled\";")
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_strconst implbuf "#else /*!MELT_HAVE_DEBUG*/")
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_strconst implbuf "const char meltmodule_")
      (add2sbuf_cident implbuf omodnam)
      (add2sbuf_strconst implbuf "__melt_have_debug_disabled[] = \"MELT module ")
      (add2sbuf_cencstring implbuf omodnam)
      (add2sbuf_strconst implbuf " have debug disabled\";")
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_strconst implbuf "#endif /*MELT_HAVE_DEBUG*/")
      (add2sbuf_indentnl implbuf 0)
      )
    ;; 
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "void* melt_start_this_module (void* modargp_) {")
    (add2sbuf_indentnl implbuf 0)
    ;; generate the initial data structure
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf "char meltpredefinited[MELTGLOB__LASTGLOB+8];")
    (add2sbuf_indentnl implbuf 1)
    ;; generate the initial frame
    (output_curframe_declstruct_init 
     (lambda (rou dsbuf)
       (add2sbuf_indentnl dsbuf 0)
       (add2sbuf_strconst dsbuf "/*startiniframdecl*/")
       (add2sbuf_indentnl dsbuf 0)
       )
     pini implbuf)
;;; output the prologue
;;;
    (add2sbuf_strconst implbuf "/**initial routine prologue**/")
    (add2sbuf_indentnl implbuf 1)
    (foreach_pair_component_in_list
     (iprolog)
     (curpair curprol)
       (if (and curprol (not (is_a curprol class_objpurevalue)))
	   (progn
	     (output_c_code curprol declbuf implbuf 1)
	     (add2sbuf_indentnl implbuf 1))
	 ))
    (add2sbuf_strconst implbuf "/**initial routine cdata initializer**/")
    (add2sbuf_indentnl implbuf 0)
;;; output call cdata initializer
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf "memset(meltpredefinited, 0, sizeof(meltpredefinited));")
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf "melt_initialize_module_meltdata_")
    (add2sbuf_cident implbuf omodnam)
    (add2sbuf_strconst implbuf " (&meltfram__, meltpredefinited);")
    (add2sbuf_indentnl implbuf 1)
;;; output the body
;;;
    (add2sbuf_strconst implbuf "/**initial routine body**/")
    (add2sbuf_indentnl implbuf 0)
    ;; filter out the pure values from the body
    (let ( (rawbody (unsafe_get_field :obrout_body pini)) 
	   (bodylist (make_list discr_list))
	   (chunkbuflist (make_list discr_list))
	   )
      (foreach_pair_component_in_list
       (rawbody)
       (curpair curbody)
       (if (and curbody (not (is_a curbody class_objpurevalue)))
	   (list_append bodylist curbody)))
      (let ( (bodtup (list_to_multiple bodylist discr_multiple))
	     (chunkbuf ())
	     (:long nbbody (multiple_length bodtup))     
	     (:long chunkcount 0)
	     )
	(foreach_in_multiple
	 (bodtup)
	 (curbody :long bodix)
	 ;; the 128 is the size of each chunk...
	 (if (==i (%iraw bodix 128) 0)
	     (let ( (:long chunkix (+i chunkcount 1))
		    (newchunkbuf (make_strbuf discr_strbuf))
		    )
	       ;;(setq chunkcount (+i chunkcount 1))
	       (increment chunkcount 1)
	       (list_append chunkbuflist newchunkbuf)
	       (setq chunkbuf newchunkbuf)))
	 ;; clear the previous location memoization
	 (unsafe_put_fields prevloc_container :referenced_value ())
	 (unsafe_put_fields previmplbuf_container :referenced_value ())
	 (let ( (curloc (get_field :obi_loc curbody))
		)
	   (if curloc 
	       (output_location curloc chunkbuf 1 "initchunk"))
	   )
	 (output_c_code curbody declbuf chunkbuf 1)
	 (add2sbuf_indentnl chunkbuf 1)
	 (cond ( (>i (strbuf_usedlength chunkbuf) (/iraw (get_int !buffer_limit_cont) 2))
		 (shortbacktrace_dbg "outpucod_initialroutine huge chunkbuf" 10)
		 (debug "outpucod_initialroutine huge chunkbuf=" chunkbuf)
		 (assert_msg "check limited chunkbuf" 
			     (<i (strbuf_usedlength chunkbuf) (get_int !buffer_limit_cont)) chunkbuf)))
	 
	 ))
      ;; clear the previous location memoization
      (unsafe_put_fields prevloc_container :referenced_value ())
      (unsafe_put_fields previmplbuf_container :referenced_value ())
      (let ( (chunktup (list_to_multiple chunkbuflist discr_multiple)) 
	     )
	;; declare each chunk and call it.
	(add2sbuf_indentnl implbuf 1)
	(add2out implbuf "debugeprintf (\" in initialization of " omodnam " thru " 
		 (multiple_length chunktup) " chunk routines with frame @%p of %d bytes\",\n" 
		 " /*fromline " (this_line) "*/ (void*)&meltfram__, (int) sizeof(meltfram__));")
	(add2sbuf_indentnl implbuf 1)
	(add2out implbuf "melt_debuggc_eprintf (\"initialization of " omodnam " thru " 
		 (multiple_length chunktup) " chunks, frame @%p of %d bytes\",\n  "
		 " (void*)&meltfram__, (int) sizeof(meltfram__));")
	(add2sbuf_indentnl implbuf 1)
	(add2sbuf_indentnl declbuf 0)
	(foreach_in_multiple
	 (chunktup)
	 (curchunk :long chunkix)
	 (add2sbuf_indentnl declbuf 0)
	 (add2sbuf_strconst declbuf "void MELT_MODULE_VISIBILITY meltmod__")
	 (add2sbuf_cident declbuf omodnam)
	 (add2sbuf_strconst declbuf "__initialmeltchunk_")
	 (add2sbuf_longdec declbuf chunkix)
	 (add2sbuf_strconst declbuf " (meltinitial_frame_t*, char*);")
	 (add2sbuf_indentnl implbuf 1)
	 (add2sbuf_strconst implbuf "meltmod__")
	 (add2sbuf_cident implbuf omodnam)
	 (add2sbuf_strconst implbuf "__initialmeltchunk_")
	 (add2sbuf_longdec implbuf chunkix)
	 (add2sbuf_strconst implbuf " (&meltfram__, meltpredefinited);")
	 )
	(add2sbuf_indentnl declbuf 0)
;;; end of implementation
;;;
	(add2sbuf_strconst implbuf ";")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf " goto meltlabend_rout;")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "meltlabend_rout:;")
	(add2sbuf_indentnl implbuf 0)
	(add2out implbuf "{ /* return out of initial fromline " (this_line) " */")
	(add2sbuf_strconst implbuf " melt_ptr_t retval = ")
	(if oretval 
	    (output_c_code oretval declbuf implbuf 1)
	  (add2sbuf_strconst implbuf "/*noretval*/ NULL"))
	(add2sbuf_strconst implbuf ";")
	(add2sbuf_indentnl implbuf 1)
	(add2out implbuf "debugeprintf (\"returning @%p from initial routine of " omodnam
		 "\", (void*)retval); /*fromline " (this_line) "*/")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf " return retval;}")
	(add2sbuf_indentnl implbuf 1)
	(add2sbuf_strconst implbuf "#undef meltcallcount")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#undef meltfram__")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#undef MELTFRAM_NBVARNUM")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#undef MELTFRAM_NBVARPTR")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_indentnl implbuf 0)
	(add2out implbuf "} /* end fromline " (this_line) " */")
	(add2sbuf_indentnl implbuf 0)
	;; output the implementation of each chunk
	(foreach_in_multiple
	 (chunktup)
	 (curchunk :long chunkix)
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_strconst implbuf "void meltmod__")
	 (add2sbuf_cident implbuf omodnam)
	 (add2sbuf_strconst implbuf "__initialmeltchunk_")
	 (add2sbuf_longdec implbuf chunkix)
	 (add2sbuf_strconst implbuf " (meltinitial_frame_t* meltframptr__, char meltpredefinited[]) {")
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_strconst implbuf "#define meltfram__ (*meltframptr__)")
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_strconst implbuf "#undef meltcallcount")
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_strconst implbuf "#define meltcallcount 0L")
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_strconst implbuf "(void) meltpredefinited;")
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_sbuf implbuf curchunk)
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_strconst implbuf "#undef meltfram__")
	 (add2sbuf_indentnl implbuf 0)
	 (add2sbuf_strconst implbuf "} /*end of meltmod__")
	 (add2sbuf_cident implbuf omodnam)
	 (add2sbuf_strconst implbuf "__initialmeltchunk_")
	 (add2sbuf_longdec implbuf chunkix)
	 (add2sbuf_strconst implbuf "*/")
	 (add2sbuf_indentnl implbuf 0)
	 ;;
	 (cond ( (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
		 (shortbacktrace_dbg "outpucod_initialroutine huge implbuf" 10)
		 (debug "outpucod_initialroutine huge implbuf=" implbuf)
		 (assert_msg "check limited implbuf" 
			     (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)))

	 )
	)
      )
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    (assert_msg "check limited declbuf" 
		(<i (strbuf_usedlength declbuf) (get_int !buffer_limit_cont)) declbuf)
    ))
(install_method class_initial_module_routineobj output_c_code outpucod_initialmoduleroutine)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; internal utility to emit central declaration of a hook 
;; to be shared in declaration & implementation buffers
(defun output_centraldecl_hookroutine (phook sbuf :cstring comm qualif)
  (debug "output_centraldecl_hookroutine start phook=" phook)
  (assert_msg "check phook" (is_a phook class_hookroutineobj) phook)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (let ( (hookname (get_field :named_name phook))
	 (nhookproc (get_field :obrout_proc phook))
	 (oretval (get_field :obrout_retval phook))
	 (oretctype (get_field :nrhook_ctype nhookproc))
	 (oretctycname (get_field :ctype_cname oretctype))
	 (ohkdatarg (get_field :ohookrout_datarg phook))
	 (ohkdatacname (get_field :oformal_name ohkdatarg))
	 (ohkinargs (get_field :ohookrout_inargs phook))
	 (ohkoutargs (get_field :ohookrout_outargs phook))
	 )
    (debug "output_centraldecl_hookroutine oretctype=" oretctype "\n.. oretval=" oretval)
    (assert_msg "check oretctype" (is_a oretctype class_ctype) oretctype)
    (add2sbuf_indentnl sbuf 0)
    (add2out sbuf ##{/** $COMM hook $HOOKNAME */}#)
    (add2sbuf_indentnl sbuf 0)
    (when qualif
      (add2out_strconst sbuf qualif)
      (add2sbuf_indentnl sbuf 0)
      )
    (add2out sbuf oretctycname " " hookname "(melt_ptr_t " ohkdatacname)
    ;; declare the input arguments
    (foreach_in_multiple
     (ohkinargs)
     (curinarg :long inix)
     (debug "output_centraldecl_hookroutine curinarg=" curinarg " inix=" inix)
     (add2sbuf_strconst sbuf ",")
     (add2sbuf_indentnl sbuf 20)
     (let ( (curinctyp (get_field :obv_type curinarg))
	    (curformalname (get_field :oformal_name curinarg))
	    (curinctycname (get_field :ctype_cname curinctyp))
	    )
       (add2out sbuf ##{$CURINCTYCNAME $CURFORMALNAME}#)
       ))
    ;; declare the output arguments
    (foreach_in_multiple
     (ohkoutargs)
     (curoutarg :long outix)
     (debug "output_centraldecl_hookroutine curoutarg=" curoutarg " outix=" outix)
     (add2sbuf_strconst sbuf ",")
     (add2sbuf_indentnl sbuf 20)
     (let ( (curoutctyp (get_field :obv_type curoutarg))
	    (curformalname (get_field :oformal_name curoutarg))
	    (curoutctycname (get_field :ctype_cname curoutctyp))
	    )
       (add2out sbuf ##{$CUROUTCTYCNAME* $CURFORMALNAME}#)
       ))
    (add2out_strconst sbuf ")")
    (add2sbuf_indentnl sbuf 0)
    ))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for hook routines
(defun outpucod_hookroutine (phook declbuf implbuf :long depth)
  (debug "outpucod_hookroutine start phook=" phook
	 "\n of discrim=" (discrim phook))
  (assert_msg "check phook" (is_a phook class_hookroutineobj) phook)
  (let ( (hookname (get_field :named_name phook))
	 (nhookproc (get_field :obrout_proc phook))
	 (nrawhookname (get_field :nrclop_name nhookproc))
	 (obody (get_field :obrout_body phook))
	 (nbval (get_field :obrout_nbval phook))
	 (nblongs (get_field :obrout_nblong phook))
	 (othervars (get_field :obrout_others phook))
	 (oretval (get_field :obrout_retval phook))
	 (oretctype (get_field :obv_type oretval))
	 (oretctycname (get_field :ctype_cname oretctype))
					;(ocntciter (get_field :obrout_cntciter phook))
					;(ocntletrec (get_field :obrout_cntletrec phook))
	 (ohkdatarg (get_field :ohookrout_datarg phook))
	 (ohkdatacname (get_field :oformal_name ohkdatarg))
	 (ohkinargs (get_field :ohookrout_inargs phook))
	 (ohkoutargs (get_field :ohookrout_outargs phook))
	 (ohkepilog (get_field :ohookrout_epilog phook))
	 (:long minihash (+i 2 (%iraw (obj_hash phook) 4096)))
	 )
    (debug "outpucod_hookroutine hookname=" hookname 
	   "\n nrawhookname=" nrawhookname
	   "\n ohkdatarg=" ohkdatarg 
	   "\n oretctype=" oretctype
	   "\n ohkinargs=" ohkinargs
	   "\n ohkoutargs=" ohkoutargs
	   "\n oretval=" oretval
	   "\n oretctype=" oretctype
	   "\n obody=" obody
	   "\n ohkepilog=" ohkepilog)
    (add2sbuf_indentnl declbuf 0)
    (add2out declbuf "/** start of declaration for hook " hookname "**/")
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf "/** start of implementation for hook " hookname "**/")
    (add2sbuf_indentnl implbuf 0)
;;; should generate the marking routine, and the hook routine
    (output_centraldecl_hookroutine phook declbuf "declaration of" "MELT_EXTERN")
    (add2out_strconst declbuf ";")
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf ##{/* frame for $HOOKNAME hook: */}#)
    (output_curframe_declstruct phook implbuf)
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf ##{/* endframe for $HOOKNAME hook */}#)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (output_centraldecl_hookroutine phook implbuf "implementation of" (the_null_cstring))
    (add2out implbuf "{ /* body of hook " hookname " from outpucod_hookroutine */")
    (add2sbuf_indentnl implbuf 0)
    (let ( (odatalocv (get_field :oformal_locv ohkdatarg))
	   )
      (debug "outpucod_hookroutine framing hookname=" hookname
	     "\n.. ohkdatarg=" ohkdatarg "\n.. odatalocv=" odatalocv)
      ;; generate the hook frame
      (add2out 
       implbuf 
       ##{/* declare and initialize frame for $HOOKNAME hook */ 
       #undef meltcallcount
       #if MELT_HAVE_DEBUG
       static long melthook_call_counter_$NRAWHOOKNAME ;
       long melt_thishookcall_counter_$NRAWHOOKNAME ATTRIBUTE_UNUSED 
       = melthook_call_counter_$NRAWHOOKNAME++ ;
       #define meltcallcount melt_thishookcall_counter_$NRAWHOOKNAME
       #else
       #define meltcallcount 0L
       #endif
       MeltFrame_$HOOKNAME meltfram__(meltcast_melthook_st(melthookdatap)) /*hook classy frame*/;
       }#
       )
      (add2sbuf_indentnl implbuf 0)
      (add2out implbuf "#define meltfhook /*hook data of " nrawhookname "*/ ((melthook_ptr_t) (")
      (output_c_code odatalocv declbuf implbuf 0)
      (add2sbuf_strconst implbuf "))")
      (add2sbuf_indentnl implbuf 1)
      ;; output the body
      (add2out 
       implbuf 
       ##{/* body of $HOOKNAME hook */}#
       )
      (add2sbuf_indentnl implbuf 1)
      (debug "outpucod_hookroutine obody=" obody)
      (assert_msg "check list body" (is_list obody) obody)
      (foreach_pair_component_in_list
       (obody)
       (curbodypair curbodyo)
       (debug "outpucod_hookroutine curbodyo=" curbodyo)
       (when (is_not_a curbodyo class_objpurevalue)
	 (output_c_code curbodyo declbuf implbuf 1)
	 (add2sbuf_strconst implbuf ";")
	 (add2sbuf_indentnl implbuf 1))
       (assert_msg "check limited implbuf" 
		   (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
       )
      ;; output the epilogue
      (add2out 
       implbuf 
       ##{/* epilogue of $HOOKNAME hook */
       goto  meltlabend_rout		;
       meltlabend_rout:			;
       }#
       )
      (add2sbuf_indentnl implbuf 1)
      (debug "outpucod_hookroutine ohkepilog=" ohkepilog)
      (assert_msg "check epilog" (is_list ohkepilog) ohkepilog)
      (foreach_pair_component_in_list
       (ohkepilog)
       (curepipair curepins)
       (debug "outpucod_hookroutine curepins=" curepins)
       (when (is_not_a curepins class_objpurevalue)
	 (output_c_code curepins declbuf implbuf 1)
	 (add2sbuf_strconst implbuf ";")
	 (add2sbuf_indentnl implbuf 1))
       )
      (add2out 
       implbuf 
       ##{/* final of $HOOKNAME hook */
       return }#)
      (add2sbuf_indentnl implbuf 3)
      (if oretval
	  (output_c_code oretval declbuf implbuf 1))
      (add2sbuf_strconst implbuf ";")
      (add2sbuf_indentnl implbuf 0)
      (add2out implbuf ##{} /* end of $HOOKNAME hook */}#)
      (add2sbuf_indentnl implbuf 0)
      (add2out_strconst implbuf "#undef meltframe")
      (add2sbuf_indentnl implbuf 0)
      (add2out_strconst implbuf "#undef meltfram__")
      (add2sbuf_indentnl implbuf 0)
      (add2out_strconst implbuf "#undef meltfhook")
      (add2sbuf_indentnl implbuf 0)
      (add2out_strconst implbuf "#undef meltcallcount")
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl declbuf 0)
      (add2out declbuf "/** end of declaration for hook " hookname "**/")
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_indentnl declbuf 0)
      (add2sbuf_indentnl implbuf 0)
      (add2out implbuf "/** end of implementation for hook " hookname "**/")
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl implbuf 0)
      ;;
      )))
(install_method class_hookroutineobj output_c_code outpucod_hookroutine)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; output extension initial routine
(defun outpucod_initialextensionroutine  (pini declbuf implbuf :long depth)
  (debug "outpucod_initialextensionroutine start pini=" pini
	 "\n of discrim " (discrim pini))
  (assert_msg "check pini" (is_a pini class_initial_extension_routineobj) pini)
  (shortbacktrace_dbg "outpucod_initialextensionroutine" 20)
  (let (
	(oname (get_field :named_name pini))
	(odatup (get_field :oirout_data pini))
	(orfill (get_field :oirout_fill pini))
	(oprolog (get_field :oirout_prolog pini))
	(omodnam (unsafe_get_field :oirout_modulename pini))
	(omodcname (let ( (sbuf (make_strbuf discr_strbuf))
			  )
		     (add2sbuf_cident sbuf omodnam)
		     (strbuf2string discr_verbatim_string sbuf)))
	(obody (get_field :obrout_body pini))
	(onbval (get_field :obrout_nbval pini))
	(:long nbval (get_int onbval))
	(:long minihash (+i 1 (%iraw (obj_hash pini) 4096)))
	(oretval (get_field :obrout_retval pini))
	)
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (add2out 
     declbuf 
     ##{ /** declare initial extension running routine $ONAME 
* of $OMODNAM [outpucod_initialextensionroutine] **/
MELT_EXTERN melt_ptr_t $ONAME (melt_ptr_t meltarg_curenvbox_p, melt_ptr_t meltarg_tuplitval_p) ;

#ifdef MELT_HAVE_DEBUG
MELT_EXTERN const char meltextend_$OMODCNAME#_have_debug_enabled[] ;
#define melt_have_debug_string meltextend_$OMODCNAME#_have_debug_enabled
#else
MELT_EXTERN const char meltextend_$OMODCNAME#_have_debug_disabled[] ;
#define melt_have_debug_string meltextend_$OMODCNAME#_have_debug_disabled
#endif /* MELT_HAVE_DEBUG */

     }#)
    (add2sbuf_indentnl declbuf 0)
    (add2out
     implbuf
##{ /* implement extension running routine $ONAME 
of $OMODNAM [outpucod_initialextensionroutine] **/
#ifdef MELT_HAVE_DEBUG
const char meltextend_$OMODCNAME#_have_debug_enabled[]
= "MELT running extension $OMODNAM has debug enabled" ;
#else
const char meltextend_$OMODCNAME#_have_debug_disabled[]
= "MELT running extension $OMODNAM has debug disabled" ;
#endif /* MELT_HAVE_DEBUG */


/******* starting initial extend run routine $OMODNAM ******/
melt_ptr_t 
$ONAME (melt_ptr_t meltarg_curenvbox_p, melt_ptr_t meltarg_tuplitval_p) 
{
}#)
    ;;
    ;; generate the initial frame declaration in the decl buf, because
    ;; the marking routine will use that
    ;;
    (add2out declbuf "// extension routine " omodnam " fromline " (this_line) "\n")
    (output_curframe_declstruct pini declbuf)
    (add2sbuf_indentnl declbuf 1)
    (add2out declbuf ##{/* extension routine $OMODNAM initial frame decl fromline $(this_line) */ typedef }#)
    (add2out declbuf (initial_classy_frame_name pini))
    (add2out declbuf ##{ meltrun_$OMODCNAME#_initialext_frame_t /*declaring runextend $OMODNAM frame type*/;}#
	     )
    (add2sbuf_indentnl declbuf 1)
    ;;    
    ;; initialize the frame
    (add2sbuf_indentnl implbuf 1)
    (add2out implbuf ##{/* extension routine $OMODNAM initial frame init */}#)
    (output_curframe_declstruct_init 
     (lambda (rou dsbuf)
       (add2sbuf_indentnl dsbuf 0)
       (add2out dsbuf  ##{ /* extension routine $OMODNAM initializing frame fromline $(this_line) */ }#))
     pini implbuf)
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf ##{ /* extension $OMODNAM initialized initial frame */}#)
    ;;
    (add2sbuf_indentnl implbuf 0)
    (add2out implbuf ##{ /* extension $OMODNAM cdata struct */}#)
    (output_curframe_cdat_struct odatup implbuf)
    (add2sbuf_strconst implbuf " *meltcdat = NULL;")
    (add2sbuf_indentnl implbuf 1)
    ;; generate the prologue
    (debug "outpucod_initialextensionroutine oprolog=" oprolog)
    (add2sbuf_indentnl implbuf 1)
    (add2out implbuf  ##{ /* extension $OMODNAM prologue */}#)
    (foreach_pair_component_in_list
     (oprolog)
     (curpair curprol)
     (when (and curprol (not (is_a curprol class_objpurevalue)))
       (add2sbuf_indentnl implbuf 1)
       (output_c_code curprol declbuf implbuf 1)))
    ;; generate the fill of the cdata
    (add2sbuf_indentnl implbuf 1)
    (add2out implbuf  ##{ /* extension $OMODNAM cdata fill */}#)
    (output_curframe_cdat_fill odatup implbuf)
    (add2sbuf_indentnl implbuf 1)
    (add2out implbuf  ##{ /* extension $OMODNAM cdata done fill */}#)
    (add2sbuf_indentnl implbuf 1)
    ;; generate the body
    (debug "outpucod_initialextensionroutine obody=" obody)
    (add2sbuf_indentnl implbuf 1)
    (let ( (bodtup
	    (cond 
	     ((is_list obody) (list_to_multiple obody discr_multiple))
	     ((is_multiple obody) obody)
	     (:else
	      (assert_msg "unexpected body" () obody))))
	   (:long nbbody (multiple_length bodtup))
	   )
      (debug "outpucod_initialextensionroutine bodtup=" bodtup)
      (add2out implbuf  ##{ /* extension $OMODNAM body of $NBBODY instructions */}#)
      (foreach_in_multiple
       (bodtup)
       (curbody :long bodix)
       (debug "outpucod_initialextensionroutine bodix=" bodix 
	      "\n curbody=" curbody
	      "\n of discrim=" (discrim curbody) "\n")
       (when (and curbody (is_not_a curbody class_objpurevalue))
	 (debug "outpucod_initialextensionroutine good bodix=" bodix "\n real curbody=" curbody)
	 (add2sbuf_indentnl implbuf 1)
	 (add2out implbuf  ##{ /*sideffecting $OMODNAM extension body #$BODIX */}#)
	 (add2sbuf_indentnl implbuf 1)
	 (let ( (curloc (get_field :obi_loc curbody))
		)
	   (if curloc 
	       (output_location curloc implbuf 1 "curbody")))
	 (output_c_code curbody declbuf implbuf 1)
	 )
       )
      (add2sbuf_indentnl implbuf 1)
      (add2out implbuf  ##{ /*-- ending run extension $OMODNAM  --*/}#)
      (add2out implbuf ##{
 goto meltlabend_rout;
meltlabend_rout:
  return (melt_ptr_t)}#)
      (output_c_code oretval declbuf implbuf 1)
      (add2out implbuf ##{; /*return value of extension $OMODNAM */
} /* end extension $ONAME */}#)
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_indentnl implbuf 0)
      ;;
      )))
(install_method class_initial_extension_routineobj output_c_code outpucod_initialextensionroutine)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; output code for argument getter
(defun outpucod_getarg (garg declbuf implbuf :long depth)
  (assert_msg "check garg" (is_a garg class_objgetarg) garg)
  (let ( (oloc (unsafe_get_field :obarg_obloc garg)) 
	 (nloc (unsafe_get_field :obi_loc garg))
	 (obind (unsafe_get_field :obarg_bind garg))
	 (:long rkbind (get_int obind))
	 (ctybind (unsafe_get_field :fbind_type obind))
	 )
    (assert_msg "check obind" (is_a obind class_formal_binding) obind)
    (output_location nloc implbuf depth "getarg")
    (assert_msg "check oloc" (is_a oloc class_objlocv) oloc)
    (assert_msg "check ctybind" (is_a ctybind class_ctype) ctybind)
    (if (==i rkbind 0)
	(progn
	  (assert_msg "check ctybind first" (== ctybind ctype_value) ctybind)
	  (output_c_code oloc declbuf implbuf depth)
	  (add2sbuf_strconst implbuf " = (melt_ptr_t) meltfirstargp_;")
	  (add2sbuf_indentnl implbuf depth)
	  )
      (let (
	    ;; use the ctype_parchar ctype_argfield
	    (parc (unsafe_get_field :ctype_parchar ctybind))
	    (argf (unsafe_get_field :ctype_argfield ctybind)) 
	    )
	(if (not (is_string parc)) 
	    (error_strv oloc "impossible argument ctype" 
			(unsafe_get_field :named_name ctybind)))
	(add2sbuf_strconst implbuf "if (meltxargdescr_[")
	(add2sbuf_longdec implbuf (-i rkbind 1))
	(add2sbuf_strconst implbuf "] != ")
	(add2sbuf_string implbuf parc)
	(add2sbuf_strconst implbuf ") goto meltlab_endgetargs;")	
	(add2sbuf_indentnl implbuf depth)
	(if (== ctybind ctype_value)
	    (progn
	      (output_c_code oloc declbuf implbuf depth)
	      (add2sbuf_strconst implbuf " = (meltxargtab_[")
	      (add2sbuf_longdec implbuf (-i rkbind 1))
	      (add2sbuf_strconst implbuf "].meltbp_aptr) ? (*(meltxargtab_[")
	      (add2sbuf_longdec implbuf (-i rkbind 1))
	      (add2sbuf_strconst implbuf "].meltbp_aptr)) : NULL;")		
	      (add2sbuf_indentnl implbuf depth)
	      (add2sbuf_strconst implbuf "gcc_assert(melt_discr((melt_ptr_t)(")
	      (output_c_code oloc declbuf implbuf depth)
	      (add2sbuf_strconst implbuf ")) != NULL);")	
	      (add2sbuf_indentnl implbuf depth)
	      )
	  (progn
	    (output_c_code oloc declbuf implbuf depth)
	    (add2sbuf_strconst implbuf " = meltxargtab_[")
	    (add2sbuf_longdec implbuf (-i rkbind 1))
	    (add2sbuf_strconst implbuf "].")
	    (add2sbuf_string implbuf argf)
	    (add2sbuf_strconst implbuf ";")
	    )
	  )
	(add2sbuf_indentnl implbuf depth)
	))
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objgetarg output_c_code outpucod_getarg)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for rest argument getter
(defun outpucod_getargrest (garg declbuf implbuf :long depth)
  (assert_msg "check garg" (is_a garg class_objgetargrest) garg)
  (let ( (oloc (unsafe_get_field :obarg_obloc garg)) 
	 (nloc (unsafe_get_field :obi_loc garg))
	 (obind (unsafe_get_field :obarg_bind garg))
	 (orest (get_field :obarg_rest garg))
	 (:long rkbind (get_int obind))
	 (ctybind (unsafe_get_field :fbind_type obind))
	 (ovariadicindex (variadic_index_idstr orest))
	 (ovariadiclength (variadic_length_idstr orest))
	 )
    (assert_msg "check obind" (is_a obind class_formal_binding) obind)
    (output_location nloc implbuf depth "getarg")
    (assert_msg "check oloc" (is_a oloc class_objlocv) oloc)
    (assert_msg "check ctybind" (is_a ctybind class_ctype) ctybind)
    (if (==i rkbind 0)
	(progn
	  (assert_msg "check ctybind first" (== ctybind ctype_value) ctybind)
	  (output_c_code oloc declbuf implbuf depth)
	  (add2sbuf_strconst implbuf " = (melt_ptr_t) meltfirstargp_;")
	  (add2sbuf_indentnl implbuf depth)
	  )
      (let (
	    ;; use the ctype_parchar ctype_argfield
	    (parc (unsafe_get_field :ctype_parchar ctybind))
	    (argf (unsafe_get_field :ctype_argfield ctybind)) 
	    )
	(if (not (is_string parc)) 
	    (error_strv oloc "impossible argument ctype" 
			(unsafe_get_field :named_name ctybind)))
	(add2sbuf_strconst implbuf "if (meltxargdescr_[")
	(add2sbuf_longdec implbuf (-i rkbind 1))
	(add2sbuf_strconst implbuf "] != ")
	(add2sbuf_string implbuf parc)
	(add2sbuf_strconst implbuf ") { /*getargrest*/")	
	(add2sbuf_indentnl implbuf (+i 1 depth))
	(add2sbuf_string implbuf ovariadicindex)
	(add2sbuf_strconst implbuf " = ")
	(add2sbuf_string implbuf ovariadiclength)
	(add2sbuf_strconst implbuf ";")
	(add2sbuf_indentnl implbuf (+i 1 depth))
	(add2sbuf_strconst implbuf "goto meltlab_endgetargs;")
	(add2sbuf_indentnl implbuf depth)	
	(add2sbuf_strconst implbuf "}")
	(add2sbuf_indentnl implbuf depth)
	(add2sbuf_string implbuf ovariadicindex)
	(add2sbuf_strconst implbuf " = ")
	(add2sbuf_longdec implbuf rkbind)
	(add2sbuf_strconst implbuf ";")	
	(add2sbuf_indentnl implbuf depth)
	(if (== ctybind ctype_value)
	    (progn
	      (output_c_code oloc declbuf implbuf depth)
	      (add2sbuf_strconst implbuf " = (meltxargtab_[")
	      (add2sbuf_longdec implbuf (-i rkbind 1))
	      (add2sbuf_strconst implbuf "].meltbp_aptr) ? (*(meltxargtab_[")
	      (add2sbuf_longdec implbuf (-i rkbind 1))
	      (add2sbuf_strconst implbuf "].meltbp_aptr)) : NULL;")		
	      (add2sbuf_indentnl implbuf depth)
	      (add2sbuf_strconst implbuf "gcc_assert(melt_discr((melt_ptr_t)(")
	      (output_c_code oloc declbuf implbuf depth)
	      (add2sbuf_strconst implbuf ")) != NULL);")	
	      (add2sbuf_indentnl implbuf depth)
	      )
	  (progn
	    (output_c_code oloc declbuf implbuf depth)
	    (add2sbuf_strconst implbuf " = meltxargtab_[")
	    (add2sbuf_longdec implbuf (-i rkbind 1))
	    (add2sbuf_strconst implbuf "].")
	    (add2sbuf_string implbuf argf)
	    (add2sbuf_strconst implbuf ";")
	    )
	  )
	(add2sbuf_indentnl implbuf depth)
	))
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objgetargrest output_c_code outpucod_getargrest)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for objcformal
(defun outpucod_objcformal (cform declbuf implbuf :long depth)
  (debug "outpucod_objcformal cform=" cform)
  (assert_msg "check cform" (is_a cform class_objcformal) cform)
  (assert_msg "check implbuf" (is_strbuf implbuf) implbuf)
  (let ( (fornam (get_field :oformal_name cform))
	 )
    (assert_msg "check formnam" (is_string fornam) fornam)
    (add2out_strconst implbuf " ")
    (add2out_string implbuf fornam)
    ))
(install_method class_objcformal output_c_code outpucod_objcformal)


;;; output code for module variable fetching
(defun outpucod_objfetchmodvar (fmodvar declbuf implbuf :long depth)
  (debug "outpucod_objfetchmodvar fmodvar=" fmodvar)
  (assert_msg "check fmodvar" (is_a fmodvar class_objfetchmodvar) fmodvar)
  (let ( (varbind (get_field :obfetchmodvar_bind fmodvar))
	 )
    ;; the inlined function melt_module_var_fetch is emitted by translate_macroexpanded_list
    (assert_msg "check varbind" (is_a varbind class_normal_module_variable_binding) varbind)
    (add2out implbuf " (melt_module_var_fetch (")
    (out_enumix_modvarbind implbuf varbind)
    (add2out implbuf "))")
))
(install_method class_objfetchmodvar output_c_code outpucod_objfetchmodvar)

;;; output code for module variable putting
(defun outpucod_objputmodvar (pmodvar declbuf implbuf :long depth)
  (debug "outpucod_objputmodvar pmodvar=" pmodvar)
  (assert_msg "check pmodvar" (is_a pmodvar class_objputmodvar) pmodvar)
  (let ( (oloc (get_field :obi_loc pmodvar))
	 (varbind (get_field :obputmodvar_bind pmodvar))
	 (oval (get_field :obputmodvar_val pmodvar))
	 )
    ;; the inlined function melt_module_var_put is emitted by translate_macroexpanded_list
    (debug "outpucod_objputmodvar varbind=" varbind)
    (assert_msg "check varbind" (is_a varbind class_normal_module_variable_binding) varbind)
    (if oloc (output_location oloc implbuf depth "putmodvar"))
    (add2out implbuf "melt_module_var_put (")
    (out_enumix_modvarbind implbuf varbind)
    (add2out implbuf ", (melt_ptr_t)(")
    (output_c_code oval declbuf implbuf depth)
    (add2out implbuf "));")
    (add2sbuf_indentnl implbuf depth)
))
(install_method class_objputmodvar output_c_code outpucod_objputmodvar)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for put output argument in hooks
(defun outpucod_objputoutarg (outa declbuf implbuf :long depth)
  (debug "outpucod_objputoutarg outa=" outa)
  (assert_msg "check outa" (is_a outa class_objputoutarg) outa)
  (let ( (oloc (get_field :obi_loc outa))
	 (oformal (get_field :oboutarg_formal outa))
	 (olocv (get_field :oformal_locv oformal))
	 )
    (debug "outpucod_objputoutarg oformal=" oformal)
    (assert_msg "check oformal" (is_a oformal class_objcformal) oformal)
    (assert_msg "check olocv" (is_a olocv class_objlocv) olocv)
    (output_location oloc implbuf depth "putoutarg")
    (add2sbuf_strconst implbuf "if ((")
    (output_c_code oformal declbuf implbuf depth)
    (add2sbuf_strconst implbuf ") != NULL)")
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2out implbuf "*")
    (output_c_code oformal declbuf implbuf depth)
    (add2sbuf_strconst implbuf " /*putout*/ = ")
    (output_c_code olocv declbuf implbuf depth)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objputoutarg output_c_code outpucod_objputoutarg)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for objlocv
(defun outpucod_objlocv (locv declbuf implbuf :long depth)
  (assert_msg "check locv" (is_a locv class_objlocv) locv)
  (let ( 
	(ltyp (unsafe_get_field :obv_type locv))
	(loff (unsafe_get_field :obl_off locv))
	(lcnam (unsafe_get_field :obl_cname locv))
	)
    (cond 
     ( (== ltyp ctype_value)
       (add2sbuf_strconst implbuf "/*_.")
       (add2sbuf_string implbuf lcnam)
       (add2sbuf_strconst implbuf "*/ meltfptr[")
       (add2sbuf_longdec implbuf (get_int loff))
       (add2sbuf_strconst implbuf "]") )
     ( (== ltyp ctype_long)
       (add2sbuf_strconst implbuf "/*_#")
       (add2sbuf_string implbuf lcnam)
       (add2sbuf_strconst implbuf "*/ meltfnum[")
       (add2sbuf_longdec implbuf (get_int loff))
       (add2sbuf_strconst implbuf "]") )
     (:else
      (add2sbuf_strconst implbuf "/*_?*/ meltfram__.")
      (add2sbuf_string implbuf lcnam)))
    )
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method class_objlocv output_c_code outpucod_objlocv)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for object closed occurrence
(defun outpucod_objcloccv (occv  declbuf implbuf :long depth)
  (assert_msg "check occv" (is_a occv class_objcloccv) occv)
  (let ( (ooff (unsafe_get_field :obc_off occv))
	 (onam (unsafe_get_field :obc_name occv)) )
    (assert_msg "check valueness of closed occurrence" 
		(== (unsafe_get_field :obv_type occv) ctype_value) occv)
    (add2sbuf_strconst implbuf "(/*~")
    (add2sbuf_string implbuf onam)
    (add2sbuf_strconst implbuf "*/ meltfclos->tabval[")
    (add2sbuf_longdec implbuf (get_int ooff))
    (add2sbuf_strconst implbuf "])")
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objcloccv output_c_code outpucod_objcloccv)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for hook closed occurrence
(defun outpucod_objclohookv (occv  declbuf implbuf :long depth)
  (debug "outpucod_objclohookv occv=" occv)
  (assert_msg "check occv" (is_a occv class_objclohookv) occv)
  (let ( (ooff (unsafe_get_field :obc_off occv))
	 (onam (unsafe_get_field :obc_name occv)) )
    (assert_msg "check valueness of closed occurrence" 
		(== (unsafe_get_field :obv_type occv) ctype_value) occv)
    (add2sbuf_strconst implbuf "(/*~")
    (add2sbuf_string implbuf onam)
    (add2sbuf_strconst implbuf "*/ meltfhook->tabval[")
    (add2sbuf_longdec implbuf (get_int ooff))
    (add2sbuf_strconst implbuf "])")
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objclohookv output_c_code outpucod_objclohookv)


;;;;;;;;;;;;;;;;
;; output code for object const [closed] occurrence
(defun outpucod_objconstv (ocnstv  declbuf implbuf :long depth)
  (assert_msg "check ocnstv" (is_a ocnstv class_objconstv) ocnstv)
  (let ( (ooff (unsafe_get_field :obc_off ocnstv))
	 (onam (unsafe_get_field :obc_name ocnstv)) )
    (assert_msg "check valueness of const occurrence" 
		(== (unsafe_get_field :obv_type ocnstv) ctype_value) ocnstv)
    (add2sbuf_strconst implbuf "(/*!")
    (add2sbuf_string implbuf onam)
    ;; was for debug
    (add2sbuf_strconst implbuf "*/ meltfrout->tabval[")
    (add2sbuf_longdec implbuf (get_int ooff))
    (add2sbuf_strconst implbuf "])")
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objconstv output_c_code outpucod_objconstv)


;; output the code of an instructions list, skipping any pure value
(defun output_code_instructions_list (lis declbuf implbuf boxeddepth)
  (assert_msg "check lis" (is_list_or_null lis) lis)
  (assert_msg "check boxeddepth" (is_integerbox boxeddepth) boxeddepth)
  (let ( (:long depth (get_int boxeddepth)) )
    (add2sbuf_indentnl implbuf depth)
    (foreach_pair_component_in_list
     (lis) 
     (pair cur)
     (cond 
      ( (is_a cur class_objplainblock)
	(add2sbuf_indentnl implbuf depth)
	(let ( (bloc (unsafe_get_field :obi_loc cur))
	       (bodyl (unsafe_get_field :oblo_bodyl cur))
	       (epil (unsafe_get_field :oblo_epil cur))
	       )
	  (if bloc (output_location bloc implbuf depth "quasiblock"))
	  (if bodyl (output_code_instructions_list bodyl declbuf implbuf boxeddepth))
	  (if epil (output_code_instructions_list epil declbuf implbuf boxeddepth))
	  )
	)
      ( (and cur (is_not_a cur class_objpurevalue))
	(add2sbuf_indentnl implbuf depth)
	(output_c_code cur declbuf implbuf depth)
	(add2sbuf_strconst implbuf ";"))
      )					;end cond
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     (assert_msg "check limited declbuf" 
		 (<i (strbuf_usedlength declbuf) (get_int !buffer_limit_cont)) declbuf)
     ))
  )
  

;;;;;;;;;;;;;;;;
(defun outpucod_objchecksignal (obchi declbuf implbuf :long depth)
  (assert_msg "check ochi" (is_a obchi class_objchecksignal) obchi)
  (let ( (oloc (unsafe_get_field :obi_loc obchi))
	 )
    ;; We use output_raw_location because out_location would pollute
    ;; too much the callstack.
    (if oloc (output_raw_location oloc implbuf depth "checksignal"))
    (add2out implbuf " MELT_CHECK_SIGNAL();")
    (add2sbuf_indentnl implbuf depth)
))
(install_method class_objchecksignal output_c_code outpucod_objchecksignal)

;; output code for objanyblock
(defun outpucod_objanyblock (oblo declbuf implbuf :long depth)
  (assert_msg "check oblo" (is_a oblo class_objanyblock) oblo)
  (output_location (unsafe_get_field :obi_loc oblo) implbuf depth "block")
  (let ( (bodyl (unsafe_get_field :oblo_bodyl oblo))
	 (epil (unsafe_get_field :oblo_epil oblo)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (add2sbuf_strconst implbuf "/*anyblock*/{")
    (if (is_list bodyl)
	(output_code_instructions_list bodyl declbuf implbuf boxdepthp1))
    (if (is_list epil)
	(progn
	  (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	  (add2sbuf_strconst implbuf "/*epilog*/")
	  (output_code_instructions_list epil declbuf implbuf boxdepthp1)))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objanyblock output_c_code outpucod_objanyblock)


;; output code for objflag
(defun outpucod_objflag (oflag declbuf implbuf :long depth)
  (debug "outpucod_objflag oflag=" oflag)
  (assert_msg "check oflag" (is_a oflag class_objflag) oflag)
  (let ( (oflname (get_field :obflag_name oflag))
	 (oflrank (get_field :obflag_rank oflag))
	 )
    (add2out implbuf "meltmatchflag_" oflname "__rk" oflrank " "))
)
(install_method class_objflag output_c_code outpucod_objflag)

;; output code for objmatchflagblock
(defun outpucod_objmatchflagblock (oblo declbuf implbuf :long depth)
  (debug "outpucod_objmatchflagblock oblo=" oblo)
  (assert_msg "check oblo" (is_a oblo class_objmatchflagblock) oblo)
  (let (
	(oloc (get_field :obi_loc oblo))
	(oflags (get_field :omchflgblo_flags oblo))
	(obody (get_field :oblo_bodyl oblo))
	(oepil (unsafe_get_field :oblo_epil oblo)) 
	(:long depthsucc (+i depth 1))
	)
    (output_location oloc implbuf depth "matchflagblock")
    (add2sbuf_strconst implbuf "/*matchflagblock*/ {")
    ;; output flag declarations;
    (debug "outpucod_objmatchflagblock oflags=" oflags)
    (when oflags
      (assert_msg "check oflags" (is_multiple oflags) oflags)
      (foreach_in_multiple
       (oflags)
       (curoflag :long ix)
       (debug "outpucod_objmatchflagblock curoflag=" curoflag " ix=" ix)
       (assert_msg "check curoflag" (is_a curoflag class_objflag) curoflag)
       (add2sbuf_indentnl implbuf depthsucc)
       (add2sbuf_strconst implbuf "bool ") ;
       (output_c_code curoflag declbuf implbuf depthsucc)
       (add2sbuf_strconst implbuf " = false;")
       )
      )
    ;; output the body
    (debug "outpucod_objmatchflagblock obody=" obody)
    (when obody
      (add2sbuf_indentnl implbuf depthsucc)
      (output_location oloc implbuf depth "matchflagblock.body")
      (assert_msg "check obody" (is_list obody) obody)
      (output_code_instructions_list obody declbuf implbuf 
				     (constant_box depthsucc))
      )
    ;; output the epilog
    (debug "outpucod_objmatchflagblock oepil=" oepil)
    (when oepil
      (add2sbuf_indentnl implbuf depthsucc)
      (output_location oloc implbuf depth "matchflagblock.epilog")
      (assert_msg "check oepil" (is_list oepil) oepil)
      (output_code_instructions_list oepil declbuf implbuf 
				     (constant_box depthsucc))
      )
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf ";} /*end.matchflagblock*/  ") ;
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objmatchflagblock output_c_code outpucod_objmatchflagblock)

;; output code for objmultiallocblock
(defun outpucod_objmultiallocblock (oblo declbuf implbuf :long depth)
  (assert_msg "check oblo" (is_a oblo class_objmultiallocblock) oblo)
  (let ( (oloc (unsafe_get_field :obi_loc oblo))
	 (oallstruct (unsafe_get_field :omalblo_allstruct oblo))
	 (oname (unsafe_get_field :omalblo_name oblo))
	 (epil (unsafe_get_field :oblo_epil oblo))
	 (bodyl (unsafe_get_field :oblo_bodyl oblo))
	 (:long depthp1 (+i depth 1))
	 (boxdepthp1 (make_integerbox discr_integer depthp1))
	 (onameptr (let ( (ptrbuf (make_strbuf discr_strbuf)) )
		     (add2sbuf_string ptrbuf oname)
		     (add2sbuf_strconst ptrbuf "_ptr")
		     (strbuf2string discr_verbatim_string ptrbuf)))
	 )
    (output_location oloc implbuf depth "blockmultialloc")
    (assert_msg "check oallstruct" (is_multiple_or_null oallstruct) oallstruct)
    (add2sbuf_strconst implbuf "/*multiallocblock*/{")
    (add2sbuf_indentnl implbuf depthp1)
    (add2sbuf_strconst implbuf "struct ")
    (add2sbuf_string implbuf oname)
    (add2sbuf_strconst implbuf "_st {")
    (foreach_in_multiple
     (oallstruct)
     (curstru :long strix)
     (assert_msg "check curstru" (is_a curstru class_objinitelem) curstru)
     (add2sbuf_indentnl implbuf depthp1)
     (output_c_declinit curstru implbuf)
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    (add2sbuf_strconst implbuf " long ")
    (add2sbuf_string implbuf oname)
    (add2sbuf_strconst implbuf "_endgap; } *")
    (add2sbuf_string implbuf oname)
    (add2sbuf_strconst implbuf "_ptr = 0;")
    (add2sbuf_indentnl implbuf depthp1)
    (add2sbuf_string implbuf oname)
    (add2sbuf_strconst implbuf "_ptr = (struct ")
    (add2sbuf_string implbuf oname)
    (add2sbuf_strconst implbuf "_st *) meltgc_allocate (sizeof (struct ")
    (add2sbuf_string implbuf oname)
    (add2sbuf_strconst implbuf "_st), 0);")
    (add2sbuf_indentnl implbuf depthp1)   
    ;;
    (output_location oloc implbuf depth "blockmultialloc.initfill")
    (foreach_in_multiple
     (oallstruct)
     (curstru :long strix)
     (output_c_initial_fill curstru implbuf onameptr depthp1)
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     (add2sbuf_indentnl implbuf depthp1)   
     )
    ;;
    (if (is_list bodyl)
	(output_code_instructions_list bodyl declbuf implbuf boxdepthp1))
    ;;
    (if (is_list epil)
	(progn
	  (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	  (add2sbuf_strconst implbuf "/*epilog*/")
	  (output_code_instructions_list epil declbuf implbuf boxdepthp1)))
    (add2sbuf_strconst implbuf "} /*end multiallocblock*/")
    (add2sbuf_indentnl implbuf depth)
    )
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method class_objmultiallocblock output_c_code outpucod_objmultiallocblock)

;; output code for objciterblock
(defun outpucod_objciterblock (obcit  declbuf implbuf :long depth)
  (assert_msg "check obcit" (is_a obcit class_objciterblock) obcit)
  (let ( (oloc (unsafe_get_field :obi_loc obcit))
	 (bodyl (unsafe_get_field :oblo_bodyl obcit))
	 (epil (unsafe_get_field :oblo_epil obcit)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 (obefore (unsafe_get_field :obciter_before obcit))
	 (oafter (unsafe_get_field :obciter_after obcit))
	 (citer (unsafe_get_field :obciter_citer obcit))
	 )
    (assert_msg "check citer" (is_a citer class_citerator) citer)
    (output_location oloc "citerblock")
    (add2sbuf_strconst implbuf "/*citerblock ")
    (add2sbuf_ccomstring implbuf (unsafe_get_field :named_name citer))
    (add2sbuf_strconst implbuf "*/ {")
    (add2sbuf_indentnl implbuf depth)
    (output_location oloc "citerbefore")
    (foreach_in_multiple 
     (obefore)
     (obef :long ix)
     (output_c_code obef declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    (add2sbuf_indentnl implbuf depth)
    (output_location oloc "citerbody")
    (if (is_list bodyl)
	(output_code_instructions_list bodyl declbuf implbuf boxdepthp1))
    (add2sbuf_indentnl implbuf depth)
    (output_location oloc "citerafter")
    (foreach_in_multiple
     (oafter)
     (oaft :long ix)
     (output_c_code oaft declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    (add2sbuf_indentnl implbuf depth)
    (output_location oloc "citerepil")
    (if (is_list epil)
	(progn
	  (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	  (add2sbuf_strconst implbuf "/*citerepilog*/")
	  (output_code_instructions_list epil declbuf implbuf boxdepthp1)))
    (add2sbuf_strconst implbuf "} /*endciterblock ")
    (add2sbuf_ccomstring implbuf (unsafe_get_field :named_name citer))
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf depth)
    )
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method class_objciterblock output_c_code outpucod_objciterblock)

;;;;;;;;;;;;;;;;
(defun outpucod_objcommentinstr (obci declbuf implbuf :long depth)
  (assert_msg "check obci" (is_a obci class_objcommentinstr) obci)
  (let ( (oloc (unsafe_get_field :obi_loc obci))
	 (coms (unsafe_get_field :obci_comment obci))
	 (comstr (let ( (sbu (make_strbuf discr_strbuf)) )
		   (add2sbuf_ccomstring sbu coms)
		   (strbuf2string discr_string sbu)
		   ))
	 )
    (output_location oloc implbuf depth "comment")
    (add2sbuf_strconst implbuf "/**COMMENT: ")
    (add2sbuf_string implbuf comstr)
    (add2sbuf_strconst implbuf " **/;")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objcommentinstr output_c_code outpucod_objcommentinstr)

;;;;;;;;;;;;;;;;
;; output code for objcommentedblock
(defun outpucod_objcommentedblock (oblo declbuf implbuf :long depth)
  (assert_msg "check oblo" (is_a oblo class_objcommentedblock) oblo)
  (output_location (unsafe_get_field :obi_loc oblo) implbuf depth "block")
  (let ( (bodyl (unsafe_get_field :oblo_bodyl oblo))
	 (epil (unsafe_get_field :oblo_epil oblo)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 (coms (unsafe_get_field :ocomblo_comment oblo))
	 (comstr (let ( (sbu (make_strbuf discr_strbuf)) )
		   (add2sbuf_ccomstring sbu coms)
		   (strbuf2string discr_string sbu)
		   ))
	 )
    (add2sbuf_strconst implbuf "/*com.block:")
    (add2sbuf_string implbuf comstr)
    (add2sbuf_strconst implbuf "*/{")
    (if (is_list bodyl)
	(output_code_instructions_list bodyl declbuf implbuf boxdepthp1))
    (when (is_list epil)
      (add2sbuf_indentnl implbuf (get_int boxdepthp1))
      (add2sbuf_strconst implbuf "/*comp.epilog:")
      (add2sbuf_string implbuf comstr)
      (add2sbuf_strconst implbuf "*/")
      (output_code_instructions_list epil declbuf implbuf boxdepthp1))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_strconst implbuf "/*com.end block:")
    (add2sbuf_string implbuf comstr)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objcommentedblock output_c_code outpucod_objcommentedblock)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; output code for label instr

(definstance labelcountref class_reference :referenced_value '0)
(defun outpucod_objlabelinstr (oblab declbuf implbuf :long depth)
  (debug "outpucod_objlabelinstr oblab=" oblab)
  (assert_msg "check oblab" (is_a oblab class_objlabelinstr) oblab)
  (add2sbuf_indentnl implbuf depth)
  (add2sbuf_strconst implbuf "/*objlabel*/ ")
  (let ( (oprefix (unsafe_get_field :oblab_prefix oblab))
	 (obrank (unsafe_get_field :oblab_rank oblab)) 
	 (:long count (+i 1 (get_int !labelcountref)))
	 )
    (set_content labelcountref (constant_box count))
    (add2sbuf_string implbuf oprefix)
    (if obrank
	(add2sbuf_longdec implbuf (get_int obrank))
      (setq obrank (string4out discr_verbatim_string "_h" (obj_hash oblab)))
      )
    (add2sbuf_strconst implbuf ": ;")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    (output_location (unsafe_get_field :obi_loc oblab) implbuf depth "objlabel")
    (add2out 
     implbuf ##{ /* objlabel */
     #if MELTDEBUG_MATCHING
     static long meltlab_count_$COUNT;   
     meltlab_count_$COUNT++;
     debugeprintf("objlabel_$COUNT $OPREFIX#$OBRANK $OBLAB %ld", meltlab_count_$COUNT);
     #endif
     }#)
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objlabelinstr output_c_code outpucod_objlabelinstr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; output code for goto instr

(defun outpucod_objgotoinstr (obgoto declbuf implbuf :long depth)
  (assert_msg "check obgoto" (is_a obgoto class_objgotoinstr) obgoto)
  (output_location (unsafe_get_field :obi_loc obgoto) implbuf depth "objgoto")
  (add2sbuf_strconst implbuf "/*objgoto*/ goto ")
  (add2sbuf_string implbuf (unsafe_get_field :obgoto_prefix obgoto))
  (let ( (obrank (unsafe_get_field :obgoto_rank obgoto)) )
    (if obrank
	(add2sbuf_longdec implbuf (get_int obrank))))
  (add2sbuf_strconst implbuf ";")
  (add2sbuf_indentnl implbuf depth)
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method class_objgotoinstr output_c_code outpucod_objgotoinstr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; add a cname for a cloned identifier into a buffer
(defun add2sbuf_clonsym (sbuf csy)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (assert_msg "check csy" (is_a csy class_cloned_symbol) csy)
  (let ( (cnam (unsafe_get_field :named_name csy))
	 (:long rk (get_int (unsafe_get_field :csym_urank csy))) )
    (add2sbuf_cident sbuf cnam)
    (add2sbuf_strconst sbuf "_")
    (add2sbuf_longdec sbuf rk)
    (assert_msg "check limited sbuf" 
		(<i (strbuf_usedlength sbuf) (get_int !buffer_limit_cont)) sbuf)
    ))

;;; output code for objloop
(defun outpucod_objloop (oblo declbuf implbuf :long depth)
  (assert_msg "check oblo" (is_a oblo class_objloop) oblo)
  (let ( (bodyl (unsafe_get_field :oblo_bodyl oblo))
	 (epil (unsafe_get_field :oblo_epil oblo)) 
	 (lab (unsafe_get_field :obloop_label oblo))
	 (oloc (unsafe_get_field :obi_loc oblo))
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "check lab" (is_a lab class_cloned_symbol) lab)
    (output_location oloc implbuf depth "loop")
    (add2sbuf_strconst implbuf "/*loop*/{ meltlabloop_")
    (add2sbuf_clonsym implbuf lab)
    (add2sbuf_strconst implbuf ":;")
    (when (is_list bodyl)
      (output_location oloc implbuf depth "loopbody")
      (add2sbuf_indentnl implbuf (+i depth 1))
      (foreach_pair_component_in_list
       (bodyl)
       (curpair curbody)
       (let ( (:long depthp1 (get_int boxdepthp1)) )
	 (if (and curbody (not (is_a curbody class_objpurevalue)))
	     (output_c_code curbody declbuf implbuf depthp1))
	 (add2sbuf_strconst implbuf ";")
	 (add2sbuf_indentnl implbuf depthp1))))
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf " goto meltlabloop_")
    (add2sbuf_clonsym implbuf lab)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf " meltlabexit_")
    (add2sbuf_clonsym implbuf lab)
    (add2sbuf_strconst implbuf ":;")
    (when (is_list epil)
      (output_location oloc implbuf depth "loopepilog")
      (add2sbuf_strconst implbuf "/*loopepilog*/")
      (add2sbuf_indentnl implbuf (+i depth 1))
      (foreach_pair_component_in_list
       (epil)
       (curpair curepil)
       (let ( (:long depthp1 (get_int boxdepthp1)) )
	 (if (and curepil (not (is_a curepil class_objpurevalue)))
	     (output_c_code curepil declbuf implbuf depthp1))
	 (add2sbuf_strconst implbuf ";")
	 (assert_msg "check limited implbuf" 
		     (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
	 (add2sbuf_indentnl implbuf depthp1))))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objloop output_c_code outpucod_objloop)


;;; output code for objexit
(defun outpucod_objexit (obxi declbuf implbuf :long depth)
  (assert_msg "check obxi" (is_a obxi class_objexit) obxi)
  (let ( (olab (unsafe_get_field :obexit_label obxi))
	 (loc (unsafe_get_field :obi_loc obxi))
	 )
    (assert_msg "check olab" (is_a olab class_cloned_symbol) olab)
    (output_location loc implbuf depth "exit")
    (add2sbuf_strconst implbuf "/*exit*/{")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf " goto meltlabexit_")
    (add2sbuf_clonsym implbuf olab)	
    (add2sbuf_strconst implbuf ";}")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)    
    ))
(install_method class_objexit output_c_code outpucod_objexit)


;;; output code for objagain
(defun outpucod_objagain (obag declbuf implbuf :long depth)
  (assert_msg "check obag" (is_a obag class_objagain) obag)
  (let ( (olab (unsafe_get_field :obagain_label obag))
	 (loc (unsafe_get_field :obi_loc obag))
	 )
    (assert_msg "check olab" (is_a olab class_cloned_symbol) olab)
    (output_location loc implbuf depth "again")
    (add2sbuf_strconst implbuf "/*again*/{")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf " goto meltlabloop_")
    (add2sbuf_clonsym implbuf olab)	
    (add2sbuf_strconst implbuf ";}")
    (add2sbuf_indentnl implbuf depth) 
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)   
    ))
(install_method class_objagain output_c_code outpucod_objagain)

;;; output code for objcompute
(defun outpucod_objcompute (obcomp declbuf implbuf :long depth)
  (assert_msg "check obcomp" (is_a obcomp class_objcompute) obcomp)
  (let ( (cdest (unsafe_get_field :obdi_destlist obcomp)) ; destination list
	 (cloc (unsafe_get_field :obi_loc obcomp))
	 (cexp (unsafe_get_field :obcpt_expr obcomp)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (output_location cloc implbuf depth "compute")
    (if (is_list cdest)
	(foreach_pair_component_in_list 
	 (cdest)
	 (curpair destcur) 
	 (output_c_code destcur declbuf implbuf (get_int boxdepthp1))
	 (add2sbuf_strconst implbuf " = ")
	 ()))
    (cond ((is_list cexp)
	   (if (>i (list_length cexp) 2)
	       (add2sbuf_indentnl implbuf (+i 1 depth)))
	   (foreach_pair_component_in_list
	    (cexp)
	    (curpair expcur) 
	    (output_c_code expcur declbuf implbuf (get_int boxdepthp1))
	    (assert_msg "check limited implbuf" 
			(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)))
	    ))
	  ((is_multiple cexp)
	   (if (>i (multiple_length cexp) 2)
	       (add2sbuf_indentnl implbuf (+i 1 depth)))
	   (foreach_in_multiple
	    (cexp)
	    (expcur :long ix) 
	    (output_c_code expcur declbuf implbuf (get_int boxdepthp1))
	    (assert_msg "check limited implbuf" 
			(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
	    ))
	  (:else
	   (output_c_code cexp declbuf implbuf (+i depth 1))
	   ))
    (add2sbuf_strconst implbuf ";")
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objcompute output_c_code outpucod_objcompute)


;; output a conditional
(defun outpucod_objcond (ocond declbuf implbuf :long depth)
  (assert_msg "check ocond" (is_a ocond class_objcond) ocond)
  (let ( (cloc (unsafe_get_field :obi_loc ocond))
	 (ctest (unsafe_get_field :obcond_test ocond))
	 (cthen (unsafe_get_field :obcond_then ocond))
	 (celse (unsafe_get_field :obcond_else ocond)) 
	 )
    (assert_msg "check ctest" (notnull ctest) ctest)
    (output_location cloc implbuf depth "cond")
    (add2sbuf_strconst implbuf "/*cond*/ if (")
    (output_c_code ctest declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf ") /*then*/ {")
    (add2sbuf_indentnl implbuf depth)
    (when (and cthen (not (is_a cthen class_objpurevalue)))
      (output_location cloc implbuf depth "cond.then")
      (output_c_code cthen declbuf implbuf (+i depth 1))
      (add2sbuf_strconst implbuf ";")
      (add2sbuf_indentnl implbuf depth)
      )
    (if (and celse (not (is_a celse class_objpurevalue)))
	(progn
	  (add2sbuf_strconst implbuf "} else {")
	  (output_location cloc implbuf depth "cond.else")
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (output_c_code celse declbuf implbuf (+i depth 1))
	  (add2sbuf_strconst implbuf ";")
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (add2sbuf_strconst implbuf "}") ;
	  )
      (add2sbuf_strconst implbuf "} /*noelse*/")
      )
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ) 
  )
(install_method class_objcond output_c_code outpucod_objcond)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; output a cppif
(defun outpucod_objcppif (opif declbuf implbuf :long depth)
  (assert_msg "check opif" (is_a opif class_objcppif) opif)
  (let ( (cloc (unsafe_get_field :obi_loc opif))
	 (ccond (unsafe_get_field :obifp_cond opif))
	 (cthen (unsafe_get_field :obifp_then opif))
	 (celse (unsafe_get_field :obifp_else opif))
	 (:long depthp1 (+i 1 depth))
	 )
    (assert_msg "check ccond" (is_string ccond) ccond)
    (output_raw_location cloc implbuf depth "cppif")
    (add2sbuf_strconst implbuf "#if ")
    (add2sbuf_string implbuf ccond)
    (add2sbuf_indentnl implbuf depthp1)
    (output_location cloc implbuf depth "cppif.then")
    (output_c_code cthen declbuf implbuf depthp1)
    (add2sbuf_indentnl implbuf depthp1)
    (add2sbuf_strconst implbuf "#else /*")
    (add2sbuf_string implbuf ccond)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf depthp1)
    (output_location cloc implbuf depth "cppif.else")
    (output_c_code celse declbuf implbuf depthp1)
    (add2sbuf_indentnl implbuf depthp1)
    (add2sbuf_strconst implbuf "#endif /*")
    (add2sbuf_string implbuf ccond)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf depthp1)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objcppif output_c_code outpucod_objcppif)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun outpucod_objinternsymbol (oisy declbuf implbuf :long depth)
  (assert_msg "check oisy" (is_a oisy class_objinternsymbol))
  (let ( (cloc (unsafe_get_field :obi_loc oisy))
	 (oiobj (unsafe_get_field :obintern_iobj oisy))
	 (oidat (unsafe_get_field :oie_data oiobj)) 
	 (oilocv (unsafe_get_field :oie_locvar oiobj)) 
	 )
    (assert_msg "check oiobj" (is_a oiobj class_objinitobject) oiobj)
    (assert_msg "check oidat" (is_a oidat class_nrep_datasymbol) oidat)
    (let ( (nsy (unsafe_get_field :ndsy_namestr oidat)) )
      (output_location (if cloc cloc (unsafe_get_field :nrep_loc oidat)) implbuf 1 "internsymbol")
      (add2sbuf_strconst implbuf "/*internsym:")
      (add2sbuf_string implbuf nsy)
      (add2sbuf_strconst implbuf "*/")
      (add2sbuf_indentnl implbuf depth)
      (add2sbuf_strconst implbuf "(void) melthookproc_HOOK_INTERN_SYMBOL ((melt_ptr_t)(")
      (output_c_code oilocv declbuf implbuf depth)
      (add2sbuf_strconst implbuf "));")
      (add2sbuf_indentnl implbuf depth))
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objinternsymbol output_c_code outpucod_objinternsymbol)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun outpucod_objinternkeyword (oikw declbuf implbuf :long depth)
  (assert_msg "check oikw" (is_a oikw class_objinternkeyword) oikw)
  (let ( (cloc (unsafe_get_field :obi_loc oikw))
	 (oiobj (unsafe_get_field :obintern_iobj oikw))
	 (oidat (unsafe_get_field :oie_data oiobj)) 
	 (oilocv (unsafe_get_field :oie_locvar oiobj)) 
	 )
    (assert_msg "check oidat" (is_a oidat class_nrep_datakeyword) oidat)
    (let ( (nsy (unsafe_get_field :ndsy_namestr oidat)) )
      (output_location (if cloc cloc (unsafe_get_field :nrep_loc oidat)) implbuf depth "internkeyword")
      (add2sbuf_strconst implbuf "/*internkeyw:")
      (add2sbuf_string implbuf nsy)
      (add2sbuf_strconst implbuf "*/")
      (add2sbuf_indentnl implbuf depth)
      (add2sbuf_strconst implbuf "(void) melthookproc_HOOK_INTERN_KEYWORD ((melt_ptr_t)(")
      (output_c_code oilocv declbuf implbuf depth)
      (add2sbuf_strconst implbuf "));")
      (add2sbuf_indentnl implbuf depth))
    (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objinternkeyword output_c_code outpucod_objinternkeyword)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun outpucod_objgetnamedsymbol (ogsy declbuf implbuf :long depth)
  (assert_msg "check ogsy" (is_a ogsy class_objgetnamedsymbol) ogsy)
  (let ( (cloc (unsafe_get_field :obi_loc ogsy))
	 (oiobj (unsafe_get_field :obgnamed_iobj ogsy)) 
	 (ogdat (unsafe_get_field :oie_data oiobj))
	 (oilocv (unsafe_get_field :oie_locvar oiobj))
	 )
    (assert_msg "check oiobj" (is_a oiobj class_objinitobject) oiobj)
    (assert_msg "check ogdat" (is_a ogdat class_nrep_datasymbol) ogdat)
    (let ( (nsy (unsafe_get_field :ndsy_namestr ogdat)) 
	   )
      (output_location (if cloc cloc (unsafe_get_field :nrep_loc ogdat)) implbuf depth "getnamedsymbol")
      (add2sbuf_strconst implbuf "/*getnamedsym:")
      (add2sbuf_string implbuf nsy)
      (add2sbuf_strconst implbuf "*/")
      (add2sbuf_indentnl implbuf depth)
      (add2sbuf_indentnl implbuf (+i depth 1))
      (add2sbuf_strconst implbuf "if (NULL == ")
      (output_c_code oilocv declbuf implbuf (+i depth 1))
      (add2sbuf_strconst implbuf ") {")
      (add2sbuf_indentnl implbuf 0)
      ;; it should never happen that we have no initial environemt,
      ;; because the objgetnamedsymbol should not have been built.
      (add2sbuf_strconst implbuf "#if !MELT_HAS_INITIAL_ENVIRONMENT")
      (add2sbuf_indentnl implbuf 0)
      (add2out implbuf "#error MELT getting named symbol " nsy " without initial environment")
      (add2sbuf_indentnl implbuf 0)
      (add2sbuf_strconst implbuf "#endif /*!MELT_HAS_INITIAL_ENVIRONMENT*/")
      (add2sbuf_indentnl implbuf (+i depth 2))
      (add2sbuf_strconst implbuf " melt_ptr_t meltsy_")
      (add2sbuf_cident implbuf nsy)
      (add2sbuf_strconst implbuf " = melthookproc_HOOK_NAMED_SYMBOL (\"")
      (add2sbuf_string implbuf nsy)
      (add2sbuf_strconst implbuf "\", (long) MELT_GET);")
      (add2sbuf_indentnl implbuf (+i depth 2))
      (output_c_code oilocv declbuf implbuf (+i depth 3))
      (add2sbuf_strconst implbuf " = (melt_ptr_t) meltsy_")
      (add2sbuf_cident implbuf nsy)
      (add2sbuf_strconst implbuf ";")
      (add2sbuf_indentnl implbuf depth)
      (add2sbuf_strconst implbuf "} /*endgetnamedsym ")
      (add2sbuf_string implbuf nsy)
      (add2sbuf_strconst implbuf "*/")
      (add2sbuf_indentnl implbuf depth)
      (add2sbuf_indentnl implbuf depth)
      (assert_msg "check limited implbuf" 
		  (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
      )))
(install_method class_objgetnamedsymbol output_c_code outpucod_objgetnamedsymbol)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun outpucod_objgetnamedkeyword (ogkw declbuf implbuf :long depth)
  (assert_msg "check ogkw" (is_a ogkw class_objgetnamedkeyword) ogkw)
  (let ( (cloc (unsafe_get_field :obi_loc ogkw))
	 (oiobj (unsafe_get_field :obgnamed_iobj ogkw)) 
	 (ogdat (unsafe_get_field :oie_data oiobj))
	 (oilocv (unsafe_get_field :oie_locvar oiobj))
	 )
    (assert_msg "check oiobj" (is_a oiobj class_objinitobject) oiobj)
    (assert_msg "check ogdat" (is_a ogdat class_nrep_datakeyword) ogdat)
    (let ( (nkw (unsafe_get_field :ndsy_namestr ogdat)) )
      (output_location (if cloc cloc (unsafe_get_field :nrep_loc ogdat)) implbuf depth "getnamedkeyword")
      (add2sbuf_strconst implbuf "/*getnamedkeyw:")
      (add2sbuf_string implbuf nkw)
      (add2sbuf_strconst implbuf "*/")
      (add2sbuf_indentnl implbuf depth)
      (add2sbuf_strconst implbuf "{ melt_ptr_t kw_")
      (add2sbuf_cident implbuf nkw)
      (add2sbuf_strconst implbuf " = melthookproc_HOOK_NAMED_KEYWORD (\"")
      (add2sbuf_string implbuf nkw)
      (add2sbuf_strconst implbuf "\", (long) MELT_GET);")
      (add2sbuf_indentnl implbuf (+i depth 1))
      (add2sbuf_strconst implbuf "if (kw_")
      (add2sbuf_cident implbuf nkw)
      (add2sbuf_strconst implbuf ") ")
      (output_c_code oilocv declbuf implbuf (+i depth 1))
      (add2sbuf_strconst implbuf " = (melt_ptr_t) kw_")
      (add2sbuf_cident implbuf nkw)
      (add2sbuf_strconst implbuf "; }")
      (add2sbuf_indentnl implbuf depth)
      (assert_msg "check limited implbuf" 
		  (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
      )))
(install_method class_objgetnamedkeyword output_c_code outpucod_objgetnamedkeyword)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output an application
(defun outpucod_objapply (oapp declbuf implbuf :long depth)
  (assert_msg "check oapp" (is_a oapp class_objapply) oapp)
  (let (
	(aloc (unsafe_get_field :obi_loc oapp))
	(adest (unsafe_get_field :obdi_destlist oapp))
	(oclos (unsafe_get_field :obapp_clos oapp))
	(oargs (unsafe_get_field :obapp_args oapp))
	(:long nbarg (multiple_length oargs))
	(paramdesclist (make_list discr_list))
	(boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	)
    (output_location aloc implbuf depth "apply")
    (add2sbuf_strconst implbuf "/*apply*/{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (when (>i nbarg 1)
      (add2sbuf_strconst implbuf "union meltparam_un argtab[")
      (add2sbuf_longdec implbuf (-i nbarg 1))
      (add2sbuf_strconst implbuf "];")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      ;; output the initialization of argtab and fill the paramdesclist
      (foreach_in_multiple
       (oargs)
       (curarg :long curank)
       (assert_msg "outputcod_objapply check curarg not objinstr" (is_not_a curarg class_objinstr) curarg)
       (if (>i curank 0)
	   (let ( (curctyp (get_ctype curarg ())) )
	     (assert_msg "check curctyp" (is_a curctyp class_ctype) curctyp)
	     (output_location aloc implbuf (get_int boxdepthp1) "apply.arg")
	     (add2sbuf_strconst implbuf "argtab[")
	     (add2sbuf_longdec implbuf  (-i curank 1))
	     (add2sbuf_strconst implbuf "].")
	     (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
	     (cond ( (null curarg)
		     (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*)NULL")) 
		   ( (is_a curarg class_objnil)
		     (add2sbuf_strconst implbuf "meltbp_aptr = /*nil*/(melt_ptr_t*)NULL"))
		   ( (== curctyp ctype_value)
		     (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*) &")
		     (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		     )
		   (:else 
		    (add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
		    (add2sbuf_strconst implbuf " = ")
		    (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		    ))
	     (add2sbuf_strconst implbuf ";")
	     (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	     ))
       (assert_msg "check limited implbuf" 
		   (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
       )
      )
;;; output the destination(s)
    (foreach_pair_component_in_list 
     (adest)
     (curpair curdest) 
     (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)))
     (add2sbuf_strconst implbuf " = "))
    ;; output the apply and the closure
    (add2sbuf_strconst implbuf " melt_apply ((meltclosure_ptr_t)(")
    (output_c_code oclos declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "), (melt_ptr_t)(")
    ;; output the first argument
    (let ( (firstarg (multiple_nth oargs 0)) )
      (output_c_code firstarg declbuf implbuf (+i 1 depth))
      )
    (add2sbuf_strconst implbuf "), (")
    ;; output the argdescr string
    (foreach_pair_component_in_list
     (paramdesclist)
     (curpair pard)
     (add2sbuf_string implbuf pard)
     (add2sbuf_strconst implbuf " "))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the argtab (or null if none)
    (if (>i nbarg 1)
	(add2sbuf_strconst implbuf "argtab,")
      (add2sbuf_strconst implbuf "(union meltparam_un*)0,"))
    ;; no extra results
    (add2sbuf_strconst implbuf " \"\", (union meltparam_un*)0")
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objapply output_c_code outpucod_objapply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a message send
(defun outpucod_objmsend (omsend declbuf implbuf :long depth)
  (assert_msg "check omsend" (is_a omsend class_objmsend) omsend)
  (let ( (oloc (unsafe_get_field :obi_loc omsend))
	 (odest (unsafe_get_field :obdi_destlist omsend))
	 (osel (unsafe_get_field :obmsnd_sel omsend))
	 (orecv (unsafe_get_field :obmsnd_recv omsend))
	 (oargs (unsafe_get_field :obmsnd_args omsend))
	 (:long nbarg (multiple_length oargs))
	 (paramdesclist (make_list discr_list))
	 (boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	 )
    (output_location oloc implbuf depth "msend")
    (add2sbuf_strconst implbuf "/*msend*/{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (when (>i nbarg 0)
      ;; the code below is very similar to code inside
      ;; outpucod_objapply except that we do not shift arguments by
      ;; one
      (add2sbuf_strconst implbuf "union meltparam_un argtab[")
      (add2sbuf_longdec implbuf nbarg)
      (add2sbuf_strconst implbuf "];")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      ;; output the initialization of argtab and fill the paramdesclist
      (foreach_in_multiple
       (oargs)
       (curarg :long curank)
       (let ( (curctyp (get_ctype curarg ())) )
	 (assert_msg "check curctyp" (is_a curctyp class_ctype))
	 (output_location oloc implbuf (get_int boxdepthp1) "ojbmsend.arg")
	 (add2sbuf_strconst implbuf "argtab[")
	 (add2sbuf_longdec implbuf  curank)
	 (add2sbuf_strconst implbuf "].")
	 (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
	 (cond ( (null curarg)
		 (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*)NULL")
		 ) 
	       ( (is_a curarg class_objnil)
		 (add2sbuf_strconst implbuf "meltbp_aptr = /*nil*/(melt_ptr_t*)NULL")
		 )
	       ( (== curctyp ctype_value)
		 (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*) &")
		 (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		 )
	       (:else
		(assert_msg "check curarg is not multiple" (not (is_multiple curarg)))
		(add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
		(add2sbuf_strconst implbuf " = ")
		(output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		))
	 (add2sbuf_strconst implbuf ";")
	 (assert_msg "check limited implbuf" 
		     (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
	 (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	 ))
      )
;;; output the destination(s)
    (foreach_pair_component_in_list
     (odest)
     (curpair curdest) 
     (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     (add2sbuf_strconst implbuf " = "))
    ;;
    (assert_msg "check orecv object" (is_object orecv) orecv)
    ;;
    (add2sbuf_strconst implbuf "meltgc_send((melt_ptr_t)(")
    (output_c_code orecv declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "), (melt_ptr_t)(")
    (output_c_code osel declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "), (")
    ;; output the argdescr string
    (foreach_pair_component_in_list
     (paramdesclist)
     (curpair pard)
     (assert_msg "check pard" (is_string pard))
     (add2sbuf_string implbuf pard)
     (add2sbuf_strconst implbuf " "))
    (add2sbuf_strconst implbuf "\"\"), ")
    (if (>i nbarg 0)
	(add2sbuf_strconst implbuf "argtab,")
      (add2sbuf_strconst implbuf "(union meltparam_un*)0,"))
    ;; no extra results
    (add2sbuf_strconst implbuf " \"\", (union meltparam_un*)0")
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objmsend output_c_code outpucod_objmsend)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a multiresult application

(defun outpucod_objmultiapply (oapp declbuf implbuf :long depth)
  (assert_msg "check oapp" (is_a oapp class_objmultiapply) oapp)
  (let (
	(aloc (unsafe_get_field :obi_loc oapp))
	(adest (unsafe_get_field :obdi_destlist oapp))
	(oclos (unsafe_get_field :obapp_clos oapp))
	(oargs (unsafe_get_field :obapp_args oapp))
	(oxres (unsafe_get_field :obmultapp_xres oapp))
	(:long nbarg (multiple_length oargs))
	(:long nbxres (multiple_length oxres))
	(paramdesclist (make_list discr_list))
	(resdesclist (make_list discr_list))
	(boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	)
    (assert_msg "check oargs" (is_multiple_or_null oargs) oargs)
    (assert_msg "check oxres" (is_multiple_or_null oxres) oxres)
    (output_location aloc implbuf depth "multiapply")
    (add2sbuf_strconst implbuf "/*multiapply ")
    (add2sbuf_longdec implbuf nbarg)
    (add2sbuf_strconst implbuf "args, ")
    (add2sbuf_longdec implbuf nbxres)
    (add2sbuf_strconst implbuf "x.res*/ ")
    (add2sbuf_strconst implbuf "{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (when (>i nbarg 1)
      (add2sbuf_strconst implbuf "union meltparam_un argtab[")
      (add2sbuf_longdec implbuf (-i nbarg 1))
      (add2sbuf_strconst implbuf "];")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      )
    (when (>i nbxres 0)
      (add2sbuf_indentnl implbuf (+i 1 depth))
      (add2sbuf_strconst implbuf "union meltparam_un restab[")
      (add2sbuf_longdec implbuf nbxres)
      (add2sbuf_strconst implbuf "];")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      )
    (when (>i nbxres 0)
      (add2sbuf_strconst implbuf "memset(&restab, 0, sizeof(restab));")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      ;; fill the resdesclist
      (foreach_in_multiple 
       (oxres)
       (cures :long curank)
       (let ( (curctyp (get_ctype cures ())) )
	 (list_append resdesclist (unsafe_get_field :ctype_parstring curctyp)))))
    (when (>i nbarg 1)
      (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      ;; output the initialization of argtab and fill the paramdesclist
      (foreach_in_multiple
       (oargs)
       (curarg :long curank)
       (if (>i curank 0)
	   (let ( (curctyp (get_ctype curarg ())) )
	     (assert_msg "check curctyp" (is_a curctyp class_ctype))
	     (output_location aloc implbuf (get_int boxdepthp1) "multiapply.arg")
	     (add2sbuf_strconst implbuf "argtab[")
	     (add2sbuf_longdec implbuf  (-i curank 1))
	     (add2sbuf_strconst implbuf "].")
	     (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
	     (cond
	      ( (null curarg)
		(add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*)NULL"))
	      ( (== curctyp ctype_value)
		(add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*) &")
		(output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		)
	      (:else
	       (add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
	       (add2sbuf_strconst implbuf " = ")
	       (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
	       ))
	     (add2sbuf_strconst implbuf ";")
	     ))
       (assert_msg "check limited implbuf" 
		   (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
       )
      (add2sbuf_indentnl implbuf (get_int boxdepthp1))
      )
    ;; output the initialization of restab
    (when (>i nbxres 0)
      (foreach_in_multiple
       (oxres)
       (cures :long curank)
       (let ( (curestyp (get_ctype cures ())) )
	 (assert_msg "check curestyp" (is_a curestyp class_ctype))
	 (output_location aloc implbuf (get_int boxdepthp1) "multiapply.xres")
	 (add2sbuf_strconst implbuf "restab[")
	 (add2sbuf_longdec implbuf  curank)
	 (add2sbuf_strconst implbuf "].")
	 (cond
	  ( (null cures)
	    (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*)NULL"))
	  ( (== curestyp ctype_value)
	    (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*) &")
	    (output_c_code cures declbuf implbuf (get_int boxdepthp1))
	    )
	  (:else
	   (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield curestyp))
	   (add2sbuf_strconst implbuf " =  & ")
	   (output_c_code cures declbuf implbuf (get_int boxdepthp1))
	   ))
	 (add2sbuf_strconst implbuf ";")
	 (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	 ))
      )
    (output_location aloc implbuf (get_int boxdepthp1) "multiapply.appl")
;;; output the destination(s)
    (foreach_pair_component_in_list
     (adest)
     (curpair curdest) 
     (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
     (add2sbuf_strconst implbuf " = "))
    ;; output the apply and the closure
    (add2sbuf_strconst implbuf " melt_apply ((meltclosure_ptr_t)(")
    (output_c_code oclos declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "), (melt_ptr_t)(")
    ;; output the first argument
    (let ( (firstarg (multiple_nth oargs 0)) )
      (output_c_code firstarg declbuf implbuf (+i 1 depth))
      )
    (add2sbuf_strconst implbuf "), (")
    ;; output the argdescr string
    (list_every 
     paramdesclist
     (lambda (pard)
       (add2sbuf_string implbuf pard)
       (add2sbuf_strconst implbuf " ")))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the argtab (or null if none)
    (if (>i nbarg 1)
	(add2sbuf_strconst implbuf "argtab, (")
      (add2sbuf_strconst implbuf "(union meltparam_un*)0, ("))
    ;; output the resdescr string
    (foreach_pair_component_in_list
     (resdesclist)
     (curpair resd)
     (add2sbuf_string implbuf resd)
     (add2sbuf_strconst implbuf " "))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the extra results
    (if (>i nbxres 0)
	(add2sbuf_strconst implbuf "restab")
      (add2sbuf_strconst implbuf "(union meltparam_un*)0"))
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))

(install_method class_objmultiapply output_c_code outpucod_objmultiapply)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a multiresult message send
(defun outpucod_objmultimsend (omsnd  declbuf implbuf :long depth)
  (assert_msg "check omsnd" (is_a omsnd class_objmultimsend) omsnd)
  (let ( (oloc (unsafe_get_field :obi_loc omsnd))
	 (odest (unsafe_get_field :obdi_destlist omsnd))
	 (osel (unsafe_get_field :obmsnd_sel omsnd))
	 (orecv (unsafe_get_field :obmsnd_recv omsnd))
	 (oargs (unsafe_get_field :obmsnd_args omsnd))
	 (oxres (unsafe_get_field :obmultsnd_xres omsnd))
	 (:long nbarg (multiple_length oargs))
	 (:long nbxres (multiple_length oxres))
	 (paramdesclist (make_list discr_list))
	 (resdesclist (make_list discr_list))
	 (boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	 )
    (output_location oloc implbuf depth "multimsend")
    (add2sbuf_strconst implbuf "/*multimsend*/{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (when (>i nbarg 0)
      (add2sbuf_strconst implbuf "union meltparam_un argtab[")
      (add2sbuf_longdec implbuf nbarg)
      (add2sbuf_strconst implbuf "];")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      )
    (when (>i nbxres 0)
      (add2sbuf_strconst implbuf "union meltparam_un restab[")
      (add2sbuf_longdec implbuf nbxres)
      (add2sbuf_strconst implbuf "];")
      (add2sbuf_indentnl implbuf (+i 1 depth))
      ;; fill the resdesclist
      (foreach_in_multiple 
       (oxres)
       (cures :long curank)
       (let ( (curestyp (get_ctype cures ())) )
	 (list_append resdesclist (unsafe_get_field :ctype_parstring curestyp))))
      )
    (when (>i nbarg 0)
      (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
      (add2sbuf_indentnl implbuf (+i 1 depth)))
    (when (>i nbxres 0)
      (add2sbuf_strconst implbuf "memset(&restab, 0, sizeof(restab));")
      (add2sbuf_indentnl implbuf (+i 1 depth)))
    ;; output the initialization of argtab and fill paramdesclist
    (when (>i nbarg 0)
      ;; output the initialization of argtab and fill the paramdesclist
      (foreach_in_multiple
       (oargs)
       (curarg :long curank)
       (let ( (curctyp (get_ctype curarg ())) )
	 (assert_msg "check curctyp" (is_a curctyp class_ctype))
	 (output_location oloc implbuf (get_int boxdepthp1) "multimsend.arg")
	 (add2sbuf_strconst implbuf "argtab[")
	 (add2sbuf_longdec implbuf   curank)
	 (add2sbuf_strconst implbuf "].")
	 (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
	 (cond
	  ( (null curarg)
	    (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*)NULL"))
	  ( (== curctyp ctype_value)
	    (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*) &")
	    (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
	    )
	  (:else
	   (add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
	   (add2sbuf_strconst implbuf " = ")
	   (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
	   ))
	 (add2sbuf_strconst implbuf ";")
	 )
       (assert_msg "check limited implbuf" 
		   (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)))
       )
      (add2sbuf_indentnl implbuf (get_int boxdepthp1))
      )
    ;; output the initialization of restab
    (when (>i nbxres 0)
      (foreach_in_multiple
       (oxres)
       (cures :long curank)
       (let ( (curestyp (get_ctype cures ())) )
	 (assert_msg "check curestyp" (is_a curestyp class_ctype) curestyp)
	 (output_location oloc implbuf (get_int boxdepthp1) "multimsend.xres")
	 (add2sbuf_strconst implbuf "restab[")
	 (add2sbuf_longdec implbuf  curank)
	 (add2sbuf_strconst implbuf "].")
	 (cond
	  ( (null cures)
	    (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*)NULL")
	    )
	  ( (== curestyp ctype_value)
	    (add2sbuf_strconst implbuf "meltbp_aptr = (melt_ptr_t*) &")
	    (output_c_code cures declbuf implbuf (get_int boxdepthp1))
	    )
	  (:else
	   (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield curestyp))
	   (add2sbuf_strconst implbuf " = ")
	   (output_c_code cures declbuf implbuf (get_int boxdepthp1))
	   ))
	 (add2sbuf_strconst implbuf ";")
	 )
       )
      )
    (output_location oloc implbuf (get_int boxdepthp1) "multimsend.send")
;;; output the destination(s)
    (foreach_pair_component_in_list
     (odest)
     (curpair curdest) 
     (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
     (add2sbuf_strconst implbuf " = "))
    ;; output the send and the receiver
    (add2sbuf_strconst implbuf " meltgc_send ((melt_ptr_t)(")
    (output_c_code orecv declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "), ((melt_ptr_t)(")
    ;; output the selector
    (output_c_code osel declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf ")), (")
    ;; output the argdescr string
    (foreach_pair_component_in_list 
     (paramdesclist)
     (curpair pard)
     (add2sbuf_string implbuf pard)
     (add2sbuf_strconst implbuf " "))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the argtab (or null if none)
    (if (>i nbarg 0)
	(add2sbuf_strconst implbuf "argtab, (")
      (add2sbuf_strconst implbuf "(union meltparam_un*)0, ("))
    ;; output the resdescr string
    (foreach_pair_component_in_list
     (resdesclist)
     (curpair resd)
     (add2sbuf_string implbuf resd)
     (add2sbuf_strconst implbuf " "))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the extra results
    (if (>i nbxres 0)
	(add2sbuf_strconst implbuf "restab")
      (add2sbuf_strconst implbuf "(union meltparam_un*)0"))
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objmultimsend output_c_code outpucod_objmultimsend)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a clear
(defun outpucod_objclear (oclear declbuf implbuf :long depth)
  (assert_msg "check oclear" (is_a oclear class_objclear) oclear)
  (let ( (cloc (unsafe_get_field :obi_loc oclear))
	 (cvl (unsafe_get_field :oclr_vloc oclear))
	 )
    (output_location cloc implbuf depth "clear")
    (add2sbuf_strconst implbuf "/*clear*/ ")
    (output_c_code cvl declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf " = 0 ")
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objclear output_c_code outpucod_objclear)

;; output a raw object allocation
(defun outpucod_objrawallocobj (oralob declbuf implbuf :long depth)
  (assert_msg "check oralob" (is_a oralob class_objrawallocobj) oralob)
  (let ( (iloc (unsafe_get_field :obi_loc oralob))
	 (iclass (unsafe_get_field :obrallobj_class oralob))
	 (iclaname (unsafe_get_field :obrallobj_classname oralob))
	 (ilen (unsafe_get_field :obrallobj_len oralob))
	 (destlist (unsafe_get_field :obdi_destlist oralob)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "outpucod_objrawallocobj check iclass" (is_a iclass class_objvalue))
    (output_location iloc implbuf depth "rawallocobj")
    (add2sbuf_strconst implbuf "/*rawallocobj*/ { melt_ptr_t newobj = 0;")
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "melt_raw_object_create(newobj,(melt_ptr_t)(")
    (output_c_code iclass declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "), (")
    (output_c_code ilen  declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "), \"")
    (add2sbuf_cencstring implbuf iclaname) 
    (add2sbuf_strconst implbuf "\");")
    (foreach_pair_component_in_list
     destlist
     (dstpair dst) 
     (add2sbuf_indentnl implbuf (+i depth 1))
     (output_c_code dst declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		  (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     (add2sbuf_strconst implbuf " =")))
  (add2sbuf_indentnl implbuf (+i depth 1))
  (add2sbuf_strconst implbuf "newobj; };")
  (add2sbuf_indentnl implbuf depth)
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method class_objrawallocobj output_c_code outpucod_objrawallocobj)


;; output a closure allocation
(defun outpucod_objnewclosure (obnclo declbuf implbuf :long depth)
  (assert_msg "check oralob" (is_a obnclo class_objnewclosure) obnclo)
  (let ( (iloc (unsafe_get_field :obi_loc obnclo))
	 (odiscr (unsafe_get_field :obnclo_discr obnclo))
	 (orout (unsafe_get_field :obnclo_rout obnclo))
	 (olen (unsafe_get_field :obnclo_len obnclo))
	 (destlist (unsafe_get_field :obdi_destlist obnclo))
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (output_location iloc implbuf depth "newclosure")
    (add2sbuf_strconst implbuf " /*newclosure*/ ")
    (foreach_pair_component_in_list
     (destlist)
     (curpair dst) 
     (output_c_code dst declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     (add2sbuf_strconst implbuf " ="))
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "(melt_ptr_t) meltgc_new_closure((meltobject_ptr_t)(")
    (output_c_code odiscr declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "), (meltroutine_ptr_t)(")
    (output_c_code orout declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "), (")
    (output_c_code olen declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "));")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objnewclosure  output_c_code outpucod_objnewclosure)

;; output a touch
(defun outpucod_objtouch (otouch declbuf implbuf :long depth)
  (assert_msg "check otouch" (is_a otouch class_objtouch))
  (let ( (iloc (unsafe_get_field :obi_loc otouch)) 
	 (touched (unsafe_get_field :otouch_val otouch)) 
	 (comm (unsafe_get_field :otouch_comment otouch))
	 )
    (output_location iloc implbuf depth "touch")
    (when comm 
      (add2sbuf_strconst implbuf "/*touch:")
      (add2sbuf_cident implbuf comm)
      (add2sbuf_strconst implbuf "*/")
      (add2sbuf_indentnl implbuf depth)
      )
    (add2sbuf_strconst implbuf "meltgc_touch(")
    (output_c_code touched declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    )
  )
(install_method class_objtouch output_c_code outpucod_objtouch)



;; output a debug tracing of written object
(defun outpucod_dbgtracewriteobj (otwro declbuf implbuf :long depth)
  (assert_msg "check otwro" (is_a otwro class_objdbgtracewriteobj) otwro)
  (let ( (iloc (unsafe_get_field :obi_loc otwro)) 
	 (owritten (unsafe_get_field :obdtw_writtenobj otwro)) 
	 (msg (unsafe_get_field :obdtw_message otwro))
	 )
    (output_location iloc implbuf depth "touchobj")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_dbgtrace_written_object (")
    (output_c_code owritten declbuf implbuf depth)
    (add2sbuf_strconst implbuf ", \"")
    (if (is_string msg) 
	(add2sbuf_cencstring implbuf msg)
      (add2sbuf_strconst implbuf "*written object*"))
    (add2sbuf_strconst implbuf "\");")
    (add2sbuf_indentnl implbuf depth)))
(install_method class_objdbgtracewriteobj output_c_code outpucod_dbgtracewriteobj)
	     
  
;;; output a put tuple (mostly used in initial data content filling)
(defun outpucod_objputuple (optup declbuf implbuf :long depth)
  (assert_msg "check optyp" (is_a optup class_objputuple) optup)
  (let ( (iloc (unsafe_get_field :obi_loc optup))
	 (otup (unsafe_get_field :oputu_tupled optup))
	 (ooff (unsafe_get_field :oputu_offset optup))
	 (:long uniqrank 0)
	 (oval (unsafe_get_field :oputu_value optup)) 
	 )
    (code_chunk uniqrankset 
		#{ { /* outpucod_objputuple $UNIQRANKSET */  
                static long $UNIQRANKSET#_cnt ;
		$UNIQRANKSET#_cnt++		 ;
		$UNIQRANK = $UNIQRANKSET#_cnt	 ;
		} /* end  outpucod_objputuple $UNIQRANKSET */ }#)
    (multicall 
     (linev filev)
     (line_and_file_of_location iloc)
     (output_location iloc implbuf depth "putuple")
     (add2sbuf_strconst implbuf "/*putupl")
     (add2sbuf_strconst implbuf "#")
     (add2sbuf_longdec implbuf uniqrank)
     (add2sbuf_strconst implbuf "*/")
     (add2sbuf_indentnl implbuf depth)
     (add2sbuf_strconst implbuf "melt_assertmsg(\"putupl ")
     (if (>i (get_int linev) 0)
	 (progn 
	   (add2sbuf_strconst implbuf "[")
	   (add2sbuf_string implbuf filev)
	   (add2sbuf_strconst implbuf ":")
	   (add2sbuf_longdec implbuf (get_int linev))
	   (add2sbuf_strconst implbuf "] ")
	   ))
     (add2sbuf_strconst implbuf "#")
     (add2sbuf_longdec implbuf uniqrank)
     (add2sbuf_strconst implbuf " checktup\", melt_magic_discr((melt_ptr_t)(")
     (output_c_code otup declbuf implbuf depth)
     (add2sbuf_strconst implbuf "))== MELTOBMAG_MULTIPLE);")
     (add2sbuf_indentnl implbuf depth)
     (add2sbuf_strconst implbuf "melt_assertmsg(\"putupl ")
     (if (>i (get_int linev) 0)
	 (progn 
	   (add2sbuf_strconst implbuf "[")
	   (add2sbuf_string implbuf filev)
	   (add2sbuf_strconst implbuf ":")
	   (add2sbuf_longdec implbuf (get_int linev))
	   (add2sbuf_strconst implbuf "] ")
	   ))
     (add2sbuf_strconst implbuf "#")
     (add2sbuf_longdec implbuf uniqrank)
     (add2sbuf_strconst implbuf " checkoff\", (")
     (output_c_code ooff declbuf implbuf depth)
     (add2sbuf_strconst implbuf ">=0 && ")
     (output_c_code ooff declbuf implbuf depth)
     (add2sbuf_strconst implbuf "< melt_multiple_length((melt_ptr_t)(")
     (output_c_code otup declbuf implbuf depth)
     (add2sbuf_strconst implbuf "))));")
     (add2sbuf_indentnl implbuf depth)
     (add2sbuf_strconst implbuf "((meltmultiple_ptr_t)(")
     (output_c_code otup declbuf implbuf depth)
     (add2sbuf_strconst implbuf "))->tabval[")
     (output_c_code ooff declbuf implbuf depth)
     (add2sbuf_strconst implbuf "] = (melt_ptr_t)(")
     (output_c_code oval declbuf implbuf depth)
     (add2sbuf_strconst implbuf ");")
     (add2sbuf_indentnl implbuf depth)
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    )
  )
(install_method class_objputuple output_c_code outpucod_objputuple)

;;;;
(definstance objputpairhead_counter class_reference :referenced_value '0)

(defun outpucod_objputpairhead (oput declbuf implbuf :long depth)
  (let ( (oloc (unsafe_get_field :obi_loc oput))
	 (opair (get_field :oputp_pair oput))
	 (ohead (get_field :oputp_head oput))
	 (oldcount !objputpairhead_counter)
	 (newcount (+ivi oldcount 1))
	)
    (output_location oloc implbuf depth "putpairhead")
    (add2sbuf_strconst implbuf "/*putpairhead*/")
    (add2sbuf_indentnl implbuf depth)
    (set_ref objputpairhead_counter newcount)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putpairhead /")
    (add2sbuf_longhex implbuf (get_int newcount))
    (add2sbuf_strconst implbuf " checkpair\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code opair declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))== MELTOBMAG_PAIR);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltpair_ptr_t)(")
    (output_c_code opair declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))->hd = (melt_ptr_t) (")
    (output_c_code ohead declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
))
(install_method class_objputpairhead output_c_code outpucod_objputpairhead)

;;;;
(defun outpucod_objputpairtail (oput declbuf implbuf :long depth)
  (let ( (oloc (unsafe_get_field :obi_loc oput))
	 (opair (get_field :oputp_pair oput))
	 (otail (get_field :oputp_tail oput))
	)
    (output_location oloc implbuf depth "putpairtail")
    (add2sbuf_strconst implbuf "/*putpairtail*/")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putpairtail /")
    (add2sbuf_longhex implbuf (obj_hash oput))
    (add2sbuf_strconst implbuf " checkpair\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code opair declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))== MELTOBMAG_PAIR);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltpair_ptr_t)(")
    (output_c_code opair declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))->tl = (meltpair_ptr_t) (")
    (output_c_code otail declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
))
(install_method class_objputpairtail output_c_code outpucod_objputpairtail)

;;;;
(defun outpucod_objputlist (oput declbuf implbuf :long depth)
  (let ( (oloc (unsafe_get_field :obi_loc oput))
	 (olist (get_field :oputl_list oput))
	 (ofirst (get_field :oputl_first oput))
	 (olast (get_field :oputl_last oput))
	)
    (output_location oloc implbuf depth "putlist")
    (add2sbuf_strconst implbuf "/*putlist*/")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putlist checklist\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code olist declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))== MELTOBMAG_LIST);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltlist_ptr_t)(")
    (output_c_code olist declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))->first = (meltpair_ptr_t) (")
    (output_c_code ofirst declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltlist_ptr_t)(")
    (output_c_code olist declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))->last = (meltpair_ptr_t) (")
    (output_c_code olast declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
))
(install_method class_objputlist output_c_code outpucod_objputlist)

;;;;
(defun outpucod_objgetslot (ogsl declbuf implbuf :long depth)
  (assert_msg "check ogsl" (is_a ogsl class_objgetslot) ogsl)
  (let ( (oloc (unsafe_get_field :obi_loc ogsl))
	 (destlist (unsafe_get_field :obdi_destlist ogsl))
	 (oobj (unsafe_get_field :ogetsl_obj ogsl))
	 (ofield (unsafe_get_field :ogetsl_field ogsl))
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "check ofield" (is_a ofield class_field) ofield)
    (output_location oloc implbuf depth "getslot")
    (add2sbuf_strconst implbuf "{ melt_ptr_t slot=NULL, obj=NULL;")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "obj = (melt_ptr_t)(") ;
    (output_c_code oobj declbuf implbuf depth)
    (add2sbuf_strconst implbuf ") /*=obj*/;") ;
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "melt_object_get_field(slot,obj, ")
    (add2sbuf_longdec implbuf (get_int ofield))
    (add2sbuf_strconst implbuf ", \"")
    (add2sbuf_string implbuf (unsafe_get_field :named_name ofield))
    (add2sbuf_strconst implbuf "\");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (foreach_pair_component_in_list
     (destlist)
     (curpair dst)    
     (output_c_code dst declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     (add2sbuf_strconst implbuf " = "))
    (add2sbuf_strconst implbuf "slot; };")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objgetslot output_c_code outpucod_objgetslot)



;;; output a put slot (mostly used in initial data content filling)
(defun outpucod_objputslot (opslo declbuf implbuf :long depth)
  (debug "outpucod_objputslot opslo=" opslo)
  (assert_msg "check opslo" (is_a opslo class_objputslot) opslo)
  (let ( (iloc (unsafe_get_field :obi_loc opslo))
	 (odata (unsafe_get_field :oslot_odata opslo))
	 (ooff (unsafe_get_field :oslot_offset opslo))
	 (ofield (unsafe_get_field :oslot_field opslo))
	 (oval (unsafe_get_field :oslot_value opslo))
	 (msg (let ( (msgbuf (make_strbuf discr_strbuf))
		     )
		(add2out msgbuf "putslot ")
		(cond ( (is_a odata class_named)
			(add2out msgbuf " "  (unsafe_get_field :named_name odata))
			)
		      ( (is_a odata class_objinitelem)
			(add2out msgbuf " ~" (unsafe_get_field :oie_cname odata)))
		      (:else
		       (add2out msgbuf " _")))
		(cond ( (is_a ofield class_named)
			(add2out msgbuf " @" (unsafe_get_field :named_name ofield)))
		      (:else
		       (add2out msgbuf " @#" ooff)))
		(strbuf2string discr_verbatim_string msgbuf)))
	 )
    (debug "outpucod_objputslot msg=" msg)
    (assert_msg "outpucod_objputslot check oval not nrep" (is_not_a oval class_nrep) oval)
    (output_location iloc implbuf depth "putslot")
    (add2sbuf_strconst implbuf "/*putslot*/")
    (add2sbuf_indentnl implbuf depth)
    (add2out implbuf "melt_assertmsg(\"checkobj " msg)
    (add2sbuf_strconst implbuf "\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code odata declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")) == MELTOBMAG_OBJECT);")
    (add2sbuf_indentnl implbuf depth)
    (if (is_a ofield class_field)
	(progn
	  (add2sbuf_strconst implbuf "melt_putfield_object((")
	  (output_c_code odata declbuf implbuf depth)
	  (add2sbuf_strconst implbuf "), (")
	  (output_c_code ooff declbuf implbuf depth)
	  (add2sbuf_strconst implbuf "), (")
	  (output_c_code oval declbuf implbuf (+i 1 depth))
	  (add2sbuf_strconst implbuf "), \"")
	  (add2sbuf_cident implbuf (unsafe_get_field :named_name ofield))
	  (add2sbuf_strconst implbuf "\");")
	  )
      (progn
;;; this only happens for initialization of instances
	(add2sbuf_indentnl implbuf depth)
	(add2out implbuf "melt_assertmsg(\"checkoff " msg)
	(add2sbuf_strconst implbuf "\", (")
	(output_c_code ooff declbuf implbuf depth)
	(add2sbuf_strconst implbuf ">=0 && ")
	(output_c_code ooff declbuf implbuf depth)
	(add2sbuf_strconst implbuf "< melt_object_length((melt_ptr_t)(")
	(output_c_code odata declbuf implbuf depth)
	(add2sbuf_strconst implbuf "))));")
	(add2sbuf_indentnl implbuf depth)
	(add2sbuf_strconst implbuf "((meltobject_ptr_t)(")
	(output_c_code odata declbuf implbuf depth)
	(add2sbuf_strconst implbuf "))->obj_vartab[")
	(output_c_code ooff declbuf implbuf depth)
	(add2sbuf_strconst implbuf "] = (melt_ptr_t)(")
	(add2sbuf_indentnl implbuf (+i 1 depth))
	(output_c_code oval declbuf implbuf (+i 1 depth))
	(add2sbuf_strconst implbuf ");")
	)
      )
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objputslot output_c_code outpucod_objputslot)


;;; output the putting of the routine in a closure
(defun outpucod_objputclosurout (opclor  declbuf implbuf :long depth)
  (assert_msg "check opclor" (is_a opclor class_objputclosurout) opclor)
  (let ( (oloc (unsafe_get_field :obi_loc opclor))
	 (oclos (unsafe_get_field :opclor_clos opclor))
	 (orout (unsafe_get_field :opclor_rout opclor)) 
	 (:long cnt 0)
	 )
    (code_chunk 
     getcntchk
     #{ /* $GETCNTCHK in outpucod_objputclosurout */ {
     static long $GETCNTCHK#_cnt;
     $GETCNTCHK#_cnt++;
     $CNT = $GETCNTCHK#_cnt;
     } }#)
    (output_location oloc implbuf depth "putclosurout")
    (add2sbuf_strconst implbuf "/*putclosurout#")    
    (add2sbuf_longdec implbuf cnt)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putclosrout#")
    (add2sbuf_longdec implbuf cnt)
    (add2sbuf_strconst implbuf " checkclo\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")) == MELTOBMAG_CLOSURE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putclosrout#")
    (add2sbuf_longdec implbuf cnt)
    (add2sbuf_strconst implbuf " checkrout\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")) == MELTOBMAG_ROUTINE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltclosure_ptr_t)")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->rout = (meltroutine_ptr_t) (")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objputclosurout output_c_code outpucod_objputclosurout)

;;; output the putting of a closed value
(defun outpucod_objputclosedv (opclov declbuf implbuf :long depth)
  (assert_msg "check opclov" (is_a opclov class_objputclosedv) opclov)
  (let ( (oloc (unsafe_get_field :obi_loc opclov))
	 (oclos (unsafe_get_field :opclov_clos opclov))
	 (ooff (unsafe_get_field :opclov_off opclov))
	 (ocval (unsafe_get_field :opclov_cval opclov)) )
    (output_location oloc implbuf depth "putclosedv")
    (add2sbuf_strconst implbuf "/*putclosv*/")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putclosv checkclo\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")) == MELTOBMAG_CLOSURE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putclosv checkoff\", ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf ">= 0 && ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "< melt_closure_size((melt_ptr_t) (")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")));")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltclosure_ptr_t)")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->tabval[")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = (melt_ptr_t)(")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objputclosedv output_c_code outpucod_objputclosedv)


;;; output the putting of a nonull closed value
(defun outpucod_objputclosednotnullv (opclov declbuf implbuf :long depth)
  (assert_msg "check opclov" (is_a opclov class_objputclosednotnullv) opclov)
  (let ( (oloc (unsafe_get_field :obi_loc opclov))
	 (oclos (unsafe_get_field :opclov_clos opclov))
	 (ooff (unsafe_get_field :opclov_off opclov))
	 (ocval (unsafe_get_field :opclov_cval opclov)) )
    (output_location oloc implbuf depth "putclosednotnullv")
    (add2sbuf_strconst implbuf "/*putclosvnotnull*/")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putclosvnotnull checkclo\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")) == MELTOBMAG_CLOSURE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putclosvnotnull checknotnullval\", NULL != ")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putclosvnotnull checkoff\", ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf ">= 0 && ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "< melt_closure_size((melt_ptr_t) (")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")));")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltclosure_ptr_t)")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->tabval[")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = (melt_ptr_t)(")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objputclosednotnullv output_c_code outpucod_objputclosednotnullv)


;; output the putting of a constant value inside a routine
(defun outpucod_objputroutconst (oprconst declbuf implbuf :long depth)
  (assert_msg "check oprconst" (is_a oprconst class_objputroutconst) oprconst)
  (let ( (oloc (unsafe_get_field :obi_loc oprconst))
	 (orout (unsafe_get_field :oprconst_rout oprconst))
	 (oroutnam (if (is_a orout class_objinitroutine) (unsafe_get_field :oie_cname orout)))
	 (ooff (unsafe_get_field :oprconst_off oprconst))
	 (ocval (unsafe_get_field :oprconst_cval oprconst)) )
    (output_location oloc implbuf depth "putroutconst")
    (add2sbuf_strconst implbuf "/*putroutconst*/")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "if (MELT_HAS_INITIAL_ENVIRONMENT) melt_assertmsg(\"putroutconst checkrout\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")) == MELTOBMAG_ROUTINE);")
    (add2sbuf_indentnl implbuf depth)
    ;;
    (add2sbuf_strconst implbuf "if (MELT_HAS_INITIAL_ENVIRONMENT) melt_checkmsg(\"putroutconst constnull.")
    (if (is_string oroutnam) (add2sbuf_string implbuf oroutnam))
    (add2sbuf_strconst implbuf "#")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "\", NULL != (")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf "));")
    (add2sbuf_indentnl implbuf depth)
    ;;
    (add2sbuf_strconst implbuf "((meltroutine_ptr_t)")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->tabval[")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = (melt_ptr_t)(")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objputroutconst output_c_code outpucod_objputroutconst)

;; output the putting of a nonnull constant value inside a routine
(defun outpucod_objputroutconstnotnull (oprconst declbuf implbuf :long depth)
  (assert_msg "check oprconst" (is_a oprconst class_objputroutconstnotnull) oprconst)
  (let ( (oloc (unsafe_get_field :obi_loc oprconst))
	 (orout (unsafe_get_field :oprconst_rout oprconst))
	 (ooff (unsafe_get_field :oprconst_off oprconst))
	 (ocval (unsafe_get_field :oprconst_cval oprconst)) )
    (assert_msg "check notnull ocval" (notnull ocval))
    (output_location oloc implbuf depth "putroutconstnotnull")
    (add2sbuf_strconst implbuf "/*putroutconstnotnull*/")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putroutconstnotnull checkrout\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")) == MELTOBMAG_ROUTINE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "melt_assertmsg(\"putroutconstnotnull notnullconst\", NULL != ")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((meltroutine_ptr_t)")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->tabval[")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = (melt_ptr_t)(")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    )
  )
(install_method class_objputroutconstnotnull output_c_code outpucod_objputroutconstnotnull)

;; output the putting of a constant value inside a hook
(defun outpucod_objputhookconst (ophconst declbuf implbuf :long depth)
  (debug "outpucod_objputhookconst ophconst=" ophconst)
  (assert_msg "check ophconst" (is_a ophconst class_objputhookconst) ophconst)
  (let ( (oloc (get_field :obi_loc ophconst))
	 (ohook (get_field :ophconst_hook ophconst))
	 (ohoff (get_field :ophconst_off ophconst))
	 (oval (get_field :ophconst_cval ophconst))
	 (nhook (get_field :oie_data ohook))
	 (hookname (get_field :ndata_name nhook))
	 )
    (debug "outpucod_objputhookconst ohook=" ohook "\n.. ohoff=" ohoff "\n.. oval=" oval "\n.. hookname=" hookname)
    (output_location oloc implbuf depth "puthookconst")
    (add2out implbuf ##{/*put inside hook $HOOKNAME */}#)
    (add2sbuf_indentnl implbuf depth)
    (add2out implbuf "melt_assertmsg(\"puthookconst checkhook " hookname "\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code ohook declbuf implbuf depth)
    (add2out implbuf ")) == MELTOBMAG_HOOK);")
    (add2sbuf_indentnl implbuf depth)
    (add2out implbuf 
	     "melt_assertmsg(\"puthookconst checkhook " hookname "\",")
    (add2sbuf_indentnl implbuf (+i 10 depth))
    (add2out implbuf "(")
    (output_c_code ohoff declbuf implbuf depth)
    (add2out implbuf ") >= 0")
    (add2sbuf_indentnl implbuf (+i 12 depth))
    (add2out implbuf "&& (")
    (output_c_code ohoff declbuf implbuf depth)
    (add2out implbuf ") < melt_hook_size ((melt_ptr_t)")
    (output_c_code ohook declbuf implbuf depth)
    (add2out implbuf "));")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((melthook_ptr_t)")
    (output_c_code ohook declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->tabval[")
    (output_c_code ohoff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = (melt_ptr_t)(")
    (output_c_code oval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objputhookconst output_c_code outpucod_objputhookconst)


;; output the putting of a constant data inside a hook
(defun outpucod_objputhookdata (ophd declbuf implbuf :long depth)
  (debug "outpucod_objputhookdata ophd=" ophd)
  (assert_msg "check ophconst" (is_a ophd class_objputhookdata) ophd)
  (let ( (oloc (get_field :obi_loc ophd))
	 (ohook (get_field :ophkdata_hook ophd))
	 (odata (get_field :ophkdata_data ophd))
	 (nhook (get_field :oie_data ohook))
	 (hookname (get_field :ndata_name nhook))
	 )
    (debug "outpucod_objputhookdata ophd=" ophd "\n.. ohook=" ohook "\n.. odata=" odata "\n nhook=" nhook)
    (assert_msg "check ohook" (is_a ohook class_objinithook) ohook)
    (output_location oloc implbuf depth "puthookdata")
    (add2out implbuf ##{/*put data in hook $HOOKNAME */}#)
    (add2sbuf_indentnl implbuf depth)
    (add2out implbuf "melt_assertmsg(\"puthookdata checkhook " hookname "\", melt_magic_discr((melt_ptr_t)(")
    (output_c_code ohook declbuf implbuf depth)
    (add2out implbuf ")) == MELTOBMAG_HOOK);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "((melthook_ptr_t)")
    (output_c_code ohook declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->hookdata = (melt_ptr_t)(")
    (output_c_code odata declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objputhookdata output_c_code outpucod_objputhookdata)


;;; output the put of an extra returned result
(defun outpucod_objputxtraresult (oputx declbuf implbuf :long depth)
  (assert_msg "check oputx" (is_a oputx class_objputxtraresult) oputx)
  (let (  (oloc (unsafe_get_field :obi_loc oputx))
	  (orank (unsafe_get_field :obxres_rank oputx))
	  (ovloc (unsafe_get_field :obxres_obloc oputx))
	  (octyp (get_ctype ovloc ()))
	  )
    (output_location oloc implbuf depth "putxtraresult")
    (assert_msg "check octyp" (is_a octyp class_ctype) octyp)
    (assert_msg "check orank" (is_integerbox orank) orank)
    (add2sbuf_strconst implbuf "if (!meltxrestab_ || !meltxresdescr_) goto meltlabend_rout;")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "if (meltxresdescr_[")
    (add2sbuf_longdec implbuf (get_int orank))
    (add2sbuf_strconst implbuf "] != ")
    (add2sbuf_string implbuf (unsafe_get_field :ctype_parchar octyp))
    (add2sbuf_strconst implbuf ") goto meltlabend_rout;")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "if (meltxrestab_[")
    (add2sbuf_longdec implbuf (get_int orank))
    (add2sbuf_strconst implbuf "].")
    (unless (is_string (get_field :ctype_resfield octyp))
      (debug "outpucod_objputxtraresult bad octyp" octyp " oputx=" oputx)
      (error_strv oloc "impossible secondary result type" (get_field :named_name octyp))
      )
    (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield octyp))
    (add2sbuf_strconst implbuf ") *(meltxrestab_[")
    (add2sbuf_longdec implbuf (get_int orank))
    (add2sbuf_strconst implbuf "].")
    (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield octyp))
    (add2sbuf_strconst implbuf ") = (")
    (if (== octyp ctype_value) (add2sbuf_strconst implbuf "melt_ptr_t) ("))
    (output_c_code ovloc declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    (assert_msg "check limited implbuf" 
		(<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
    ))
(install_method class_objputxtraresult output_c_code  outpucod_objputxtraresult)


;;; output an expression
(defun outpucod_objexpv (oexp declbuf implbuf :long depth)
  (assert_msg "check oexp" (is_a oexp class_objexpv))
  (let ( (cont (unsafe_get_field :obx_cont oexp)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "check cont" (is_multiple cont) cont)
    (foreach_in_multiple
     (cont)
     (comp :long ix)
     (output_c_code comp declbuf implbuf (get_int boxdepthp1))
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )))
(install_method class_objexpv output_c_code outpucod_objexpv)

;;; output a located expression
(defun outpucod_objlocatedexpv (oexp declbuf implbuf :long depth)
  (debug "outpucod_objlocatedexpv oexp=" oexp)
  (assert_msg "check oexp" (is_a oexp class_objlocatedexpv) oexp)
  (let ( (cont (unsafe_get_field :obx_cont oexp)) 
	 (oloc (unsafe_get_field :obcx_loc oexp))
	 (:long depthp1 (+i depth 1))
	 (otyp (unsafe_get_field :obv_type oexp))
	 )
    ;; the cont may be null
    (assert_msg "check cont" (is_multiple_or_null cont) cont)
    (if (== otyp ctype_void)
	(progn
	  (add2sbuf_indentnl implbuf depth)
	  (add2sbuf_strconst implbuf "{")
	  (add2sbuf_indentnl implbuf depth)
	  (output_location oloc implbuf depth "locexp")
	  )      
      (if oloc
	  (output_raw_location oloc implbuf depth "expr")
	)
      )
    ;;
    (debug "outpucod_objlocatedexpv cont=" cont)
    (foreach_in_multiple
     (cont)
     (comp :long ix)
     (output_c_code comp declbuf implbuf depthp1)
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    (when (== otyp ctype_void)
      (add2sbuf_strconst implbuf ";}")
      (add2sbuf_indentnl implbuf depth))
    )
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method class_objlocatedexpv output_c_code outpucod_objlocatedexpv)


;;; output a verbatim string
(defun outpucod_verbatimstring (vstr declbuf implbuf :long depth)
  (assert_msg "check vstr" (== (discrim vstr) discr_verbatim_string) vstr)
  (add2sbuf_string implbuf vstr)
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) vstr)
  )
(install_method discr_verbatim_string output_c_code outpucod_verbatimstring)



;; output a string (cstring constant)
(defun outpucod_string (vstr declbuf implbuf :long depth)
  (assert_msg "check vstr" (== (discrim vstr) discr_string) vstr) 
  (add2sbuf_strconst implbuf " \"")
  (add2sbuf_cencstring implbuf vstr)
  (add2sbuf_strconst implbuf "\"")
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method discr_string output_c_code outpucod_string)



;;; output an integer
(defun outpucod_integer (vint declbuf implbuf :long depth)
  (assert_msg "check vint" (is_integerbox vint) vint)
  (add2sbuf_longdec implbuf (get_int vint))
  )
(install_method discr_integer output_c_code outpucod_integer)

;;; output a finalreturn
(defun outpucod_finalreturn (fret declbuf implbuf :long depth)
  (assert_msg "check fret" (is_a fret class_objfinalreturn) fret)
  (output_location (unsafe_get_field :obi_loc fret) implbuf depth "finalreturn")
  (add2sbuf_strconst implbuf ";")
  (add2sbuf_indentnl implbuf depth)
  (add2sbuf_strconst implbuf "/*finalret*/ goto meltlabend_rout ")
  (assert_msg "check limited implbuf" 
	      (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
  )
(install_method class_objfinalreturn output_c_code outpucod_finalreturn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun sorted_named_dict_tuple (dic)
  (let ( (:long dicnt (mapstring_count dic))
	 (entlist (make_list discr_list)) 
	 )
    (foreach_in_mapstring
     (dic)
     (nam ent)
     (assert_msg "check ent named" (is_a ent class_named) ent)
     (list_append entlist ent))
    (let ( (rawtup (list_to_multiple entlist))
	   )
      (multiple_sort rawtup compare_named_alpha discr_multiple)
      )
    ))


(defun output_exported_offsets (modctx declbuf implbuf)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (let ( 
	(rawdictfields (unsafe_get_field :mocx_expfieldict modctx))
	(sortedfields (sorted_named_dict_tuple rawdictfields))
	(rawdictclasses (unsafe_get_field :mocx_expclassdict modctx))
	(sortedclasses (sorted_named_dict_tuple rawdictclasses))
	)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "/* exported ")
    (add2sbuf_longdec implbuf (mapstring_count rawdictfields))
    (add2sbuf_strconst implbuf " field offsets */")
    (foreach_in_multiple 
     (sortedfields)
     (fld :long ix)
     (assert_msg "check fld" (is_a fld class_field) fld)
     (add2sbuf_indentnl implbuf 0)
     (add2sbuf_strconst implbuf "MELT_EXTERN const int meltfieldoff__")
     (add2sbuf_cident implbuf (unsafe_get_field :named_name fld))
     (add2sbuf_strconst implbuf ";")
     (add2sbuf_indentnl implbuf 0)
     (add2sbuf_strconst implbuf "const int meltfieldoff__")
     (add2sbuf_cident implbuf (unsafe_get_field :named_name fld))
     (add2sbuf_strconst implbuf " = ")
     (add2sbuf_longdec implbuf (get_int fld))
     (add2sbuf_strconst implbuf ";")
     (add2sbuf_strconst implbuf " /* in ")
     (add2sbuf_string implbuf (get_field :named_name (get_field :fld_ownclass fld)))
     (add2sbuf_strconst implbuf " */")
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "/* exported ")
    (add2sbuf_longdec implbuf (mapstring_count rawdictclasses))
    (add2sbuf_strconst implbuf " class lengths */")
    (foreach_in_multiple
     (sortedclasses)
     (cla :long ix)
     (assert_msg "check cla" (is_a cla class_class) cla)
     (add2sbuf_indentnl implbuf 0)
     (add2sbuf_strconst implbuf "MELT_EXTERN const int meltclasslen__")
     (add2sbuf_cident implbuf (unsafe_get_field :named_name cla))
     (add2sbuf_strconst implbuf ";")
     (add2sbuf_indentnl implbuf 0)
     (add2sbuf_strconst implbuf "const int meltclasslen__")
     (add2sbuf_cident implbuf (unsafe_get_field :named_name cla))
     (add2sbuf_strconst implbuf " = ")	
     (add2sbuf_longdec implbuf 
		       (multiple_length (unsafe_get_field :class_fields cla)))
     (add2sbuf_strconst implbuf ";")
     (assert_msg "check limited implbuf" 
		 (<i (strbuf_usedlength implbuf) (get_int !buffer_limit_cont)) implbuf)
     )
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    ))


;;; the internal class for secondary generated C++ files
(defclass class_secondary_cc_file
  :super class_root
  :fields (secfil_modnam 		;the module name
	   secfil_path			;the file path
	   secfil_declbuf		;the declaration buffer
	   secfil_implbuf		;the implementation buffer
	   ))

;; internal primitive to generate a C++ name
(defprimitive generated_cc_filename (discr base dir :long num) :value
  #{meltgc_new_string_generated_cc_filename /*  generated_cc_filename */
     ((meltobject_ptr_t) ($DISCR),
      melt_string_str((melt_ptr_t) ($BASE)), melt_string_str((melt_ptr_t) ($DIR)), 
      ($NUM))}#)


;;; retrieve or create the nth secondary file in a module
(defun nth_secundary_file (modctx modnamstr declbuf :long ix)
    (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
    (assert_msg "check modnamstr" (is_string modnamstr) modnamstr)
    (assert_msg "check declbuf" (is_strbuf declbuf) declbuf)
    (let ( (mofiles (get_field :mocx_filetuple modctx))
	   (:long nbfiles (multiple_length mofiles))
	   (nthfile (multiple_nth mofiles ix))
	   )
      (if nthfile (return nthfile))
      (if (<=i ix 0) (return))
      (if (>=i ix nbfiles) (return))
      (compile_warning "nth_secundary_file incomplete")
      (let ( 	 
	    (path (generated_cc_filename discr_string
					modnamstr
					()
					ix))
	    (implbuf (make_strbuf discr_strbuf))
	    (newfile (instance class_secondary_cc_file
			       :secfil_modnam modnamstr
			       :secfil_path path 
			       :secfil_declbuf declbuf
			       :secfil_implbuf implbuf))
	    )
	(put_int newfile ix)
	(multiple_put_nth mofiles ix newfile)
	(return newfile)
	)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utility to output the melt descriptor FOO+meltdesc.c and melt
;; timestamp FOO+melttime.h [#include-d by FOO+meltdesc.c] from files
(defun output_melt_descriptor (modnamstr secfiles modctx)
  (debug "output_melt_descriptor modnamstr=" modnamstr " secfiles=" secfiles " modctx=" modctx)
  (assert_msg "check modnamstr" (is_string modnamstr) modnamstr)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (let ( 
	(:long nbsecfiles (multiple_length secfiles))
	(:long lastsecfileix 0)
	(debuf (make_strbuf discr_strbuf))
	(tibuf (make_strbuf discr_strbuf))
	(mkbuf (make_strbuf discr_strbuf))
	(pathlist (make_list discr_list))
	(md5list (make_list discr_list))
	(tupstatvar (list_to_multiple (get_field :mocx_varlist modctx) discr_multiple))
	(:long nbstatvar (multiple_length tupstatvar))
	(modbuildstr (make_string_nakedbasename discr_string modnamstr))
	(modcident (let ( (buf (make_strbuf discr_strbuf))
			  )
		     (add2out_cident buf modnamstr)
		     (strbuf2string discr_string buf)))
	(modbuildcident (let ( (buf (make_strbuf discr_strbuf))
			  )
		     (add2out_cident buf modbuildstr)
		     (strbuf2string discr_string buf)))
	(modprefstr (string4out discr_string "$(GCCMELTGEN_BUILD)" modbuildstr))
	(packagepclist (get_field :mocx_packagepclist modctx))
	(flavortuple
	 (if (is_a modctx class_running_extension_module_context)
	     (tuple '"runextend" '"optimized")
	   (tuple '"quicklybuilt" '"optimized" '"dynamic" '"debugnoline")))
	)
    (add2sbuf_strconst debuf "/** GENERATED MELT DESCRIPTOR FILE ")
    (add2sbuf_ccomstring debuf modnamstr)
    (add2sbuf_strconst debuf "+meltdesc.c \n** NEVER EDIT OR MOVE THIS, IT IS GENERATED & PARSED! **/")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "/* These identifiers are generated in warmelt-outobj.melt \n & handled in melt-runtime.c carefully. */") 
    (add2sbuf_indentnl debuf 0)
    (add2out mkbuf "## GENERATED MELT MAKE FRAGMENT FILE " modnamstr "+meltbuild.mk\n")
    (add2out mkbuf "## NEVER EDIT THIS FILE, generated from warmelt-outobj.melt by output_melt_descriptor\n")
    (add2out debuf ##{
	     #ifdef __cplusplus
	     /* explicitly declare as extern "C" our dlsym-ed symbols */
	     extern "C" const char melt_versionmeltstr[];
	     extern "C" const char melt_genversionstr[];
	     extern "C" const char melt_modulename[];
	     extern "C" const char melt_modulerealpath[];
	     extern "C" const char melt_prepromd5meltrun[];
	     extern "C" const char melt_primaryhexmd5[]	;
	     extern "C" const char* const melt_secondaryhexmd5tab[];
	     extern "C" const int melt_lastsecfileindex;
	     extern "C" const char melt_cumulated_hexmd5[];
	     extern "C" const int melt_module_nb_module_vars;

	     extern "C" {
	     #endif /*__cplusplus */
	     }#)
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "/* version of the GCC compiler & MELT runtime generating this */")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "const char melt_genversionstr[]=\"")
    (code_chunk 
     genversch
     #{ /* output_melt_descriptor $GENVERSCH + */
     meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, melt_gccversionstr) ;
     }#)
    (add2sbuf_strconst debuf "\"")
    (add2sbuf_indentnl debuf 0)
    (add2out debuf ##{
	     #ifdef __cplusplus
	     " (in C++)"
	     #else
	     " (in C)"
	     #endif
					;
	     }#)
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "const char melt_versionmeltstr[]=\"")
    (add2out mkbuf "## generated by MELT version ")
    (code_chunk 
     genvmeltch
     #{ /* output_melt_descriptor $GENVMELTCH + */
     meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, melt_version_str ()) ;
     meltgc_add_strbuf_cstr ((melt_ptr_t) $MKBUF, melt_version_str ()) ;
     }#)
    (add2sbuf_strconst debuf "\";")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_indentnl mkbuf 0)
    ;;
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "/* source name & real path of the module */")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "/*MELTMODULENAME ")
    (add2sbuf_ccomstring  debuf modnamstr)
    (add2sbuf_strconst debuf " */")
    (add2sbuf_indentnl debuf 0)
    (add2out mkbuf "#module name and identifier\n")
    (add2out mkbuf "MELTGEN_MODULENAME=" modnamstr)
    (add2sbuf_indentnl mkbuf 0)
    (add2out mkbuf "MELTGEN_MODULEIDENT=" modcident)
    (add2sbuf_indentnl mkbuf 0)
    (add2sbuf_strconst debuf "const char melt_modulename[]=\"")
    (code_chunk
     genmodnamstr
     #{ /* output_melt_descriptor $GENMODNAMSTR + */
     meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, lbasename (melt_string_str((melt_ptr_t) $MODNAMSTR))) ;
     }#
     )
    ;;
    (add2sbuf_strconst debuf "\";")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "const char melt_modulerealpath[]=\"")
    (code_chunk 
     genrpathch
     #{ /* output_melt_descriptor $GENRPATHCH + */ {
     char* lrp = lrealpath (melt_string_str ((melt_ptr_t) $MODNAMSTR)) ;
     if (!melt_flag_bootstrapping && !IS_ABSOLUTE_PATH(lrp)) {
       meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, getpwd()) ;
       meltgc_add_strbuf ((melt_ptr_t) $DEBUF, "/") ;
       meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, lrp) ;
     }
     else if (melt_flag_bootstrapping) {
       meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, melt_module_dir) ;
       meltgc_add_strbuf ((melt_ptr_t) $DEBUF, "/") ;
       meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, lbasename (lrp)) ;
     }
     else      
       meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, lrp) ;
     free (lrp)					       ;
     } /* end output_melt_descriptor $GENRPATHCH */}#)
    (add2sbuf_strconst debuf "\";")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "/* hash of preprocessed melt-run.h generating this */")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "const char melt_prepromd5meltrun[]=\"")
    (code_chunk 
     genversch
     #{ /* output_melt_descriptor $GENVERSCH */
     meltgc_add_strbuf_cstr ((melt_ptr_t) $DEBUF, MELT_RUN_HASHMD5) ;
     }#)
    (add2sbuf_strconst debuf "\";")
    (add2sbuf_indentnl debuf 0)
    ;;
    (add2sbuf_strconst debuf "/* hexmd5checksum of primary C++ file */")
    (add2sbuf_indentnl debuf 0)
    (add2sbuf_strconst debuf "const char melt_primaryhexmd5[]=\"")
    (let ( 
	  (primpath (string4out discr_string modnamstr ".cc")) 
	  (primmd5s (string_hex_md5sum_pathstrv primpath))
	  (mkrulebuf (make_strbuf discr_strbuf))
	  (secmd5buf (make_strbuf discr_strbuf))
	  (secpathbuf (make_strbuf discr_strbuf))
	  )
      (debug "output_melt_descriptor primpath=" primpath)
      (list_append pathlist primpath)
      (list_append md5list primmd5s)
      (add2sbuf_cencstring debuf primmd5s)
      (add2out mkbuf "#primary path and checksum\n")
      (add2out mkbuf "MELTGENMOD_PRIMPATH_" modcident "=" primpath)
      (add2sbuf_indentnl mkbuf 0)
      (add2out mkbuf "MELTGENMOD_MD5PRIM_" modcident "=" primmd5s)
      (add2sbuf_indentnl mkbuf 0)
      ;; emit pkg-config information in make fragment
      (let ( (packagepctup (list_to_multiple packagepclist discr_multiple))
	     (:long nbpackagepc (multiple_length packagepctup))
	     )
	(debug "output_melt_descriptor packagepctup=" packagepctup)
	(when nbpackagepc
	  (add2out mkbuf "# " nbpackagepc " packages for pkg-config utility\n")
	  (add2out mkbuf "MELTGENMOD_PACKAGELIST_PKGCONFIG_" modcident "=")
	  (foreach_in_multiple 
	   (packagepctup)
	   (curpack :long pkix)
	   (add2out mkbuf " " curpack))
	  (add2out mkbuf "\n# global name for these pkg-config packages:\n")
	  (add2out mkbuf "MELTGENMOD_PACKAGELIST=$(MELTGENMOD_PACKAGELIST_PKGCONFIG_" modcident ")\n")
	)
	(unless nbpackagepc
	  (add2out mkbuf "# no packages needed thru pkg-config\n"))
	)
      (add2out mkrulebuf "### generated dependencies for " modnamstr "\n\n")
      (add2out mkrulebuf "# dependency for primary of " modcident "\n")
      (foreach_in_multiple
       (flavortuple)
       (curflav :long flavix)
       (add2out mkrulebuf modprefstr "." primmd5s "." curflav ".meltpic.o: " primpath "\n")
       )
      (add2sbuf_strconst debuf "\";")
      (add2sbuf_indentnl debuf 0)
      ;;
      (add2sbuf_indentnl debuf 0) 
      (add2sbuf_strconst debuf "/* hexmd5checksum of secondary C++ files */")
      (add2sbuf_indentnl debuf 0)
      (add2sbuf_strconst debuf "const char* const melt_secondaryhexmd5tab[]={")
      ;;
      (debug "output_melt_descriptor secfiles=" secfiles)
      (foreach_in_multiple
       (secfiles)
       (curfil :long filix)
       (debug "output_melt_descriptor curfil=" curfil " filix=" filix)
       (add2sbuf_indentnl debuf 1)
       (if curfil
	   (progn
	     (assert_msg "output_melt_descriptor check curfil" 
			 (is_a curfil class_secondary_cc_file) curfil)
	     (setq lastsecfileix filix)
	     (let ( (secpath (get_field :secfil_path curfil)) 
		    (secmd5s (string_hex_md5sum_pathstrv secpath))
		    )
	       (list_append pathlist secpath)
	       (list_append md5list secmd5s)
	       (add2sbuf_strconst debuf "/*sechexmd5checksum ")
	       (add2sbuf_ccomstring debuf secpath)
	       (add2sbuf_strconst debuf " #")
	       (add2sbuf_longdec debuf (get_int curfil))
	       (add2sbuf_strconst debuf " */ \"")
	       (add2sbuf_cencstring debuf secmd5s)
	       (add2sbuf_strconst debuf "\",")
	       (add2out secpathbuf " " secpath)
	       (add2out secmd5buf " " secmd5s)
	       ;; make secondary dependencies
	       (add2out mkrulebuf "# dependencies for secondary " filix " of " modcident "\n")
	       (foreach_in_multiple
		(flavortuple)
		(curflav :long flavix)
		(add2out mkrulebuf modprefstr "+" 
			 (if (<i filix 10) "0" "") 
			 filix "." secmd5s "." curflav ".meltpic.o: " modnamstr "+" 
			 (if (<i filix 10) "0" "") 
			 filix ".cc" "\n")
		)
	       ))
	 (add2sbuf_strconst debuf "/*nosecfile*/ (const char*)0,")
	 ))				;end foreach secondary file
      (add2sbuf_indentnl debuf 1)
      (add2sbuf_strconst debuf "(const char*)0 };")
      (add2sbuf_indentnl debuf 0)
      ;;
      (add2sbuf_indentnl debuf 0)
      (add2sbuf_strconst debuf "/* last index of secondary files */")
      (add2sbuf_indentnl debuf 0)
      (add2sbuf_strconst debuf "const int melt_lastsecfileindex=")
      (add2sbuf_longdec  debuf lastsecfileix)
      (add2sbuf_strconst debuf ";")
      (add2sbuf_indentnl debuf 0)
      (add2out mkbuf "#secondary paths and checksums\n")
      (add2out mkbuf  "MELTGENMOD_SECONDARY_FILES_" modcident "=" (strbuf2string discr_string secpathbuf) "\n")
      (add2sbuf_indentnl mkbuf 0)
      (add2out mkbuf  "MELTGENMOD_SECONDARY_MD5SUMS_" modcident "=" (strbuf2string discr_string secmd5buf) "\n")
      (add2sbuf_indentnl mkbuf 0)
      ;;
      (let ( (cumpathmds (string_hex_md5sum_path_sequence
			  (list_to_multiple pathlist)))
	     (midstr (make_string_nakedbasename
		      discr_string modnamstr)) 
	     (modidnam (let ( (mout (make_strbuf discr_strbuf)) 			    
			      )
			 (add2out mout "meltmod_")
			 (add2sbuf_cident mout midstr)
			 (add2out mout "_mds__")
			 (add2sbuf_cident mout cumpathmds)
			 (strbuf2string discr_string mout))
		       )
	     )
	(assert_msg "check cumpathmds" (is_string cumpathmds) cumpathmds) 
	;;
	(add2out mkrulebuf "## dependency for descriptor object of " modnamstr "\n")
	(add2out mkrulebuf  modprefstr "."  cumpathmds ".descriptor.meltpic.o: " modnamstr "+meltdesc.c " 
		 modnamstr "+melttime.h\n")
	;;
	(add2out mkrulebuf "## dependency for modules " modnamstr "\n")
	(foreach_in_multiple
	 (flavortuple)
	 (curflav :long flavix)
	 (add2out mkrulebuf "\n#### dependencies for flavor " curflav " of module " modnamstr "\n\n")
	 ;; new flavored dependencies; the .meltmod- is before the md5sum 
	 (add2out mkrulebuf "\n\n## new dependency for flavor " curflav " of module " modnamstr "\n")
	 (add2out mkrulebuf modprefstr ".meltmod-" cumpathmds "." curflav ".so: \\\n"
		  "  " modprefstr "."  cumpathmds ".descriptor.meltpic.o "
		  )
	 (let ( (pathtup (list_to_multiple pathlist discr_multiple))
		(md5tup (list_to_multiple md5list discr_multiple))
		)
	   (assert_msg "check same length pathtup md5tup" 
		       (==i (multiple_length pathtup) (multiple_length md5tup)) pathtup md5tup)
	   (foreach_in_multiple
	    (pathtup)
	    (curpath :long ix)
	    (let ( (curmd5 (multiple_nth md5tup ix))
		   )
	      (debug "output_melt_descriptor curpath=" curpath " ix=" ix " curmd5=" curmd5)
	      (add2out mkrulebuf " \\\n   "  "$(GCCMELTGEN_BUILD)" (make_string_nakedbasename discr_string curpath) 
		       "." curmd5 "." curflav ".meltpic.o")
	      )
	    )
	   )
	 (add2out mkrulebuf "\n\n")
	 ) ;; end foreach flavortuple
	;;
	(add2out mkrulebuf "\n#end of generated dependencies for " modnamstr "\n\n")
	(add2out mkbuf mkrulebuf)
	(setq mkrulebuf ())
	(add2out mkbuf "## cumulated checksum and naked name\n")
	(add2out mkbuf "MELTGENMOD_CUMULATED_MD5SUM_" modcident "=" cumpathmds "\n")
	(add2out mkbuf "MELTGENMOD_NAKED_NAME_" modcident "=" midstr "\n")
	(add2sbuf_indentnl debuf 0) 
	(add2out 
	 debuf 
	 ##{/* cumulated checksum of primary & secondary files */
const char melt_cumulated_hexmd5[]="$CUMPATHMDS" ;

/* number of module variables */
const int melt_module_nb_module_vars= $NBSTATVAR;

/* include the timestamp file */
#define $MODIDNAM 1
#include "$MIDSTR+melttime.h"
	 }#
	 )
	;;
	;;
	(add2sbuf_strconst tibuf "/** GENERATED MELT TIMESTAMP FILE ")
	(add2sbuf_ccomstring tibuf modnamstr)
	(add2sbuf_strconst tibuf "+melttime.h \n** NEVER EDIT OR MOVE THIS, IT IS GENERATED & PARSED! **/")
	(add2sbuf_indentnl tibuf 0)
	(add2sbuf_strconst tibuf "/* These identifiers are generated in warmelt-outobj.melt \n & handled in melt-runtime.c carefully. */") 
	(add2sbuf_indentnl tibuf 0)
	(add2sbuf_indentnl tibuf 0) 
	(add2out tibuf ##{
/* This $MIDSTR+melttime.h is included from $MIDSTR+meltdesc.c only. */
#if $MODIDNAM
/* MELT generation timestamp for $MODNAMSTR */

#ifdef __cplusplus
/* these symbols are extern "C" since dlsym-ed */
extern "C" const char melt_gen_timestamp[] ;
extern "C" const long long melt_gen_timenum ;
extern "C" const char melt_build_timestamp[] ;
extern "C" {
#endif /*__cplusplus */

		 }#
		 )
	(add2sbuf_indentnl tibuf 0)
        (code_chunk 
         gentimch
         #{ /* output_melt_descriptor $GENTIMCH + */ {
         time_t now = 0 ;
         char nowbuf[64] ;
         time (&now) ;
         memset (nowbuf, 0, sizeof(nowbuf)) ;
         strftime (nowbuf, sizeof(nowbuf)-1, "%c %Z", localtime(&now)) ;
         if (melt_flag_bootstrapping)
           meltgc_add_strbuf ((melt_ptr_t) $TIBUF, "/*MELT BOOTSTRAP*/\n") ;
         meltgc_add_strbuf ((melt_ptr_t) $TIBUF, 
                            "const char melt_gen_timestamp[]=\"") ;
         meltgc_add_strbuf_cstr ((melt_ptr_t) $TIBUF, nowbuf) ;
         meltgc_add_strbuf ((melt_ptr_t) $TIBUF, "\";\n") ;
         /*  $GENTIMCH don't use time_t, it is not a predefined C type! */
         meltgc_strbuf_printf ((melt_ptr_t) $TIBUF, 
                               "const long long melt_gen_timenum=%lld;",
                               (long long) now) ;              
         } /* output_melt_descriptor $GENTIMCH - */}#)
	(add2sbuf_indentnl tibuf 0)
	(add2out tibuf ##{
		 const char melt_build_timestamp[]= __DATE__ "@" __TIME__
		 #ifdef __cplusplus
		 " (in C++)"
		 #else
		 " (in C)"
		 #endif /*__cplusplus*/
					;
		 }#)
	(add2sbuf_indentnl tibuf 0)
	(add2out tibuf ##{
		 #ifdef __cplusplus
		 }  /* end extern C timestamp */
		 #endif /*__cplusplus */

		 #else /* ! $MODIDNAM */
		 #error invalid timestamp file for $MODNAMSTR 
		 #endif /* $MODIDNAM */
		 }#)
	(add2sbuf_indentnl tibuf 0)
	;;
	(add2sbuf_indentnl debuf 0)
	(add2out debuf ##{
		 #ifdef __cplusplus
		 }	  /* end extern C descriptor */
		 #endif /*__cplusplus */
		 }#)
	(add2sbuf_indentnl debuf 0)
	(add2sbuf_strconst debuf "/* end of melt descriptor file */")
	(add2sbuf_indentnl debuf 0)
	(add2out mkbuf "\n## eof of generated " modnamstr "+meltbuild.mk\n")
	)
      (let (
	    (meltdescpath (string4out discr_string  modnamstr "+meltdesc.c"))
	    (melttimepath (string4out discr_string  modnamstr "+melttime.h"))
	    (meltmakepath (string4out discr_string  modnamstr "+meltbuild.mk"))
	    )
	(debug "output_melt_descriptor meltdescpath=" meltdescpath 
	       "\n* debuf=" debuf)
	(debug "output_melt_descriptor melttimepath=" melttimepath 
	       "\n* tibuf=" tibuf)
	(debug "output_melt_descriptor meltmakepath=" meltmakepath 
	       "\n* mkbuf=" mkbuf)
	(output_sbuf_no_overwrite_strval debuf meltdescpath)
	(output_sbuf_no_overwrite_strval tibuf melttimepath)
	(output_sbuf_no_overwrite_strval mkbuf meltmakepath)
	(debug "output_melt_descriptor final modctx=" modctx)
	)
      )
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
(defselector syntax_test_generator
  class_selector
  :doc #{Selector to emit C++ syntax for testing purposes of a generator
device.  Reciever is the representation -e.g. $CLASS_PRIMITIVE,
... $GENDEV is the generator device, $SBUF is the string buffer,
$MODCTX is the module context, and $IX is the index.}#
  :formals (recv gendev sbuf modctx :long ix)
)

(defun syntestgen_any (recv gendev sbuf modctx :long ix)
  (let ( (dis (discrim recv))
	 (disname (get_field :named_name dis))
	 (dloc (get_field :loca_location gendev))
	 )
    (debug "syntestgen_any recv=" recv "\n* dis=" dis
	   "\n* gendev=" gendev
	   "\n* sbuf=" sbuf
	   "\n* modctx=" modctx
	   "\n* ix=" ix)
    (error_strv dloc "unimplemented SYNTAX_TEST_GENERATOR method for " disname)
    (assert_msg "check gendev" (is_a gendev class_source_generator_device) gendev)
    (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
    (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
    (assert_msg "@$@unimplemented syntax_test_generator" () recv)
))
(install_method discr_any_receiver syntax_test_generator syntestgen_any)
		


(defun substitute_formals_for_syntest (sbuf replmap formals :cstring prefix)
  (debug "substitute_formals_for_syntest sbuf=" sbuf "\n replmap=" replmap "\n* formals=" formals "\n prefix=" prefix)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (assert_msg "check replmap" (is_mapobject replmap) replmap)
  (assert_msg "check formals" (is_multiple_or_null formals) formals)
  (foreach_in_multiple
   (formals)
   (curformal :long ix)
   (debug "substitute_formals_for_syntest curformal=" curformal " ix=" ix)
   (assert_msg "check curformal" (is_a curformal class_formal_binding) curformal)
   (let ( (fsymb (get_field :binder curformal))
	  (ftype (get_field :fbind_type curformal))
	  (gensy (let ( (nambuf (make_strbuf discr_strbuf))
			)
		   (add2out nambuf prefix ix "_")
		   (add2sbuf_cident nambuf (get_field :named_name fsymb))
		   (strbuf2string discr_verbatim_string nambuf))) 
	  )
     (mapobject_put replmap fsymb gensy)
     (debug "substitute_formals_for_syntest updated replmap=" replmap "\n with fsymb=" fsymb "\n with gensy=" gensy)
     (add2out sbuf (get_field :ctype_cname ftype) " " gensy " =0;")
     (add2sbuf_indentnl sbuf 1)
     ))
  )
  

(defun expand_tuple_for_syntest (sbuf replmap tup loc)
  (debug "expand_tuple_for_syntest sbuf=" sbuf "\n replmap=" replmap "\n tup=" tup)
  (foreach_in_multiple 
   (tup) 
   (curexpan :long pix)
   (debug "expand_tuple_for_syntest curexpan=" curexpan)
   (if (is_object curexpan)
       (let ( (curepl (mapobject_get replmap curexpan))
	      )
	 (debug "expand_tuple_for_syntest curepl=" curepl) 
	 (if curepl
	     (add2out sbuf curepl)
	   (let ( (curexpnam (get_field :named_name curexpan))
		  )
	     (debug "expand_tuple_for_syntest no curepl for curexpan=" curexpan " replmap=" replmap)
	     (warning_strv 
	      loc "unexpected symbol in expansion [syntax check]" curexpnam)
	     )))
     (add2out sbuf curexpan))
   ) ;;end foreach tup
  (debug "expand_tuple_for_syntest done sbuf=" sbuf)
  )

;;;;;;;;;;;;;;;;
(defun syntestgen_primitive (recv gendev sbuf modctx :long ix)
  (debug "syntestgen_primitive recv=" recv " gendev=" gendev)
  (assert_msg "check recv" (is_a recv class_primitive) recv)
  (assert_msg "check gendev" (is_a gendev class_source_generator_device) gendev)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (let ( (dloc (get_field :loca_location gendev))
	 (pridef (get_field :srcgen_defin gendev))
	 (prirep (get_field :srcgen_repr gendev))
	 (prinam (get_field :named_name recv))
	 (priformals (get_field :prim_formals recv))
	 (exploc (or (get_field :sprim_exploc pridef) dloc))
	 (pritype (get_field :prim_type recv))
	 (primexpan (get_field :prim_expansion recv))
	 (replmap (make_mapobject discr_map_objects 
				  (+i 5 (*i 2 (multiple_length priformals)))))
	 )
    (assert_msg "check pridef" (is_a pridef class_source_defprimitive) pridef)
    (assert_msg "check prirep" (== prirep recv) prirep recv)
    (add2out sbuf "/*primitive-syntax ")
    (add2sbuf_ccomstring sbuf prinam)
    (add2out sbuf "*/ {")
    (add2sbuf_indentnl sbuf 1)
    (substitute_formals_for_syntest sbuf replmap priformals "meltprimf_")
    ;;
    (if (!= pritype ctype_void)
	(let  ( (pritynam (get_field :ctype_cname pritype))
		)
	  (add2out sbuf ##{$PRITYNAM primres_$IX = }#)
	  ))
;;;
    (if exploc (output_raw_location exploc sbuf 0 "primitive-syntax"))
    (if (!= pritype ctype_void) 
	(add2out sbuf "    "))
    (debug "syntestgen_primitive primexpan=" primexpan)
    (expand_tuple_for_syntest sbuf replmap primexpan exploc)
    ;;
    (if (!= pritype ctype_void)
	(let  ( (pritynam (get_field :ctype_cname pritype))
		)
	  (add2out sbuf ";")
	  (add2sbuf_indentnl sbuf 2)
	  (add2out sbuf ##{if (primres_$IX) return}#
		   )
	  ))
    (add2out sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    (add2out sbuf "} /*end primitive-syntax ")
    (add2sbuf_ccomstring sbuf prinam)
    (add2out sbuf "*/")
    (add2sbuf_indentnl sbuf 0)
    ))

(install_method class_primitive syntax_test_generator syntestgen_primitive)


;;;


;;;;;;;;;;;;;;;;
(defun syntestgen_citerator (recv gendev sbuf modctx :long ix)
  (debug "syntestgen_citerator recv=" recv " gendev=" gendev)
  (assert_msg "check recv" (is_a recv class_citerator) recv)
  (assert_msg "check gendev" (is_a gendev class_source_generator_device) gendev)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (let ( (dloc (get_field :loca_location gendev))
	 (citdef (get_field :srcgen_defin gendev))
	 (citrep (get_field :srcgen_repr gendev))
	 (citnam (get_field :named_name recv))
	 (citstaformals (get_field :citer_start_formals recv))
	 (citstate (get_field :citer_state recv))
	 (citbodformals (get_field :citer_body_formals recv))
	 (citexpbefo (get_field :citer_expbefore recv))
	 (citexpafte (get_field :citer_expafter recv))
	 (replmap (make_mapobject discr_map_objects (*i 2 (+i 3 (multiple_length citstaformals)))))
	 (repstatnam (let ( (nbuf (make_strbuf discr_strbuf)) 
			    )
		       (add2out nbuf "meltcitstate_" ix "_")
		       (add2sbuf_cident nbuf (get_field :named_name citstate))
		       (strbuf2string discr_verbatim_string nbuf)))
	 (befloc (or (get_field :sciterdef_beforeloc citdef) dloc))
	 (aftloc (or (get_field :sciterdef_afterloc citdef) dloc))
	 )
    (assert_msg "check citdef" (is_a citdef class_source_defciterator) citdef)
    (assert_msg "check citrep" (== citrep recv) citrep recv)
    (add2out sbuf "/*citerator-syntax ")
    (add2sbuf_ccomstring sbuf citnam)
    (add2out sbuf "*/ {")
    (add2sbuf_indentnl sbuf 1)
    (if dloc (output_raw_location dloc sbuf 0 "citerator-syntax"))
    (mapobject_put replmap citstate repstatnam)
    (debug "syntestgen_citerator replmap=" replmap)
    (substitute_formals_for_syntest sbuf replmap citstaformals "meltcitstart_")
    (substitute_formals_for_syntest sbuf replmap citbodformals "meltcitbody_")
    (if befloc (output_raw_location befloc sbuf 0 "citerator-syntax-before"))
    (expand_tuple_for_syntest sbuf replmap citexpbefo befloc)
    (debug "syntestgen_citerator after start formals replmap=" replmap)
    (add2sbuf_indentnl sbuf 0)
    (add2out sbuf "/**fictive body of citerator " repstatnam " **/")
    (add2sbuf_indentnl sbuf 0)
    (debug "syntestgen_citerator citbodformals=" citbodformals)
    (foreach_in_multiple
     (citbodformals)
     (curbodformbind :long bodformix)
     (debug "syntestgen_citerator curbodformbind=" curbodformbind)
     (let (
	   (curbodformal (get_field :binder curbodformbind))
	   (nambodformal (mapobject_get replmap curbodformal))
	    )
       (debug "syntestgen_citerator nambodformal=" nambodformal)
       (assert_msg "check nambodformal" nambodformal)
       (add2out sbuf "if (" NAMBODFORMAL ") return;")
       (add2sbuf_indentnl sbuf 0)
     ))
    (if aftloc (output_raw_location aftloc sbuf 0 "citerator-syntax-after"))
    (expand_tuple_for_syntest sbuf replmap citexpafte aftloc)
    (add2sbuf_indentnl sbuf 0)
    (add2out sbuf "} /*end citerator-syntax ")
    (add2sbuf_ccomstring sbuf citnam)
    (add2out sbuf "*/")
    (add2sbuf_indentnl sbuf 0)
    ))

(install_method class_citerator syntax_test_generator syntestgen_citerator)


;;;;;;;;;;;;;;;;
(defun syntestgen_cmatcher (recv gendev sbuf modctx :long ix)
  (debug "syntestgen_cmatcher recv=" recv " gendev=" gendev)
  (assert_msg "check recv" (is_a recv class_cmatcher) recv)
  (assert_msg "check gendev" (is_a gendev class_source_generator_device) gendev)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (let ( (dloc (get_field :loca_location gendev))
	 (cmatdef (get_field :srcgen_defin gendev))
	 (cmatrep (get_field :srcgen_repr gendev))
	 (cmatnam (get_field :named_name recv))
	 (cmatins (get_field :amatch_in recv))
	 (cmatbind (get_field :amatch_matchbind recv))
	 (cmatout (get_field :amatch_out recv))
	 (cmatstate (get_field :cmatch_state recv))
	 (cmattest (get_field :cmatch_exptest recv))
	 (cmatfill (get_field :cmatch_expfill recv))
	 (cmatoper (get_field :cmatch_expoper recv))
	 (testloc (or (get_field :scmatdef_testloc cmatdef) dloc))
	 (fillloc (or (get_field :scmatdef_fillloc cmatdef) dloc))
	 (operloc (or (get_field :scmatdef_operloc cmatdef) dloc))
	 (replmap (make_mapobject discr_map_objects 
				  (+i 5 (*i 2 (+i (multiple_length cmatins) 
						  (multiple_length cmatout))))))
	 (repstatnam (let ( (nbuf (make_strbuf discr_strbuf)) 
			    )
		       (add2out nbuf "cmatstate_" ix "_")
		       (add2sbuf_cident nbuf (get_field :named_name cmatstate))
		       (strbuf2string discr_verbatim_string nbuf)))
	 )
    (add2out sbuf "/*cmatcher-syntax ")
    (add2sbuf_ccomstring sbuf cmatnam)
    (add2out sbuf "**/ {")
    (add2sbuf_indentnl sbuf 1)
    (mapobject_put replmap cmatstate repstatnam)
    (substitute_formals_for_syntest sbuf replmap (tuple cmatbind) "meltcmatched_")
    (substitute_formals_for_syntest sbuf replmap cmatins "meltcmatinput_")
    (substitute_formals_for_syntest sbuf replmap cmatout "meltcmatoutput_")
    (add2sbuf_indentnl sbuf 1)
    (if testloc (output_raw_location testloc sbuf 0 "cmatcher-syntax-test"))
    (add2out sbuf "if (/*cmatcher-test " cmatnam ":*/")
    (expand_tuple_for_syntest sbuf replmap cmattest testloc)
    (add2out sbuf "/*cmatcher-endtest*/) {")
    (add2sbuf_indentnl sbuf 2)
    (if fillloc (output_raw_location fillloc sbuf 0 "cmatcher-syntax-fill"))
    (add2out sbuf "/*cmatcher-fill " cmatnam ":*/")
    (add2sbuf_indentnl sbuf 2)
    (expand_tuple_for_syntest sbuf replmap cmatfill fillloc)
    (add2out sbuf ";")
    (add2sbuf_indentnl sbuf 2)
    (foreach_in_multiple
     (cmatout)
     (curmatoutbind :long outix)
     (debug "syntestgen_cmatcher curmatoutbind=" curmatoutbind)
     (let (
	   (curoutformal (get_field :binder curmatoutbind))
	   (namoutformal (mapobject_get replmap curoutformal))
	   )
       (debug "syntestgen_cmatcher curmatoutbind=" curmatoutbind
	      " namoutformal=" namoutformal)
       (assert_msg "check namoutformal " namoutformal)
       (add2out sbuf "if (" NAMOUTFORMAL ") return;")
       (add2sbuf_indentnl sbuf 2)
       )
     )
    (add2out sbuf "} /*cmatcher-endfill " cmatnam " */ else return;")
    (add2sbuf_indentnl sbuf 1)
    (if cmatoper
	(progn
	  (if operloc (output_raw_location operloc sbuf 0 "cmatcher-syntax-oper"))
	  (expand_tuple_for_syntest sbuf replmap 
				    (tuple '"/*cmatcher-oper*/" (get_field :binder cmatbind)  '" = ") 
				    operloc)
	  (expand_tuple_for_syntest sbuf replmap cmatoper operloc)
	  (add2out sbuf ";")
	  (add2sbuf_indentnl sbuf 2)
	  ))
    (add2out sbuf "} /*end cmatcher-syntax ")
    (add2sbuf_ccomstring sbuf cmatnam)
    (add2out sbuf "**/")
    (add2sbuf_indentnl sbuf 0)
    ))

(install_method class_cmatcher syntax_test_generator syntestgen_cmatcher)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun emit_syntax_testing_routine (gendevtup modctx sbuf)
  (debug "emit_syntax_testing_routine gendevtup=" gendevtup 
	 " sbuf=" sbuf)
  (assert_msg "check gendevtup" (is_multiple gendevtup) gendevtup)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (let ( 
	(:long nbgendev (multiple_length gendevtup))
	(modnam (get_field :mocx_modulename modctx))
	(syntestname 
	 (let ( (nabuf (make_strbuf discr_strbuf)) )
	   (add2out nabuf "melt_syntax_tester_")
	   (add2sbuf_cident nabuf modnam)
	   (strbuf2string discr_verbatim_string nabuf)))
	)
    (debug "emit_syntax_testing_routine syntestname=" syntestname)
    (assert_msg "check syntestname" (is_string syntestname) syntestname)
    (add2sbuf_indentnl sbuf 0)
    (add2sbuf_indentnl sbuf 0)
    (add2sbuf_indentnl sbuf 0)
    (add2out sbuf "/****** emitted syntax checking for C generating devices *****/")
    (add2sbuf_indentnl sbuf 0)
    (add2out sbuf "#if MELT_HAVE_DEBUG")
    (add2sbuf_indentnl sbuf 0)
    (add2out 
     sbuf ##{
/* generated syntax checking routine for $NBGENDEV C generating devices */
MELT_EXTERN void MELT_MODULE_VISIBILITY $SYNTESTNAME (void);

void
$SYNTESTNAME (void) {
if (1) return;
#define meltcallcount -1L /* in $SYNTESTNAME */
}#)
    (foreach_in_multiple
     (gendevtup)
     (curgendev :long gix)
     (add2sbuf_indentnl sbuf 1)
     (debug "emit_syntax_testing_routine curgendev=" curgendev "\n gix#" gix)
     (assert_msg "check curgendev" (is_a curgendev class_source_generator_device) curgendev)
     (let ( (:long sucgix (+i gix 1))
	    (repr (get_field :srcgen_repr curgendev))
	    )
       (add2sbuf_indentnl sbuf 0)
       (add2out sbuf ##{/* generating device #$SUCGIX */}#)
       (add2sbuf_indentnl sbuf 0)
       (debug "emit_syntax_testing_routine before syntax_test_generator repr=" repr)
       (syntax_test_generator repr curgendev sbuf modctx gix)
       (debug "emit_syntax_testing_routine after syntax_test_generator repr=" repr "\n gix#" gix "\n")
       )
     (add2sbuf_indentnl sbuf 0)
     ) ;; end foreach gendevtup
     (add2sbuf_indentnl sbuf 0)
     (add2out 
      sbuf 
      ##{} /* end generated $SYNTESTNAME */}#)
     (add2sbuf_indentnl sbuf 0)
     (add2out sbuf "#endif /*MELT_HAVE_DEBUG syntaxcheck*/")
     (add2sbuf_indentnl sbuf 0)
     (add2sbuf_indentnl sbuf 0)
     ))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; internal utility function to normalize a macroexpanded list
;; return the normalized list & the start clock
;; no bindings are returned because we have letwrapped them
;; the initial function is not modified
(defun give_normalized_macroexpanded_list (xlist modnamstr modctx ncx inienv)
  (debug "give_normalized_macroexpanded_list start xlist= " xlist
	 "\n* modnamstr=" modnamstr 
	 "\n* modctx=" debug_less modctx
	 "\n* ncx=" debug_less ncx
	 "\n* inienv=" debug_less inienv)
  (shortbacktrace_dbg "give_normalized_macroexpanded_list" 12)
  (assert_msg "check xlist" (is_list xlist) xlist)
  (assert_msg "check modnamstr" (is_string modnamstr) modnamstr)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (assert_msg "check ncx" (is_a ncx class_normalization_context) ncx)
  (assert_msg "check inienv" (is_a inienv class_environment) inienv)
  (let (
	(:long startclock 0)
	(normlist (list))
	(firstx (pair_head (list_first xlist)))
	(firstloc (if (is_a firstx class_source) (get_field :loca_location firstx)))
	(errorhdlr (get_field :mocx_errorhandler modctx))
	(modinienv (get_field :mocx_initialenv modctx))
	(iniproc (get_field :nctx_initproc ncx))
	;; make an update_current_module_environment at the very beginning
	(ucmeb1 (instance class_source_update_current_module_environment_reference
			  :loca_location firstloc
			  :sucme_comment '"at very start"
			  ))
	)
    (debug "give_normalized_macroexpanded_list ucmeb1=" ucmeb1 "\n.. iniproc=" iniproc)
    (code_chunk startmodnam
		#{ /* give_normalized_macroexpanded_list $STARTMODNAM */
	#if HAVE_CLOCK
		$STARTCLOCK = (long) clock () ;
	#endif /*HAVE_CLOCK */
	#if MELT_HAVE_DEBUG
	     if (melt_dbgcounter > 0)
		inform  (UNKNOWN_LOCATION, 
			 "MELT [#%ld] generating C++ code of module %s", 
			 melt_dbgcounter, melt_string_str ((melt_ptr_t) $MODNAMSTR)) ;
	     else
	#endif/* MELT_HAVE_DEBUG */
		inform  (UNKNOWN_LOCATION, 
			 "MELT generating C++ code of module %s", 
			 melt_string_str ((melt_ptr_t) $MODNAMSTR)) ;
		}#)
    ;; special hack to copy the first comment before anything else,
    ;; practically useful to make the copyright comment appear really
    ;; early in generated declaration buffer.
    (when (is_a firstx class_source_comment)
      (list_popfirst xlist)
      (let ( (sloc (unsafe_get_field :loca_location firstx))
	     (scomm (unsafe_get_field :scomm_str firstx)) 
	     )
	(put_fields modctx :mocx_startcomment scomm)
	)
      )
    (debug "give_normalized_macroexpanded_list ucmeb1=" ucmeb1 " modinienv=" modinienv)
    (if modinienv 
	(list_prepend xlist ucmeb1))
    (debug "give_normalized_macroexpanded_list xlist=" xlist "\n.. iniproc=" iniproc
	   "\n.. inienv=" inienv)
    (assert_msg "check xlist" (is_list xlist) xlist)
    ;;
    ;; we need to normalize now, because cheaders are handled by normalization
    (foreach_pair_component_in_list
     (xlist)
     (curpair sexp)
     (debug "give_normalized_macroexpanded_list sexp=" sexp "\n.. inienv=" inienv)
     (let (
	   (psloc (if (is_a sexp class_located) (unsafe_get_field :loca_location sexp)))
	   )
       (multicall 
	(nexp nbind)
	(normal_exp sexp inienv ncx psloc) ;;; inienv is probably wrong here	    
	(debug "give_normalized_macroexpanded_list nexp=" nexp "\n.. nbind=" nbind "\n.. for sexp=" debug_less sexp "\n.. psloc=" psloc "\n")
	;; check the nbind and its elements
	(assert_msg "check nbind" (is_list_or_null nbind) nbind)
	(cppif MELT_HAVE_DEBUG
	       (foreach_pair_component_in_list
		(nbind)
		(curpair curbind)
		(assert_msg "check curbind" (is_a curbind class_normal_let_binding) curbind)))
	;;
	(let ( (newnexp nexp)
	       (newnbind nbind)
	       )
	  ;; letwrap when relevant
	  (when (list_first_element nbind)
	    (debug "give_normalized_macroexpanded_list should wrap nexp=" nexp "\n.. nbind=" nbind)
	    (assert_msg "check nexp" (is_not_a nexp class_nrep_anyproc) nexp)
	    ;;
	    (setq newnbind ())
	    (cond ( (is_multiple nexp)
		    (debug "give_normalized_macroexpanded_list multiple nexp=" nexp)
		    (setq newnexp (wrap_normal_letseq nexp nbind psloc))
		    (debug "give_normalized_macroexpanded_list wrapseq newnexp=" newnexp))
		  ( (is_list nexp)
		    (assert_msg "give_normalized_macroexpanded_list nonlist nexp" () nexp))
		  (:else
		   (setq newnexp (wrap_normal_let1 nexp nbind psloc))
		   (debug "give_normalized_macroexpanded_list wrap1 newnexp=" newnexp)))
	    )
	  ;;
	  (cond ( (is_list newnexp)
		  (list_append2list normlist newnexp))
		( (is_multiple newnexp)
		  (foreach_in_multiple
		   (newnexp)
		   (curcomp :long cix)
		   (list_append normlist curcomp)))
		(:else
		 (list_append normlist newnexp)))
	  (debug "give_normalized_macroexpanded_list updated normlist=" debug_less normlist)
	  ;;
	  (assert_msg "check empty newnbind" (==i (list_length newnbind) 0) newnbind)
	  )
	))
     )
    ;;
    (debug "give_normalized_macroexpanded_list gives normlist=" normlist
	   "\n startclock=" startclock)
    (return normlist startclock)
    ))




;;; utility function to output the hook C procedures for hook with module variables
(defun output_hooks_with_modvar (tuphooks modctx declbuf implbuf)
  (debug "output_hooks_with_modvar tuphooks=" tuphooks)
  (let ( (:long nbhooks (multiple_length tuphooks))
	 )
    (add2out declbuf "\n/*** " nbhooks " hooks in module variables declarations ***/\n")
    (add2out implbuf "\n/*** " nbhooks 
	     " hooks in module variables implementations [by output_hooks_with_modvar] ***/\n")
    (foreach_in_multiple
     (tuphooks)
     (curhookrout :long hix)
     (debug "output_hooks_with_modvar curhookrout=" curhookrout " hix#" hix)
     (assert_msg "check curhookrout" (is_a curhookrout class_hookroutineobj) curhookrout)
     (let ( (nhookproc (get_field :obrout_proc curhookrout))
	    (nhookdata (get_field :nrhook_datahook nhookproc))
	    (modvarbind (get_field :ndhook_modvarbind nhookdata))
	    (hkname (get_field :nrclop_name nhookproc))
	    (hkins (get_field :nrclop_argbindtuple nhookproc))
	    (hkouts (get_field :nrhook_outb nhookproc))
	    (hkctype (get_field :nrhook_ctype nhookproc))
	    (hkctypename (get_field :ctype_cname hkctype)) 
	    (:long nbparam 0)
	   )
       (debug "output_hooks_with_modvar nhookproc=" nhookproc "\n modvarbind=" modvarbind)
       (debug "output_hooks_with_modvar hkname=" hkname "\n nhookdata=" nhookdata "\n hkctype=" hkctype)
       (debug "output_hooks_with_modvar hkins=" hkins " hkouts=" hkouts)
       (assert_msg "check nhookproc" (is_a nhookproc class_nrep_hookproc) nhookproc)
       (assert_msg "check hkname" (is_string hkname) hkname)
       (assert_msg "check hkctype" (is_a hkctype class_ctype) hkctype)
       (debug "output_hooks_with_modvar nhookdata=" nhookdata)
       (assert_msg "check nhookdata" (is_a nhookdata class_nrep_datahook) nhookdata)
       (add2out declbuf "\n" "/* declare hook with module variable " hkname " */\n")
       (add2out declbuf "MELT_EXTERN " hkctypename " melthookproc_" hkname " (")
       (add2out implbuf "\n" "/* define hook with module variable " hkname " */\n")
       (add2out implbuf hkctypename " melthookproc_" hkname " (")
       (debug "output_hooks_with_modvar hkins=" hkins)
       ;; some code similar to generate_runtypesupport_predefined_hooks
       ;; emit the input parameters
       (foreach_in_multiple 
	(hkins)
	(curinsb :long inix)
	(debug "output_hooks_with_modvar curinsb=" curinsb " inix#" inix)
	(when (>i nbparam 0) 
	  (add2out declbuf ", ")
	  (add2out implbuf ", "))
	(setq nbparam (+i nbparam 1))
	(assert_msg "check curinsb" (is_a curinsb class_formal_binding) curinsb)
	(add2out declbuf (get_field :ctype_cname (get_field :fbind_type curinsb)))
	(add2out declbuf " meltin_" (get_field :named_name (get_field :binder curinsb)) "_p" inix)
	(add2out implbuf (get_field :ctype_cname (get_field :fbind_type curinsb)))
	(add2out implbuf " meltin_" (get_field :named_name (get_field :binder curinsb)) "_p" inix)
	)
       ;; emit the output parameters
       (foreach_in_multiple
	(hkouts)
	(curoutb :long outix)
	(debug "output_hooks_with_modvar curoutb=" curoutb " outix#" outix)
	(when (>i nbparam 0) 
	  (add2out declbuf ", ")
	  (add2out implbuf ", "))
	(setq nbparam (+i nbparam 1))
	(add2out declbuf 
		 (get_field :ctype_cname (get_field :fbind_type curoutb))
		 "* meltout_" (get_field :named_name (get_field :binder curoutb)) "_o" outix)
	(add2out implbuf ", ")
	(add2out implbuf (get_field :ctype_cname (get_field :fbind_type curoutb)))
	(add2out implbuf "* meltout_" (get_field :named_name (get_field :binder curoutb)) "_o" outix)
	)
       (add2out declbuf ");\n")
       (add2out implbuf ")\n" "{\n")
       ;; emit the body
       (add2out implbuf "  typedef " hkctypename " melthooksig_" hkname "_t (")
       (add2out implbuf "melt_ptr_t")
       (foreach_in_multiple 
	(hkins)
	(curinsb :long inix)
	(add2out implbuf ", " (get_field :ctype_cname (get_field :fbind_type curinsb)))
	)
       (foreach_in_multiple 
	(hkouts)
	(curoutb :long outix)
	(add2out implbuf ", "  (get_field :ctype_cname (get_field :fbind_type curoutb)) "* ")
	)
       (add2out implbuf ");")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf "  melthook_ptr_t melthkp = (melthook_ptr_t) melt_module_var_fetch (")
       (out_enumix_modvarbind implbuf modvarbind)
       (add2out implbuf ");\n")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf "/*checkhook exist*/ melt_assertmsg (\" check module hook " hkname " exists\", ")
       (add2sbuf_indentnl implbuf 15)
       (add2out implbuf "             melthkp != NULL);")
       (add2sbuf_indentnl implbuf 1)
       (add2out implbuf "/*checkhook good*/ melt_assertmsg (\" check  module good hook " hkname " \", ")
       (add2sbuf_indentnl implbuf 15)
       (add2out implbuf "             melt_magic_discr ((melt_ptr_t) melthkp) == MELTOBMAG_HOOK);")
       (add2sbuf_indentnl implbuf 1)
       (add2out
	implbuf 
##{ /* check hook routine $HKNAME */
   melthooksig_$HKNAME#_t *melthookptr_$HKNAME = 
   (melthooksig_$HKNAME#_t*) (melthkp->hookad) ;
   melt_assertmsg("check module hook routine $HKNAME", 
	       melthookptr_$HKNAME);
}#)
       (add2sbuf_indentnl implbuf 1)
       (add2out
	implbuf ##{return (*melthookptr_$HKNAME) ((melt_ptr_t)melthkp}#
                                                            )
	(foreach_in_multiple 
	 (hkins)
	 (curinsb :long inix)
	 (add2out implbuf ",")
	 (add2sbuf_indentnl implbuf 20)
	 (add2out implbuf " meltin_" (get_field :named_name (get_field :binder curinsb)) "_p" inix)
	 )
	(foreach_in_multiple
	 (hkouts)
	 (curoutb :long outix)
	 (add2out implbuf ",") 
	 (add2sbuf_indentnl implbuf 20)
	 (add2out implbuf " meltout_" (get_field :named_name (get_field :binder curoutb)) "_o" outix)
	 )
	(add2out implbuf ");")
	(add2sbuf_indentnl implbuf 0)
       (add2out implbuf "} /*** end  melthookproc_" hkname " **/\n\n")
       )
     )					;end foreach tuphooks
    (add2out declbuf "\n/*** end of " nbhooks " hooks in module variables declarations ***/\n")
    (add2out implbuf "\n/*** end of " nbhooks 
	     " hooks in module variables implementations ***/\n")
));; end output_hooks_with_modvar




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utility function to translate a macroexpanded list
(defun translate_macroexpanded_list (xlist modnamstr modctx ncx inienv normalisthandler iniproctransl)
  ;; XLIST is the list of macro-expanded things, usually instances of
  ;; subclasses of class_source
  ;;
  ;; MODNAMSTR is the name string of the module
  ;;
  ;; MODCTX is the module generation context of class_any_module_context
  ;;
  ;; NCX is the normalization context, of class_normalization_context
  ;;
  ;; INIENV is the initial environment, of class_environment
  ;;
  ;; NORMALISTHANDLER is null or a closure to post-process the
  ;; normalized list
  ;;
  ;; INIPROCTRANSL is the translator of the initial routine
  ;;
;;;;;;;;;;;;;;;;
  (debug "translate_macroexpanded_list modnamstr=" modnamstr "\n* modctx=" modctx
	 "\n* inienv=" inienv
	 "\n* iniproctransl=" iniproctransl)
  (assert_msg "check xlist" (is_list xlist) xlist)
  (assert_msg "check modnamstr" (is_string modnamstr) modnamstr)
  (assert_msg "check modctx" (is_a modctx class_any_module_context) modctx)
  (assert_msg "check ncx" (is_a ncx class_normalization_context) ncx)
  (assert_msg "check inienv" (is_a inienv class_environment) inienv)
  (assert_msg "translate_macroexpanded_list modulename not ended with MELT_DYNLOADED_SUFFIX."
	      (not (string_dynloaded_suffixed modnamstr)) modnamstr)
  (assert_msg "translate_macroexpanded_list modulename not ended with .melt"
	      (not (string_suffixed modnamstr ".melt")) modnamstr)
  (assert_msg "translate_macroexpanded_list modulename not ended with .cc"
	      (not (string_suffixed modnamstr ".cc")) modnamstr)
  (assert_msg "translate_macroexpanded_list modulename not ended with .c"
	      (not (string_suffixed modnamstr ".c")) modnamstr)
  (let (
	(:long endclock 0)
	(errorhdlr (get_field :mocx_errorhandler modctx))
	(gendevlist (get_field :mocx_gendevlist modctx))
	(modinienv (get_field :mocx_initialenv modctx))
	(iniproc (get_field :nctx_initproc ncx))
	(implbuf (make_strbuf discr_strbuf)) 
	(declbuf (make_strbuf discr_strbuf))
	)
    (debug "translate_macroexpanded_list modinienv=" modinienv "\n.. modnamstr=" modnamstr
	   "\n.. before give_normalized_macroexpanded_list modctx=" modctx "\n ..xlist=" xlist)
    (multicall
     (normlist :long startclock)
     (give_normalized_macroexpanded_list xlist modnamstr modctx ncx inienv)
     (debug "translate_macroexpanded_list give_normalized_macroexpanded_list give normlist=" normlist
	    "\n.. startclock=" startclock "\n")
     (assert_msg "check normlist" (is_list normlist) normlist)
     (debug "translate_macroexpanded_list after normalize_macroexpanded_list modctx=" modctx
	    "\n.. normalisthandler=" normalisthandler
	    "\n.. normlist=" normlist)
     (when (is_closure normalisthandler)
       (debug "translate_macroexpanded_list before calling normalisthandler=" normalisthandler 
	      "\n.. with normlist=" normlist 
	      "\n.. of length " (list_length normlist))
       (normalisthandler normlist modctx ncx inienv)
       (debug "translate_macroexpanded_list after calling normalisthandler normlist=" normlist
	      "\n.. of length " (list_length normlist)
	      "\n.. iniproc=" iniproc)
       )
     ;;
     ;; insert the normalized list inside the initial procedure but skip the procedures
     (debug "translate_macroexpanded_list iniproc=" iniproc "\n.. before insertion of normlist=" normlist)
     (assert_msg "check iniproc" (is_a iniproc class_nrep_initproc) iniproc)
     (let ( (initoplist (get_field :ninit_topl iniproc))
	    )
       (debug "translate_macroexpanded_list initoplist=" initoplist)
       (assert_msg "check empty initoplist" (==i 0 (list_length initoplist)) initoplist)
       (foreach_pair_component_in_list
	(normlist)
	(curpair curnorm)
	(debug "translate_macroexpanded_list curnorm=" curnorm)
	(if (is_not_a curnorm class_nrep_anyproc)
	    (list_append initoplist curnorm)))
       (debug "translate_macroexpanded_list updated initoplist=" initoplist "\n.. in iniproc=" iniproc)
       )
     ;;
     ;;
     (when (melt_error_counter)
       (if (is_closure errorhdlr) 
	   (errorhdlr '"MELT translation failed after normalization"))
       (code_chunk errorednormal_warnchk 
		   #{ /* translate_macroexpanded_list $ERROREDNORMAL_WARNCHK */
		   warning (0, "MELT translation of %s got after normalization %ld MELT errors",
			       melt_string_str((melt_ptr_t) $MODNAMSTR), melt_error_counter) ;
		   }#)
       (return))
     ;;
     ;;
     (let ( (prolist (get_field :nctx_proclist ncx)) 
	    (objlist (make_list discr_list))
	    (compicache (make_mapobject discr_map_objects (+i 10 (*i 20 (list_length xlist)))))
	    (:long count 0)
	    ) 
       ;;
       ;; compile each procedure and check for errors
       (debug "translate_macroexpanded_list prolist=" prolist)
       (shortbacktrace_dbg "translate_macroexpanded_list" 14)
       ;;
       (assert_msg "check prolist" (is_list prolist) prolist)
       (foreach_pair_component_in_list
	(prolist)
	(curpair pro)
	(setq count (+i count 1))
	(debug "translate_macroexpanded_list pro=" pro 
	       "\n.. compicache=" compicache
	       "\n.. count=" count)
	(shortbacktrace_dbg "translate_macroexpanded_list" 10)
	(cond 
	 ;; first check for hooks
	 ( (is_a pro class_nrep_hookproc)
	   (let ( (objhook (compile2obj_hook pro modctx compicache count))
		  )
	     (list_append objlist objhook)
	     (debug "translate_macroexpanded_list objhook=" objhook 
		    "\n.. pro=" pro "\n.. objlist=" objlist 
		    "\n.. compicache=" compicache)
	     (assert_msg "check objhook=" (is_object objhook) objhook)
	     ))
	 ( (is_a pro class_nrep_anyproc)
	   (let ( (objpro (compile2obj_procedure pro modctx compicache count)) 
		  )
	     (list_append objlist objpro)
	     (debug "translate_macroexpanded_list objpro=" objpro 
		    "\n.. pro=" pro "\n.. objlist=" objlist
		    "\n.. compicache=" compicache)
	     (assert_msg "check objpro=" (is_object objpro) objpro)
	     ))
	 ( :else
	   (assert_msg "translate_macroexpanded_list unexpected procedure" () pro))
	 ))				;end foreach_pair_component_in_list
       ;;
       (when (melt_error_counter)
	 (if (is_closure errorhdlr) 
	     (errorhdlr '"MELT translation failed after generation"))
	 (code_chunk erroredgener_warnchk 
		     #{ /* translate_macroexpanded_list $ERROREDGENER_WARNCHK */
		     warning (0, "MELT translation of %s got after generation %ld MELT errors",
				 melt_string_str((melt_ptr_t) $MODNAMSTR), melt_error_counter) ;
		     }#)
	 (return))
       ;;
       ;; compile the initial procedure
       (assert_msg "check objlist" (is_list objlist) objlist)
       (debug "translate_macroexpanded_list checking elements of objlist=" objlist)
       (foreach_pair_component_in_list
	(objlist)
	(pairel obel)
	(assert_msg "check obel is object" (is_object obel) obel)
	)
       ;;
       (let ( (inipro (unsafe_get_field :nctx_initproc ncx)) 
	      (inidata (unsafe_get_field :nctx_datalist ncx))
	      (importvalues (unsafe_get_field :nctx_valuelist ncx))
	      (procurmodenvlist (unsafe_get_field :nctx_procurmodenvlist ncx))
	      )
	 (debug "translate_macroexpanded_list before compiling initproc inipro=" inipro 
		"\n... of discrim=" (discrim inipro)
		"\n.. iniproctransl=" iniproctransl
		"\n.. importvalues=" importvalues
		"\n.. normlist=" normlist)
	 (assert_msg "null iniprobody" (null (get_field :nproc_body inipro)) inipro)
	 (let ( (importup (list_to_multiple 
			   importvalues discr_multiple
			   (lambda (curimp)
			     (debug "translate_macroexpanded_list/lambda curimp=" curimp)
			     (let ( (resimp (normal_import curimp inienv ncx ()))
				    )
			       (debug "translate_macroexpanded_list/lambda resimp=" resimp)
			       resimp
			       ))))
		)
	   (debug "translate_macroexpanded_list importup=" importup)
	   (put_fields inipro :nproc_body normlist :ninit_imports importvalues
		       :ninit_importexprs importup)
	   (debug "translate_macroexpanded_list unpdated inipro=" inipro)
	   )
	 (assert_msg "check inipro" (is_a inipro class_nrep_initproc) inipro)
	 (assert_msg "check iniproctransl" (is_closure iniproctransl) iniproctransl)
	 (debug "translate_macroexpanded_list inipro= " inipro
		"\n before calling iniproctransl=" iniproctransl
		"\n.. objlist=" objlist)
	 (foreach_pair_component_in_list
	  (objlist)
	  (pairel obel)
	  (assert_msg "check obel is object" (is_object obel) obel)
	  )
	 (let ( (iniobj
		 (iniproctransl inipro modctx inidata compicache procurmodenvlist)) 
		)
	   (debug "translate_macroexpanded_list iniobj=" iniobj
		  "\n objlist=" objlist)
;;;
;;;;;;;;;
	   (let ( 
		 (mstartcom (get_field :mocx_startcomment modctx))
		 (mheadertup (list_to_multiple (get_field :mocx_cheaderlist modctx) discr_multiple))
		 (mimplemtup (list_to_multiple (get_field :mocx_cimplementlist modctx) discr_multiple))
		 (modvarlist (get_field :mocx_varlist modctx))
		 (:long nbheaders (multiple_length mheadertup))
		 (:long nbimplems (multiple_length mimplemtup))
		 (modhookdict (get_field :mocx_hookdict modctx))
		 (:long nbmodhooks (mapstring_count modhookdict))
		 (hookswithmodvarlist (make_list discr_list)) ; hack to generate hook with :var
		 )
	     (debug "translate_macroexpanded_list mstartcom=" mstartcom
		    "\n .. mheadertup=" mheadertup
		    "\n .. mimplemtup=" mimplemtup)
	     (add2out declbuf "/**** MELT GENERATED DECLARATIONS for ")
	     (add2sbuf_ccomstring declbuf (make_string_nakedbasename discr_string modnamstr))
	     (add2out declbuf " ** DO NOT EDIT ; see gcc-melt.org ****/")
	     (add2sbuf_indentnl declbuf 0)
	     ;;
	     (add2out implbuf "/**** MELT GENERATED IMPLEMENTATIONS for ")
	     (add2sbuf_ccomstring implbuf (make_string_nakedbasename discr_string modnamstr))
	     (add2out implbuf " ** DO NOT EDIT ; see gcc-melt.org ****/")
	     (add2sbuf_indentnl declbuf 0)
	     (add2sbuf_indentnl implbuf 0)
	     (when (is_string mstartcom)
	       (add2out declbuf "/****++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n")
	       (add2sbuf_ccomstring declbuf mstartcom)
	       (add2sbuf_indentnl declbuf 0)
	       (add2out declbuf "----------------------------------------------------------------****/\n\n")
	       (add2sbuf_indentnl declbuf 0))
	     ;;
	     (if modinienv
		 (progn
		   ;; plain module
		   (add2out declbuf "/** ordinary MELT module " modnamstr "**/")
		   (add2sbuf_indentnl declbuf 0)
		   (add2out declbuf "#define MELT_HAS_INITIAL_ENVIRONMENT 1 /*usualmodule*/\n")
		   )
	       (progn
		 ;; lack of initial environment happens only in translateinit
		 ;; mode for warmelt-first.melt
		 (add2out declbuf "/** first MELT module " modnamstr "**/")
		 (add2sbuf_indentnl declbuf 0)
		 (add2out declbuf "#define MELT_HAS_INITIAL_ENVIRONMENT 0 /*firstmodule*/\n")
		 (code_chunk 
		  check_warmelt_first_bootstrapping_chunk #{ 
		  /* translate_macroexpanded_list $CHECK_WARMELT_FIRST_BOOTSTRAPPING_CHUNK */ 
		  melt_checkmsg ("bootstrapping first file",
				 melt_flag_bootstrapping 
				 && melt_string_str((melt_ptr_t) $MODNAMSTR)
				 && strstr(melt_string_str((melt_ptr_t) $MODNAMSTR), "first")) ;
		  }#)
		 ))
	     (add2sbuf_indentnl declbuf 0)
	     (add2sbuf_indentnl declbuf 0)
	     (add2sbuf_indentnl declbuf 0)
	     (add2out declbuf "class " (initial_classy_frame_name iniobj) "; // forward declaration fromline " (this_line))
	     (add2sbuf_indentnl declbuf 0)
	     (add2out declbuf "typedef " (initial_classy_frame_name iniobj) " Melt_InitialFrame;")
	     (add2sbuf_indentnl declbuf 0)
	     ;;
	     ;;
	     ;; module variables
	     (let ( (modvartup (list_to_multiple modvarlist discr_multiple))
		    (:long nbmodvars (multiple_length modvartup))
		    (modnamcident (let ( (sbuf (make_strbuf discr_strbuf)) )
				    (add2sbuf_cident sbuf (get_field :mocx_modulename modctx))
				    (strbuf2string discr_verbatim_string sbuf)))
		    )
	       (if nbmodvars
		   (progn
		     (debug "translate_macroexpanded_list modvartup=" modvartup)
		     (add2out declbuf "/*** " nbmodvars " MELT module variables declarations ****/\n")
		     (add2out implbuf "/*** " nbmodvars " MELT module variables implementations ****/\n")
		     (add2out declbuf "MELT_EXTERN void melt_forwarding_module_data (void);\n")
		     (add2out declbuf "MELT_EXTERN void melt_marking_module_data (void);\n")
		     ;; declare & define the static pointers and flags
		     (let ( (:long nbvarslots (*i 16 (+i (/iraw (+i nbmodvars 1) 16) 1)))
			    (:long nbflags (+i (/iraw nbmodvars 16) 1))
			    )
		       (add2out declbuf 
				"\n"
				"MELT_EXTERN melt_ptr_t MELT_MODULE_VISIBILITY melt_" modnamcident "_module_var_ptr_tab[" 
				nbvarslots "];\n")
		       (add2out declbuf 
				"MELT_EXTERN bool MELT_MODULE_VISIBILITY melt_" modnamcident "_module_var_flags[" 
				nbflags "];\n\n")
		       (add2out implbuf "melt_ptr_t melt_" modnamcident "_module_var_ptr_tab[" nbvarslots "];\n")
		       (add2out implbuf "bool melt_" modnamcident "_module_var_flags["  nbflags "];\n")
		       )
		     ;; emit the fetch & put; useful for outpucod_objfetchmodvar & outpucod_objputmodvar
		     (add2out declbuf 
			      "static inline melt_ptr_t\n"
			      "melt_module_var_fetch (int ix)\n"
			      "{return (ix > 0  &&  ix <= " nbmodvars ")?melt_" modnamcident "_module_var_ptr_tab[ix]:NULL;}\n\n")
		     (add2out declbuf 
			      "static inline void\n" 
			      "melt_module_var_put (int ix, melt_ptr_t val)\n"
			      "{\n"
			      "  if (ix > 0  &&  ix <= " nbmodvars ") {\n"
			      "    melt_" modnamcident "_module_var_ptr_tab[ix]= val;\n"
			      "    melt_" modnamcident "_module_var_flags[ix/16] = true;\n  }\n}\n\n")
		     ;; emit the forwarding routine
		     (add2out implbuf "\n/**** forwarding MELT module variables ****/\n")
		     (add2out implbuf "void melt_forwarding_module_data (void) {\n")
		     (add2out implbuf "  int i, j;\n")
		     (add2out implbuf "  melt_" modnamcident "_module_var_ptr_tab[0] = NULL; /* unused modvar elem */\n")
		     (add2out implbuf "  for (i=0; i<=" (/iraw (+i nbmodvars 1) 16) "; i++) {\n")
		     (add2out implbuf "    if (melt_" modnamcident "_module_var_flags[i]) {\n")
		     (add2out implbuf "      melt_" modnamcident "_module_var_flags[i] = false;\n")
		     (add2out implbuf "      for (j=0; j<16; j++)\n")
		     (add2out implbuf "        MELT_FORWARDED (melt_" modnamcident "_module_var_ptr_tab[i*16+j]);\n")
		     (add2out implbuf "    };\n")
		     (add2out implbuf "  }\n")
		     (add2out implbuf "} /* end melt_fowarding_module_data */\n\n")
		     ;; emit the marking routine
		     (add2out implbuf "\n/**** marking MELT module variables ****/\n")
		     (add2out implbuf "void melt_marking_module_data (void) {\n")
		     (add2out implbuf "  int i;\n")
		     (add2out implbuf "  melt_" modnamcident "_module_var_ptr_tab[0] = NULL; /* unused modvar elem */\n")
		     (add2out implbuf "  for (i=1; i <= " nbmodvars "; i++)\n")
		     (add2out implbuf "    " (get_field :ctype_marker ctype_value) "(melt_" modnamcident "_module_var_ptr_tab[i]);\n")
		     (add2out implbuf "} /* end melt_marking_module_data */\n\n")
		     ;;
		     ;; should emit the enum for the indexes
		     (add2out declbuf "/* MELT module variables indexes */\n"
			      "enum {\n"
			      " meltmodatix_none,\n")
		     (foreach_in_multiple
		      (modvartup)
		      (curmodvarbind :long mvix)
		      (debug "translate_macroexpanded_list curmodvarbind=" curmodvarbind " mvix#" mvix)
		      (assert_msg "check curmodvarbind" (is_a curmodvarbind class_normal_module_variable_binding) curmodvarbind)
		      (add2out declbuf " ")
		      (out_enumix_modvarbind declbuf curmodvarbind)
		      (add2out declbuf " = " (+i mvix 1) ",\n")
		      )
		     (add2out declbuf " meltmodatix_last\n")
		     (add2out declbuf "}; /* end MELT module variables indexes */\n")
		     )
		 (progn
		   (add2out declbuf "/**** no MELT module variables ****/\n")
		   ))
	       )
	     ;;
	     ;;
	     ;;;; called hook declarations
	     (if nbmodhooks
		 (let ( (sortuphook (sorted_named_dict_tuple modhookdict))
		       )
		   (debug "translate_macroexpanded_list sortuphook=" sortuphook "\n modhookdict=" modhookdict)
		   (add2out declbuf "\n/*** " nbmodhooks " MELT called hook declarations ***/\n")
		   (foreach_in_multiple
		    (sortuphook)
		    (curhkdesc :long hkix)
		    (debug "translate_macroexpanded_list curhkdesc=" curhkdesc "\n .. hkix#" hkix)
		    (assert_msg "check curhkdesc" (is_a curhkdesc class_hook_descriptor) curhkdesc)
		    (let ( (hkname (get_field :named_name curhkdesc))
			   (hkins (get_field :hookdesc_in_formals curhkdesc))
			   (hkouts (get_field :hookdesc_out_formals curhkdesc))
			   (hkctype (get_field :hookdesc_ctype curhkdesc))
			   (hkctypename (get_field :ctype_cname hkctype))
			   )
		    (add2out declbuf "\n/*declare MELT called hook #" hkix " " hkname " **/\n")
		    (add2out declbuf "MELT_EXTERN " hkctypename " melthook_" hkname " (melt_ptr_t melthookdatap")
		    (foreach_in_multiple
		     (hkins)
		     (curinsb :long inix)
		     (add2out declbuf ", " (get_field :ctype_cname (get_field :fbind_type curinsb))
			      " meltinp" inix "_" (symbol_cname (get_field :binder curinsb)))
		     )
		    (foreach_in_multiple
		     (hkouts)
		     (curoutsb :long outix)
		     (add2out declbuf ", " (get_field :ctype_cname (get_field :fbind_type curoutsb))
			      "* meltoutp" outix "_" (symbol_cname (get_field :binder curoutsb)))     
		     )
		    (add2out declbuf ");\n")
		   ))
		   (add2out declbuf
			    "\n/*** end of " nbmodhooks " MELT called hook declarations ***/\n\n")
		   )
	       (progn
		 (add2out declbuf "/**** no MELT called hook declarations ***/\n")
		 ))
	     ;;
	     ;;
	     ;;;; headers
	     (if nbheaders
		 (progn
		   (add2out declbuf "/*** " nbheaders " extra MELT c-headers ***/\n")
		   (foreach_in_multiple
		    (mheadertup)
		    (curheader :long hdix)
		    (debug  "translate_macroexpanded_list curheader=" curheader " hdix#" hdix)
		    (assert_msg "check curheader" (is_a curheader class_source_cheader) curheader)
		    (let ( 
			  (hloc (get_field :loca_location curheader))
			  (hstr (get_field :sc_codestring curheader))
			  )
		      (add2sbuf_indentnl declbuf 0)
		      (add2sbuf_indentnl declbuf 0)
		      (add2out declbuf "/** MELT extra c-header " (+i hdix 1) " : **/\n")
		      (output_raw_location hloc declbuf 0 "xtracheader")
		      (add2sbuf_string declbuf hstr)
		      (add2sbuf_indentnl declbuf 0)
		      )
		    (add2out declbuf "/*** end of " nbheaders " extra MELT c-headers ***/\n")
		    ))
	       (add2out declbuf "/*** no extra MELT c-headers ***/\n"))
	     ;;
	     ;;
	     (if nbimplems
		 (progn
		   (add2out implbuf "/*** " nbimplems " extra MELT implementations ***/\n")
		   (foreach_in_multiple
		    (mimplemtup)
		    (curimplem :long imix)
		    (assert_msg "check curimplem" (is_a curimplem class_source_cimplement) curimplem)
		    (let ( 
			  (iloc (get_field :loca_location curimplem))
			  (istr (get_field :sc_codestring curimplem))
			  )
		      (add2sbuf_indentnl implbuf 0)
		      (add2sbuf_indentnl implbuf 0)
		      (add2out implbuf "/** MELT extra c-implementation " (+i imix 1) " : **/\n")
		      (output_raw_location iloc implbuf 0 "xtracimplem")
		      (add2sbuf_string implbuf istr)
		      (add2sbuf_indentnl implbuf 0)		    
		      ))
		   (add2out implbuf "/*** end of " nbimplems " extra MELT c-implementations ***/\n")
		   )
	       (add2out implbuf "/*** no extra MELT implementations ***/\n"))
;;;;
	     ;;
	     (debug "translate_macroexpanded_list objlist=" objlist)
	     (foreach_pair_component_in_list
	      (objlist)
	      (pairel obel)
	      (debug "translate_macroexpanded_list obel=" obel)
	      (assert_msg "check obel" (is_object obel) obel)
	      ;; hack to generate hook routine with module variable
	      (when  (is_a obel class_hookroutineobj)
		(debug "translate_macroexpanded_list obel is hookroutineobj " obel)
		(let ( (hkproc (get_field :obrout_proc obel))
		       (hkdata (get_field :nrhook_datahook hkproc))
		       )
		  (debug "translate_macroexpanded_list hkproc=" hkproc "\n.. hkdata=" hkdata)
		(when (get_field :ndhook_modvarbind hkdata)
		  (list_append hookswithmodvarlist obel)
		  (debug "translate_macroexpanded_list hookwithmodvar obel=" obel)
		)))
	      ;;
	      ;; we do want to generate several C files...
	      (let ( (:long filnum
			    (if (is_a obel class_procroutineobj)
				(get_int (get_field :oprout_filenum obel))))
		     (secfil 
		      (if filnum (nth_secundary_file modctx modnamstr declbuf filnum)))
		     (outimplbuf 
		      (if secfil (get_field :secfil_implbuf secfil) implbuf))
		     )
		(output_c_code obel declbuf outimplbuf 0)))
;;;
	     (debug "translate_macroexpanded_list final modnamstr=" modnamstr " iniobj=" iniobj) 
	     (add2sbuf_indentnl implbuf 0)
	     (add2sbuf_indentnl implbuf 0)
;;;;; emit the syntax generator
	     (let ( (gendevtup (list_to_multiple  gendevlist discr_multiple))
		    (:long nbgendev (multiple_length gendevtup))
		    )
	       (debug "translate_macroexpanded_list before emit_syntax_testing_routine gendevtup=" gendevtup
		      " gendevlist=" gendevlist)
	       (if nbgendev
		   (emit_syntax_testing_routine gendevtup modctx implbuf)
		 (add2sbuf_strconst implbuf "/*no syntax testing generated*/")
		 ))
	     ;;
	     (add2sbuf_indentnl implbuf 0)
;;;; emit the initial routine
	     (output_c_code iniobj declbuf implbuf 0)
	     (output_exported_offsets modctx declbuf implbuf)
	     (debug "translate_macroexpanded_list hookswithmodvarlist=" hookswithmodvarlist)
	     (let ( (tuphookswithmodvar (list_to_multiple hookswithmodvarlist discr_multiple))
		    )
	       (debug "translate_macroexpanded_list tuphookswithmodvar=" tuphookswithmodvar)
	       (if (multiple_length tuphookswithmodvar)
		   (output_hooks_with_modvar tuphookswithmodvar modctx declbuf implbuf)))
	     )
	   ;; output warnings if the buffer are half the limit
	   (if (>i (strbuf_usedlength declbuf) (/iraw (get_int !buffer_limit_cont) 2))
	       (warningmsg_strv "very large declaration string buffer for module " modnamstr))
	   (if (>i (strbuf_usedlength implbuf) (/iraw (get_int !buffer_limit_cont) 2))
	       (warningmsg_strv "very large implementation string buffer module for " modnamstr))
	   ;;
	   (code_chunk outputcfile
		       #{ /* translate_macroexpanded_list $OUTPUTCFILE: */
		       melt_output_cfile_decl_impl
		       ((melt_ptr_t)($MODNAMSTR),
			(melt_ptr_t)($DECLBUF),
			(melt_ptr_t)($IMPLBUF)) ;
		       }#)
	   ;;(informsg_strv "warmelt generated module C file" modnamstr)
	   (let ( (secfiles (get_field :mocx_filetuple modctx)) 
		  (:long nbsecfiles 0)
		  (:long lgsecfiles (multiple_length secfiles))
		  (:long hisecfilerk 0)
		  )
	     (debug "translate_macroexpanded_list secfiles=" secfiles)
	     (foreach_in_multiple
	      (secfiles)
	      (curfil :long filix)
	      (if curfil
		  (progn
		    (assert_msg "check curfil" 
				(is_a curfil class_secondary_cc_file) curfil)
		    (assert_msg "check curfil index" 
				(==i (get_int curfil) filix) curfil filix)
		    (setq hisecfilerk filix)
		    (increment nbsecfiles 1)
		    ;;(setq nbsecfiles (+i nbsecfiles 1))
		    (let ( (secfilpath (get_field :secfil_path curfil))
			   (secdeclbuf (get_field :secfil_declbuf curfil))
			   (secimplbuf (get_field :secfil_implbuf curfil))
			   )
		      ;; output warnings if the buffer are half the limit
		      (if (>i (strbuf_usedlength secdeclbuf) (/iraw (get_int !buffer_limit_cont) 2))
			  (warningmsg_strv "very large declaration string buffer for secondary file " secfilpath))
		      (if (>i (strbuf_usedlength secimplbuf) (/iraw (get_int !buffer_limit_cont) 2))
			  (warningmsg_strv "very large implementation string buffer for secondary file " secfilpath))
		      ;;
		      (code_chunk 
		       secfilout 
		       #{ /* translate_macroexpanded_list $SECFILOUT: */
		       melt_output_cfile_decl_impl_secondary 
		       ((melt_ptr_t)($SECFILPATH),
			(melt_ptr_t)($SECDECLBUF),
			(melt_ptr_t)($SECIMPLBUF),
			$FILIX)		;
		       }#)
		      ;;(informsg_strv "warmelt generated secondary C file" secfilpath)
		      ))
		))
	     ;;
	     ;; output the descriptive C file 
	     (debug "translate_macroexpanded_list before output descrfil modctx=" modctx)
	     (output_melt_descriptor modnamstr secfiles modctx)
	     ;; remove the old extra files
	     (foreach_long_upto 
	      ((+i hisecfilerk 1) (+i hisecfilerk 25))
	      (:long delfilix)
	      (if (>i delfilix 0)
		  (let ( (delfilnam (generated_cc_filename discr_string modnamstr () delfilix))
			 (baksbuf (make_strbuf discr_strbuf))
			 )
		    (add2out baksbuf delfilnam "~")
		    (let ( (bakfilnam (strbuf2string discr_string baksbuf))
			   )
		      (code_chunk 
		       backupchk
		       #{ /*translate_macroexpanded_list $BACKUPCHK*/ {
		       const char* $BACKUPCHK#_delfilnamstr =
		       melt_string_str ((melt_ptr_t) $DELFILNAM) ;
		       const char* $BACKUPCHK#_bakfilnamstr = 
		       melt_string_str ((melt_ptr_t) $BAKFILNAM) ;
		       if ($BACKUPCHK#_delfilnamstr && $BACKUPCHK#_bakfilnamstr
						    && !access ($BACKUPCHK#_delfilnamstr, F_OK)) {
		       if (!rename ($BACKUPCHK#_delfilnamstr, $BACKUPCHK#_bakfilnamstr)) 
		       inform (UNKNOWN_LOCATION, "MELT backing up previous generated file %s as %s", 
						 $BACKUPCHK#_delfilnamstr, $BACKUPCHK#_bakfilnamstr) ;
		       }
		       $BACKUPCHK#_delfilnamstr = NULL ;
		       $BACKUPCHK#_bakfilnamstr = NULL ;
		       } /*end translate_macroexpanded_list $BACKUPCHK*/ }#)
		      ))))
	     ;;
	     (debug "translate_macroexpanded_list before endmodnamchk modctx=" modctx)
	     (code_chunk 
	      endmodnam
	      #{ /* translate_macroexpanded_list $ENDMODNAM */
  #if HAVE_CLOCK && defined (CLOCKS_PER_SEC)
	      $ENDCLOCK = (long) clock () ;
	      if (melt_flag_bootstrapping)
	        inform (UNKNOWN_LOCATION, 
		      "MELT generated C++ code of module %s with %ld secondary files in %ld CPU millisec [#%ld].", 
		      melt_string_str ((melt_ptr_t) $MODNAMSTR), $NBSECFILES,
		      ($ENDCLOCK - $STARTCLOCK) / (CLOCKS_PER_SEC/1000), melt_dbgcounter) ;
	      else
	        inform (UNKNOWN_LOCATION, 
		      "MELT generated C++ code of module %s with %ld secondary files in %ld CPU millisec.", 
		      melt_string_str ((melt_ptr_t) $MODNAMSTR), $NBSECFILES,
		      ($ENDCLOCK - $STARTCLOCK) / (CLOCKS_PER_SEC/1000)) ;
  #else /* no clock */
	        inform (UNKNOWN_LOCATION, 
		      "MELT generated C++ code of module %s with %ld secondary files", 
		      melt_string_str ((melt_ptr_t) $MODNAMSTR), $NBSECFILES) ;
  #endif /* HAVE_CLOCK && CLOCKS_PER_SEC */
	      /* end translate_macroexpanded_list $ENDMODNAM */ }#)
	     (debug "translate_macroexpanded_list ending modctx=" modctx)
	     (shortbacktrace_dbg "translate_macroexpanded_list ended" 25)
	     (when (melt_error_counter)
	       (if (is_closure errorhdlr) 
		   (errorhdlr '"MELT translation failed after C code emission"))
	       (code_chunk errorednormal_warnchk 
			   #{ /* translate_macroexpanded_list $ERROREDNORMAL_WARNCHK */
			   warning (0, "MELT translation of %s got after emission %ld MELT errors",
				       melt_string_str((melt_ptr_t) $MODNAMSTR), melt_error_counter) ;
			   }#)
	       (return))
	     )))))))
  



;; utility to handle compilation errors as fatal ones
(defun fatal_compile_error (modnamstr v)
  (if (is_string v)
      (code_chunk
       fatalerrormsg_chk 
       #{ /*fatal_compile_error $FATALERRORMSG_CHK */
       melt_fatal_error ("MELT failed to compile module %s (%ld errors): %s",
			 melt_string_str ((melt_ptr_t) $MODNAMSTR),
			 melt_error_counter,
			 melt_string_str ((melt_ptr_t) $V)) ;
       }#)
    (code_chunk 
     fatalerror_chk 
     #{ /* fatal_compile_error $FATALERROR_CHK */
     melt_fatal_error ("MELT failed to compile module %s (%ld errors)",
		       melt_string_str ((melt_ptr_t) $MODNAMSTR),
		       melt_error_counter) ;
     }#))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; compile a list of sexpressions as a module starting from a given environment
(defun compile_list_sexpr (lsexp inienv modnamstr)
  (debug "@*@@@@ compile_list_sexpr lsexp=" lsexp 
	 "\n@ compile_list_sexpr  inienv=" debug_more inienv
	 "\n@ compile_list_sexpr  modnamstr=" modnamstr) 
  (shortbacktrace_dbg "compile_list_sexpr" 10)
  (assert_msg "check lsexp" (is_list lsexp) lsexp)
  (assert_msg "check modnamstr" (is_string modnamstr) modnamstr)
  (assert_msg "check inienv" (is_a inienv class_environment) inienv)
  (assert_msg "compile_list_sexpr modulename not ended with MELT_DYNLOADED_SUFFIX."
	      (not (string_dynloaded_suffixed modnamstr)) modnamstr)
  (assert_msg "compile_list_sexpr modulename not ended with .melt"
	      (not (string_suffixed modnamstr ".melt")) modnamstr)
  (assert_msg "compile_list_sexpr modulename not ended with .c"
	      (not (string_suffixed modnamstr ".c")) modnamstr)
  (assert_msg "compile_list_sexpr modulename not ended with .cc"
	      (not (string_suffixed modnamstr ".cc")) modnamstr)
  (let (
	(modnakedname (make_string_nakedbasename discr_string modnamstr))
	(macroenv (fresh_env inienv (tuple 'macro-environment modnamstr)))
	(basenv (fresh_env inienv (tuple 'base-environment modnamstr)))
	(modctx (instance class_module_context
			  :mocx_modulename  modnakedname
			  :mocx_expfieldict (make_mapstring discr_map_strings 390)
			  :mocx_expclassdict (make_mapstring discr_map_strings 140)
			  :mocx_initialenv inienv
			  :mocx_macroenv macroenv
			  :mocx_funcount (make_integerbox discr_integer 0)
			  :mocx_filetuple ()
			  :mocx_cheaderlist (make_list discr_list)
			  :mocx_cimplementlist (make_list discr_list)
			  ;; :mocx_cflags (make_list discr_list)
			  ;; :mocx_linkflags (make_list discr_list)
			  :mocx_packagepclist (make_list discr_list)
			  :mocx_gendevlist (make_list discr_list)
			  :mocx_errorhandler (lambda (v) (fatal_compile_error modnamstr v))
			  :mocx_varcount (make_integerbox discr_integer 0)
			  :mocx_varlist (make_list discr_list)
			  :mocx_hookdict (make_mapstring discr_map_strings 31)
			  :mocx_macrolist (make_list discr_list)
			  ))
	(ncx (create_normcontext modctx)) 
	)
    (debug "compile_list_sexpr modctx=" modctx 
	   "\n of class " (discrim modctx))
    (debug "compile_list_sexpr macroenv=" debug_more macroenv "\n.. basenv=" debug_more basenv)
    (debug "compile_list_sexpr initial ncx=" debug_more ncx "\n.. inienv=" inienv)
    (assert_msg "check ncx" (is_a ncx class_normalization_context) ncx)
    ;; probably use basenv instead of inienv below
    (let ( 
	  (xlist (macroexpand_toplevel_list lsexp basenv macroexpand_1 modctx)) 
	  (:long lenxlist (list_length xlist))
	  )
      (debug "compile_list_sexpr after macroexpansion and before translation modctx=" debug_less modctx
	     "\n.. xlist=" xlist
	     "\n.. basenv=" basenv)
      ;;
      (translate_macroexpanded_list xlist modnamstr modctx ncx basenv () compile2obj_initproc)
      (debug "compile_list_sexpr after translation modctx=" debug_less modctx)
      )))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass class_first_module_context 
  :doc #{$CLASS_FIRST_MODULE_CONTEXT is for compiling the bootstrapped first module warmelt-first. For Gurus.}#
  :super class_module_context
  :fields (
	   ))

;; compile a list of sexpressions as a the first bootstrapping module ie bootstrap warmelt-first
(defun compile_first_bootstrap_list_sexpr (lsexp modnamstr)
  (debug "compile_first_bootstrap_list_sexpr modnamstr=" modnamstr " lsexp=" debug_less lsexp)
  (shortbacktrace_dbg "compile_list_sexpr" 10)
  (assert_msg "check lsexp" (is_list lsexp) lsexp)
  (assert_msg "check modnamstr" (is_string modnamstr) modnamstr)
  (assert_msg "compile_first_bootstrap_list_sexpr modulename not ended with MELT_DYNLOADED_SUFFIX."
	      (not (string_dynloaded_suffixed modnamstr)) modnamstr)
  (assert_msg "compile_first_bootstrap_list_sexpr modulename not ended with .melt"
	      (not (string_suffixed modnamstr ".melt")) modnamstr)
  (assert_msg "compile_first_bootstrap_list_sexpr modulename not ended with .c"
	      (not (string_suffixed modnamstr ".c")) modnamstr)
  (assert_msg "compile_first_bootstrap_list_sexpr modulename not ended with .cc"
	      (not (string_suffixed modnamstr ".cc")) modnamstr)
  (code_chunk 
   check_warmelt_first_bootstrapping_chunk #{ 
   /* compile_first_bootstrap_list_sexpr $CHECK_WARMELT_FIRST_BOOTSTRAPPING_CHUNK */ 
   melt_checkmsg ("bootstrapping first file",
		  melt_flag_bootstrapping 
		  && melt_string_str((melt_ptr_t) $MODNAMSTR)
		  && strstr(melt_string_str((melt_ptr_t) $MODNAMSTR), "first")) ;
   }#)
  (let (
	(modnakedname (make_string_nakedbasename discr_string modnamstr))
	(macroenv (fresh_env initial_environment (tuple 'macro-first modnamstr)))
	(modctx (instance class_first_module_context
			  :mocx_modulename  modnakedname
			  :mocx_expfieldict (make_mapstring discr_map_strings 490)
			  :mocx_expclassdict (make_mapstring discr_map_strings 240)
			  :mocx_initialenv ()
			  :mocx_macroenv macroenv
			  :mocx_funcount (make_integerbox discr_integer 0)
			  :mocx_filetuple ()
			  :mocx_cheaderlist (make_list discr_list)
			  :mocx_cimplementlist (make_list discr_list)
			  ;; :mocx_cflags (make_list discr_list)
			  ;; :mocx_linkflags (make_list discr_list)
			  :mocx_packagepclist (make_list discr_list)
			  :mocx_gendevlist (make_list discr_list)
			  :mocx_errorhandler (lambda (v) (fatal_compile_error modnamstr v))
			  :mocx_varcount (make_integerbox discr_integer 0)
			  :mocx_varlist (make_list discr_list)
			  :mocx_hookdict (make_mapstring discr_map_strings 31)
			  :mocx_macrolist () ;; no macro list because macros are forbidden in first
			  ))
	(ncx (create_normcontext modctx)) 
	)
    (debug "compile_first_bootstrap_list_sexpr modctx=" debug_less modctx "\n ncx=" debug_less ncx)
    (assert_msg "compile_first_bootstrap_list_sexpr check initial_environment" 
		(is_a initial_environment class_environment) initial_environment)
    (assert_msg "check ncx" (is_a ncx class_normalization_context) ncx)
    (let ( (xlist (macroexpand_toplevel_list lsexp initial_environment macroexpand_1 modctx)) 
	   (:long lenxlist (list_length xlist))
	   )
      (debug "compile_first_bootstrap_list_sexpr after macroexpansion and before translation modctx=" debug_less modctx)
      (inform_at () "compile first got $1 expanded expressions in $2" lenxlist modnamstr)
      ;;
      (translate_macroexpanded_list xlist modnamstr modctx ncx initial_environment () compile2obj_initproc)
      )))

;;;;;**********************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; an internal primitive to run an extension file with a basename, an
;; environment, and a tuple of literals
(defprimitive melt_run_extension (basename env litval) :value
  #{ /* melt_run_extension */ meltgc_run_cc_extension
      ((melt_ptr_t) $BASENAME,
       (melt_ptr_t) $ENV,
       (melt_ptr_t) $LITVAL) }#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utility function to box a non-value normal as a return of an
;; autoboxed value
(defun autobox_normal_return (nexp ctyp ncx)
  (debug "autobox_normal_return nexp=" nexp " ctyp=" ctyp " ncx=" debug_less ncx)
  (shortbacktrace_dbg "autobox_normal_return" 12)
  (assert_msg "check ctyp" (is_a ctyp class_ctype) ctyp)
  (let ( (csym (clone_symbol 'retautoboxval))
	 (cbind (instance class_normal_let_binding
			  :letbind_loc ()
			  :binder csym
			  :letbind_type ctype_value
			  :letbind_expr () ;to be filled later
			  ))
	 (clocc (instance class_nrep_locsymocc
			  :nrep_loc ()
			  :nocc_ctyp ctype_value
			  :nocc_symb csym
			  :nocc_bind cbind))
	 (nbinds (list cbind))
	 )
    (debug "autobox_normal_return clocc=" clocc " incomplete cbind=" cbind
	   "\n.. nbinds=" nbinds)
    (cond
     ( (== ctyp ctype_value)
       (if (is_not_a nexp class_nrep_return)
	   (let ( (nret (instance class_nrep_return
				  :nret_main clocc
				  ))
		  )
	     (put_fields cbind :letbind_expr nexp)
	     (debug "autobox_normal_return value gives nret=" nret "\n.. nbinds=" nbinds "\n cbind=" cbind)
	     (return nret nbinds))
	 (return nexp nbinds)))
     ;; autoboxing longs
     ( (== ctyp ctype_long)
       (let ( 
	     (lgsym (clone_symbol 'longautobox))
	     (lgbind (instance class_normal_let_binding
			       :letbind_loc ()
			       :binder lgsym
			       :letbind_type ctype_long
			       :letbind_expr nexp
			       ))
	     (lglocc (instance class_nrep_locsymocc
			       :nrep_loc ()
			       :nocc_ctyp ctype_long
			       :nocc_symb lgsym
			       :nocc_bind lgbind))
	     (nchk (instance 
		    class_nrep_chunk
		    :nrep_loc ()
		    :nchunk_expansion
		    (tuple 
		     (make_stringconst 
		      discr_verbatim_string 
		      "/*autobox long*/ meltgc_new_int((meltobject_ptr_t)MELT_PREDEF(DISCR_CONSTANT_INTEGER), ")
		     lglocc
		     (make_stringconst 
		      discr_verbatim_string 
		      ")"))
		    :nchunk_oper 'autoboxlong
		    :nexpr_ctyp ctype_value))
	     (nret (instance class_nrep_return
			     :nret_main clocc
			     ))
	     )
	 (put_fields cbind :letbind_expr nchk)
	 (list_prepend nbinds lgbind)
	 (debug "autobox_normal_return long return nret=" nret "\n.. nbinds=" nbinds)
	 (return nret nbinds)
	 ))
     ;; autoboxing void
     ( (== ctyp ctype_void)
       (let ( (nilr (instance class_nrep_nil
			      ))
	      (nret (instance class_nrep_return
			      :nret_main clocc))
	      )
	 (put_fields cbind :letbind_expr nilr)
	 (debug "autobox_normal_return void return nret=" nret " nbinds=" nbinds)
	 (return nret nbinds)		    
	 ))
     ;; autoboxing cstrings
     ( (== ctyp ctype_cstring)
       (let (
	     (stsym (clone_symbol 'stringautobox))
	     (stbind (instance class_normal_let_binding
			       :letbind_loc ()
			       :binder stsym
			       :letbind_type ctype_cstring
			       :letbind_expr nexp
			       ))
	     (stlocc (instance class_nrep_locsymocc
			       :nrep_loc ()
			       :nocc_ctyp ctype_cstring
			       :nocc_symb stsym
			       :nocc_bind stbind))
	     (nchk (instance 
		    class_nrep_chunk
		    :nrep_loc ()
		    :nchunk_expansion
		    (tuple 
		     (make_stringconst 
		      discr_verbatim_string 
		      "/*autobox cstring*/ meltgc_new_stringdup((meltobject_ptr_t)MELT_PREDEF(DISCR_STRING), ")
		     stlocc
		     (make_stringconst 
		      discr_verbatim_string 
		      ")"))
		    :nchunk_oper 'autoboxstring
		    :nexpr_ctyp ctype_value))
	     (nret (instance class_nrep_return
			     :nret_main clocc
			     ))
	     )
	 (put_fields cbind :letbind_expr nchk)
	 (list_prepend nbinds stbind)
	 (debug "autobox_normal_return cstring return nret=" nret " nbinds=" nbinds)
	 (return nret nbinds)
	 ))
     ;; autoboxing gty-ed ctypes
     ( (is_a ctyp class_ctype_gty)
       (let ( (dis (get_field :ctype_autoboxdiscr ctyp))
	      (boxf (get_field :ctypg_boxfun ctyp)) 
	      (ctynam (get_field :named_name ctyp))
	      (gtsym (clone_symbol (string4out discr_string "AUTOBOXING_" ctynam)))
	      (gtbind (instance class_normal_let_binding
				:letbind_loc ()
				:binder gtsym
				:letbind_type ctype_cstring
				:letbind_expr nexp
				))
	      (gtlocc (instance class_nrep_locsymocc
				:nrep_loc ()
				:nocc_ctyp ctyp
				:nocc_symb gtsym
				:nocc_bind gtbind))
	      (nchk (instance 
		     class_nrep_chunk
		     :nrep_loc ()
		     :nchunk_expansion
		     (tuple 
		      (make_stringconst 
		       discr_verbatim_string 
		       "/*autobox-gty ")
		      (make_string discr_verbatim_string ctynam)
		      (make_stringconst 
		       discr_verbatim_string 
		       "*/ ")
		      (make_string discr_verbatim_string boxf)
		      (make_stringconst 
		       discr_verbatim_string 
		       " ((meltobject_ptr_t)MELT_PREDEF (")
		      (make_string discr_verbatim_string dis)
		      (make_stringconst 
		       discr_verbatim_string 
		       "), ")
		      gtlocc
		      (make_stringconst 
		       discr_verbatim_string 
		       ")"))
		     :nchunk_oper 'autoboxgty
		     :nexpr_ctyp ctype_value))
	      (nret (instance class_nrep_return
			      :nret_main clocc
			      ))
	      )
	 (put_fields cbind :letbind_expr nchk)
	 (list_prepend nbinds gtbind)
	 (debug "autobox_normal_return gtyctype return nret=" nret " nbinds=" nbinds)
	 (return nret nbinds)
	 ))
     ;;
     (:else
      (debug "autobox_normal_return unexpected ctyp=" ctyp "\n of discrim " (discrim ctyp))
      (assert_msg "autobox_normal_return unexpected ctype" () ctyp)
      ))))




;; translate and run a list of expressions in an environment
(defun translate_run_melt_expressions (exprs env)
  :doc #{Translate and run the MELT s-expressions from $EXPRS in the
  $ENV environment, which can be modified, e.g. by definitions inside
  the $EXPRS. The last expression should preferably gives a value,
  which is returned...}#
  (debug "translate_run_melt_expressions start exprs=" exprs "\n*env=" debug_more env)
  (shortbacktrace_dbg "translate_run_melt_expressions" 12)
  (assert_msg "check env" (is_a env class_environment) env)
  (when (not (is_list exprs))
    (debug "translate_run_melt_expressions gets non-list " exprs " and gives null")
    (return ()))
  (when (null (list_first exprs))
    (debug "translate_run_melt_expressions gets empty list and gives null")
    (return ()))
  (let ( (:long num 0)
	 (:long starterrcount (melt_error_counter))
	 (nakedbasnam ())
	 (referr (instance class_reference))
	 ;; we need to store the normlist for debugging purposes
	 (refnormlist (instance class_reference))
	 )
    (code_chunk numchk #{/* translate_run_melt_expressions $NUMCHK */ 
		char basbuf_$NUMCHK[64] ;
		long num_$NUMCHK = 0 ;
		memset (basbuf_$NUMCHK, 0, sizeof(basbuf_$NUMCHK)) ;
		melt_count_runtime_extensions++ ;
		num_$NUMCHK = melt_count_runtime_extensions ;
		if (melt_count_runtime_extensions
		    > MELT_MAX_RUNTIME_EXTENSIONS)
		melt_fatal_error ("too many %ld MELT runtime extensions",
				  num_$NUMCHK) ;
                /* In translate_run_melt_expressions $NUMCHK using getpid to ensure unicity 
		   of generated naked base name */
		const char* runinfix = melt_argument("run-infix");
		if (runinfix && runinfix[0])
		  {
		    static long informruncounter;
		    /* inform only once. */
		    if (informruncounter++ == 0)
		       inform (UNKNOWN_LOCATION,
				"MELT using the run infix %s for temporary modules", 
				runinfix);
		    if (strlen(runinfix) > 32)
		       melt_fatal_error ("too long run infix %s, should be less than thirty-two bytes", runinfix);
		    for (const char*pr = runinfix; *pr; pr++)
                      if (!ISALNUM(*pr) && *pr != '_')
		       melt_fatal_error ("invalid run infix %s, should have only alphanumerical or _", *
					 runinfix);
		      
		    snprintf (basbuf_$NUMCHK, sizeof(basbuf_$NUMCHK),
			      "meltruni_%.32s_run%04lx", 
			      runinfix, num_$NUMCHK);
		  }
		else 
		  snprintf (basbuf_$NUMCHK, sizeof(basbuf_$NUMCHK), 
			    "melt_p%d_run%04lx", (int)getpid(), num_$NUMCHK) ;
		$NAKEDBASNAM = meltgc_new_string_raw_len ((meltobject_ptr_t)MELT_PREDEF (DISCR_STRING),
							  basbuf_$NUMCHK, -1) ;
		}#)
    (debug "translate_run_melt_expressions nakedbasnam=" nakedbasnam " num=" num " starterrcount=" starterrcount)
    (let (
	  (runerrorhdlr 
	   (lambda (v)
	     (debug "runerrorhdlr v=" v)
	     (cond 
	      ((is_string v)
	       (code_chunk warnrunstr_chk
			   #{ /* translate_run_melt_expressions $WARNRUNSTR_chk */
			   warning (0, "MELT running expression {%s} error - %s", 
				       melt_string_str ((melt_ptr_t) $NAKEDBASNAM), 
				       melt_string_str ((melt_ptr_t) $V)) ; }#
			   ))
	      (:else 
	       (code_chunk warnrun_chk
			   #{ /* translate_run_melt_expressions $WARNRUN_chk */
			   warning (0, "MELT running expression {%s} errored", 
				       melt_string_str ((melt_ptr_t) $NAKEDBASNAM)) ; }#
			   ))
	      )
	     (set_ref referr (or v :true))))
	  (litvalist 
	   (list ()))	    ;first element of list is ignored, so null
	  (macroenv 
	   (let ( (menv (fresh_env env (tuple 'macro-extension nakedbasnam)))
		  )
	     (debug "translate_run_melt_expressions macroenv=" debug_more menv)
	     menv))
	  (modctx
	   (let ( (m (instance class_running_extension_module_context
		     :mocx_modulename  nakedbasnam
		     :mocx_expfieldict (make_mapstring discr_map_strings 71)
		     :mocx_expclassdict (make_mapstring discr_map_strings 19)
		     :mocx_initialenv env
		     :mocx_macroenv macroenv
		     :mocx_funcount (make_integerbox discr_integer 0)
		     :mocx_filetuple ()
		     :mocx_cheaderlist (make_list discr_list)
		     :mocx_cimplementlist (make_list discr_list)
		     :mocx_varcount (make_integerbox discr_integer 0)
		     :mocx_varlist (make_list discr_list)
		     :mocx_hookdict (make_mapstring discr_map_strings 31)
		     ;; :mocx_cflags (make_list discr_list)
		     ;; :mocx_linkflags (make_list discr_list)
		     :mocx_packagepclist (make_list discr_list)
		     :mocx_gendevlist (make_list discr_list)
		     :mocx_macrolist (make_list discr_list)
		     :mocx_errorhandler runerrorhdlr
		     :morcx_litervalist litvalist
		     :morcx_countlitval (make_integerbox discr_integer 1)
		     :morcx_literobjmap (make_mapobject discr_map_objects 53)
		     ))
		  )
	     (debug "translate_run_melt_expressions modctx=" m)
	     m))
	  (ncx 
	   (create_normal_extending_context modctx env))
	  (lsexp
	   (let
	       ( (ls (make_list discr_list))
		 (addexp 
		  (lambda (curexp :long ix)
		    (cond
		     ((null curexp)
		      (void))
		     ((is_a curexp class_sexpr)
		      (list_append ls curexp))
		     ((is_a curexp class_symbol)
		      (list_append ls curexp))
		     ((is_string curexp)
		      (list_append ls curexp))
		     ((is_integerbox curexp)
		      (list_append ls curexp))
		     ((is_closure curexp)
		      (debug "translate_run_melt_expressions closure curexp=" curexp " ix=" ix)
		      (curexp ls))
		     (:else
		      (debug "translate_run_melt_expressions bad curexp=" curexp " ix=" ix)
		      (let ( (curdis (discrim curexp))
			     (curdisname (get_field :named_name curdis))
			     )
			(code_chunk badexp_chk
				    #{ /* translate_run_melt_expressions $BADEXP_CHK */
				    warning (0, "MELT run %s expression #%d has bad disciminant %s",
						melt_string_str ((melt_ptr_t) $NAKEDBASNAM),
						1+(int) $IX, 
						melt_string_str ((melt_ptr_t) $CURDISNAME)) ;
				    }#)
			(runerrorhdlr '"Bad expression")))
		     )
		    ))
		 )
	     (cond
	      ((null exprs)
	       (void))
	      ((is_multiple exprs)
	       (foreach_in_multiple
		(exprs)
		(curexp :long ix)
		(addexp curexp ix)
		))
	      ((is_list exprs)
	       (let ((:long ix 0))
		 (foreach_pair_component_in_list
		  (exprs)
		  (curpair curexp)
		  (setq ix (-i ix 1))
		  (addexp curexp ix))))
	      ((is_a exprs class_sexpr)
	       (addexp exprs -999999))
	      (:else
	       (runerrorhdlr '"No expressions")))
	     ls))
	  )
      ;;macro expand
      (debug "translate_run_melt_expressions modctx=" modctx "\n ncx=" ncx "\n lsexp=" lsexp)
      (when !referr
	(runerrorhdlr '"runtime invalid expressions")
	(return () ()))
      (let ( (xlist
	      (let ( (xl (macroexpand_toplevel_list lsexp env macroexpand_1 modctx))
		     )
		(debug "translate_run_melt_expressions xlist=" xl)
		xl))
	     (:long lenxlist (list_length xlist))
	     ;; normalextend should ensure that the last normal gives a value
	     (normalextend 
	      (lambda (normlist modctx ncx inienv)
		(debug "translate_run_melt_expressions/normalextend normlist=" normlist
		       "\n old !refnormlist=" !refnormlist
		       "\n ncx=" ncx)
		(shortbacktrace_dbg "translate_run_melt_expressions/normalextend" 13)
		(assert_msg "check null !refnormlist" (null !refnormlist) refnormlist)
		(let ( (lastnormpair (list_last normlist))
		       (lastnorm (let ( (ln (list_last_element normlist))
					)
				   (debug "translate_run_melt_expressions/normalextend lastnorm=" ln)
				   ln))
		       (lastctyp (get_ctype lastnorm inienv))
		       )
		  (debug "translate_run_melt_expressions/normalextend lastnorm=" lastnorm 
			 " lastnormpair=" lastnormpair
			 " lastctyp=" lastctyp)
		  (assert_msg "check lastctyp" (is_a lastctyp class_ctype) lastctyp)
		  (cond
		   ((== lastctyp ctype_value)
		    (debug "translate_run_melt_expressions/normalextend value lastnorm=" lastnorm "\n of discrim=" (discrim lastnorm)
			   "\n lastnormpair=" lastnormpair
			   "\n normlist=" normlist)
		    (when (is_not_a lastnorm class_nrep_return)
		      (let ( (nret (instance class_nrep_return
					     :nret_main lastnorm
					     :nrep_loc (get_field :nrep_loc lastnorm)
					     ))
			     )
			(pair_set_head lastnormpair nret)
			(debug "translate_run_melt_expressions/normalextend replaced lastnorm=" lastnorm
			       "\n with nret=" nret 
			       "\n in lastnormpair=" lastnormpair)
			(setq lastnorm nret)
			)))
		   (:else
		    (debug "translate_run_melt_expressions/normalextend nonvalue lastnorm=" lastnorm 
			   " of discrim " (discrim lastnorm) "\n lastctyp=" lastctyp)
		    (warning_at () 
		     "runtime expressions ending with a non-value expression of $1, auto-boxing it."
		     (get_field :named_name lastctyp))
		    (debug "translate_run_melt_expressions/normalextend before autoboxing lastnorm=" lastnorm)
		    (multicall
		     (newexp newbinds)
		     (autobox_normal_return lastnorm lastctyp ncx)
		     (debug "translate_run_melt_expressions/normalextend autoboxed newexp=" newexp
			    "\n.. newbinds=" newbinds)
		     (let ( (newraplast (wrap_normal_let1 newexp newbinds ()))
			    )
		       (debug "translate_run_melt_expressions/normalextend newraplast=" newraplast)
					
		     (pair_set_head lastnormpair newraplast)
		     (setq lastnorm newraplast)
		     ))))
		  ;;
		  (debug "translate_run_melt_expressions/normalextend lastnorm=" lastnorm 
			 "\n lastnormpair=" lastnormpair
			 "\n normlist=" normlist)
		  (set_ref refnormlist normlist)
		  (debug "translate_run_melt_expressions/normalextend final normlist=" normlist
			 "\n updated refnormlist=" refnormlist)
		  (return)
		  )))			;end normalextend
	     )
	(debug "translate_run_melt_expressions xlist=" xlist "\n... normalextend=" normalextend)
	(when (or (notnull !referr) (>i (melt_error_counter) starterrcount))
	  (runerrorhdlr '"runtime macroexpansion failed")
	  (return () ()))
	(let ( (basename (make_string_tempname_suffixed discr_string nakedbasnam "_eXt"))
	       )
	  (debug "translate_run_melt_expressions basename=" basename 
		 " refnormlist=" refnormlist)
	  ;; translate to C code
	  (translate_macroexpanded_list xlist basename modctx ncx env 
					normalextend compile2obj_initextendproc)
	  (debug "translate_run_melt_expressions after translation"
		 " refnormlist=" refnormlist
		 " to nakedbasnam=" nakedbasnam)
	  (when  (or (notnull !referr) (>i (melt_error_counter) starterrcount))
	    (runerrorhdlr '"runtime translation to code failed")
	    (return () ()))
	  ;; should now compile the generated C code
	  (debug "translate_run_melt_expressions before compiling runextend flavor of basename=" basename "\n modctx=" modctx)
	  (generate_flavored_melt_module basename basename '"runextend")
	  (debug "translate_run_melt_expressions after compiling runextend flavor of basename=" basename)
	  ;; make the literal value tuple
	  (assert_msg "check litvalist" (is_list litvalist) litvalist)
	  (debug "translate_run_melt_expressions after generation litvalist=" litvalist)
	  (let ( (:long nblitval (list_length litvalist))
		 (tuplitval (make_multiple discr_multiple nblitval))
		 (:long ix 0)
		 (filtup (get_field :mocx_filetuple modctx))
		 (:long nbfile (multiple_length filtup))
		 )
	    (debug "translate_run_melt_expressions filtup=" filtup)
	    (foreach_pair_component_in_list
	     (litvalist)
	     (curpair curlitval)
	     (debug "translate_run_melt_expressions ix=" ix 
		    " curlitval=" curlitval)
	     (when curlitval
	       (assert_msg "check curlitval" 
			   (is_a curlitval class_literal_value) curlitval)
	       (let ( (val (get_field :litv_value curlitval))
		      (bxrk (get_field :litv_rank curlitval))
		      )
		 (assert_msg "check bxrk" (==i (get_int bxrk) ix) bxrk ix)
		 (multiple_put_nth tuplitval ix val)
		 ))
	     (setq ix (+i ix 1)))    ;end of foreach_pair_component_in_list litvalist
	    (debug "translate_run_melt_expressions tuplitval=" tuplitval)
	    (debug "before melt_run_extension basename=" basename
		   "\n* env=" env
		   "\n* tuplitval=" tuplitval)
	    (let ( (result (melt_run_extension basename env tuplitval))
		   )
	      (debug "after melt_run_extension basename=" basename
		     "\n* translate_run_melt_expressions result=" result)
	      (return result)
	      )))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun melt_translate_run_macroexpansions_list (lismexp env parmodctx)
  :doc #{The utility $MELT_TRANSLATE_RUN_MACROEXPANSIONS_LIST
  translates and runs a list of macroexpansions. It is used for
  expansion of $DEFMACRO-ed macronames.}#
  (debug "melt_translate_run_macroexpansions_list start lismexp=" lismexp 
	 "\n.. env=" env "\n.. parmodctx=" parmodctx)
  (shortbacktrace_dbg "melt_translate_run_macroexpansions_list" 12)
  (assert_msg "check env" (is_a env class_environment) env)
  (when (null lismexp)
    (debug "melt_translate_run_macroexpansions_list null lismexp=" lismexp)
    (return ()))
  (when (not (is_list lismexp))
    (debug "melt_translate_run_macroexpansions_list bad lismexp=" lismexp)
    (assert_msg "invalid lismexp" () lismexp)
    (return ()))
  (let ( (:long num 0)
	 (:long starterrcount (melt_error_counter))
	 (nakedbasnam ())
	 (referr (instance class_reference))
	 ;; we need to store the normlist for debugging purposes
	 (refnormlist (instance class_reference))
	 (modnam (get_field :mocx_modulename parmodctx))
	 (macroenv (get_field :mocx_macroenv parmodctx))
	 )
    (debug "melt_translate_run_macroexpansions_list env=" env 
	   "\n.. macroenv=" macroenv)
    (code_chunk numchk #{/* melt_translate_run_macroexpansions_list $NUMCHK */ 
         char basbuf_$NUMCHK[64] ;
         long num_$NUMCHK = 0 ;
         memset (basbuf_$NUMCHK, 0, sizeof(basbuf_$NUMCHK)) ;
         melt_count_runtime_extensions++ ;
         num_$NUMCHK = melt_count_runtime_extensions ;
         if (melt_count_runtime_extensions
             > MELT_MAX_RUNTIME_EXTENSIONS)
           melt_fatal_error ("too many %ld MELT runtime extensions for macroexpansion",
                             num_$NUMCHK) ;
         /* In melt_translate_run_macroexpansions_list $NUMCHK using getpid to 
         ensure unicity of generated naked base name */
         if (melt_flag_bootstrapping && melt_magic_discr($MODNAM) == MELTOBMAG_STRING)
           snprintf (basbuf_$NUMCHK, sizeof(basbuf_$NUMCHK), 
                                   "melt_%s_macro%05lx",
                                   melt_string_str($MODNAM), num_$NUMCHK) ;
         else
           snprintf (basbuf_$NUMCHK, sizeof(basbuf_$NUMCHK), 
                                   "melt_p%d_macro%05lx", 
                                   (int)getpid(), num_$NUMCHK) ;
         $NAKEDBASNAM =
           meltgc_new_string_raw_len ((meltobject_ptr_t)MELT_PREDEF (DISCR_STRING),
                                    basbuf_$NUMCHK, -1) ;
         /* end melt_translate_run_macroexpansions_list $NUMCHK */ 
         }#)
    (debug "melt_translate_run_macroexpansions_list nakedbasnam=" nakedbasnam " num=" num 
	   " starterrcount=" starterrcount)
    (let (
	  (runerrorhdlr 
	   (lambda (v)
	     (debug "melt_translate_run_macroexpansions_list/macrorunerrorhdlr v=" v)
	     (shortbacktrace_dbg "melt_translate_run_macroexpansions_list/macrorunerrorhdlr" 14)
	     (cond 
	      ((is_string v)
	       (code_chunk warnrunstr_chk
			   #{ /* melt_translate_run_macroexpansions_list $WARNRUNSTR_chk */
			   warning (0, "MELT running macro expansions {%s} error - %s", 
				       melt_string_str ((melt_ptr_t) $NAKEDBASNAM), 
				       melt_string_str ((melt_ptr_t) $V)) ; }#
			   ))
	      (:else 
	       (code_chunk warnrun_chk
			   #{ /* melt_translate_run_macroexpansions_list $WARNRUN_chk */
			   warning (0, "MELT running macro expansions {%s} errored", 
				       melt_string_str ((melt_ptr_t) $NAKEDBASNAM)) ; }#
			   ))
	      )
	     (set_ref referr (or v :true))))
	  (litvalist 
	   (list ()))	    ;first element of list is ignored, so null	  
	  (macroenv 
	   (fresh_env env (tuple 'macro-extension nakedbasnam)))
	  (newmodctx
	   (instance class_running_extension_module_context
		     :mocx_modulename  nakedbasnam
		     :mocx_expfieldict (make_mapstring discr_map_strings 71)
		     :mocx_expclassdict (make_mapstring discr_map_strings 19)
		     :mocx_initialenv env
		     :mocx_macroenv macroenv
		     :mocx_funcount (make_integerbox discr_integer 0)
		     :mocx_filetuple ()
		     :mocx_cheaderlist (make_list discr_list)
		     :mocx_cimplementlist (make_list discr_list)
		     :mocx_varcount (make_integerbox discr_integer 0)
		     :mocx_varlist (make_list discr_list)
		     :mocx_hookdict (make_mapstring discr_map_strings 31)
		     :mocx_macrolist (make_list discr_list)
		     ;; :mocx_cflags (make_list discr_list)
		     ;; :mocx_linkflags (make_list discr_list)
		     :mocx_packagepclist (make_list discr_list)
		     :mocx_gendevlist (make_list discr_list)
		     :mocx_errorhandler runerrorhdlr
		     :morcx_litervalist litvalist
		     :morcx_countlitval (make_integerbox discr_integer 1)
		     :morcx_literobjmap (make_mapobject discr_map_objects 53)
		     ))
	  (ncx 
	   (create_normal_extending_context newmodctx env))
	  (:long lenxlist (list_length lismexp))
	  
	  )
      (debug "melt_translate_run_macroexpansions_list here lismexp=" lismexp
	     "\n.. macroenv=" debug_less macroenv)
      (let ( (basename (make_string_tempname_suffixed discr_string nakedbasnam "_eXt"))
	     )
	(debug "melt_translate_run_macroexpansions_list basename=" basename 
	       "\n.. refnormlist=" refnormlist)
	;; translate to C code
	(translate_macroexpanded_list lismexp basename newmodctx ncx macroenv 
				      () compile2obj_initextendproc)
	(debug "melt_translate_run_macroexpansions_list after translation"
	       " refnormlist=" refnormlist
	       " to nakedbasnam=" nakedbasnam)
	(when  (or (notnull !referr) (>i (melt_error_counter) starterrcount))
	  (runerrorhdlr '"runtime translation to code failed")
	  (return () ()))
	(debug "melt_translate_run_macroexpansions_list before compiling runextend flavor of basename=" basename "\n.. newmodctx=" newmodctx "\n.. parmodctx=" parmodctx)
	(generate_flavored_melt_module basename basename '"runextend")
	(debug "melt_translate_run_macroexpansions_list after compiling runextend flavor of basename=" basename)
	;; make the literal value tuple
	(assert_msg "check litvalist" (is_list litvalist) litvalist)
	(debug "melt_translate_run_macroexpansions_list after generation litvalist=" litvalist)
	(let ( (:long nblitval (list_length litvalist))
	       (tuplitval (make_multiple discr_multiple nblitval))
	       (:long ix 0)
	       (filtup (get_field :mocx_filetuple newmodctx))
	       (:long nbfile (multiple_length filtup))
	       )
	  (debug "melt_translate_run_macroexpansions_list filtup=" filtup)
	  (foreach_pair_component_in_list
	   (litvalist)
	   (curpair curlitval)
	   (debug "melt_translate_run_macroexpansions_list ix#" ix " curlitval=" curlitval)
	   (when curlitval
	     (assert_msg "check curlitval" (is_a curlitval class_literal_value) curlitval)
	     (let ( (val (get_field :litv_value curlitval))
		    (bxrk (get_field :litv_rank curlitval))
		    )
	       (assert_msg "check bxrk" (==i (get_int bxrk) ix) bxrk)
	       (multiple_put_nth tuplitval ix val)
	       ))
	   (setq ix (+i ix 1)))	     ;end of foreach_pair_component_in_list litvalist
	  (debug "melt_translate_run_macroexpansions_list tuplitval=" tuplitval)
	  (debug "melt_translate_run_macroexpansions_list before melt_run_extension basename=" basename
		 "\n* env=" env
		 "\n* tuplitval=" tuplitval)
	  (let ( (result (melt_run_extension basename env tuplitval))
		 )
	    (debug "melt_translate_run_macroexpansions_list after melt_run_extension basename=" basename
		   "\n*  result=" result)
	    (return result)
	    )
	  )))))

;; to enable forward reference from warmelt-macro.melt
(melt_register_translator_runner_macroexpansions melt_translate_run_macroexpansions_list)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; recursive internal utility to read melt expressions from files or lists or vectors or s-exprs
(defun read_melt_expressions (src rlist :long depth)
  (debug "read_melt_expressions src=" src " depth=" depth " rlist.len=" (list_length rlist))
  (assert_msg "check rlist" (is_list rlist) rlist)
  (assert_msg "check depth" (<i depth 100) depth)
  (cond 
   ((null src)
    (return))
   ((is_string src)
    (informsg_strv "reading from MELT file source" src)
    (list_append2list rlist (read_file src)))
   ((is_list src)
    (foreach_pair_component_in_list 
     (src)
     (curpair cursrc)
     (read_melt_expressions cursrc rlist (+i depth 1))))
   ((is_multiple src)
    (foreach_in_multiple
     (src)
     (cursrc :long six)
     (read_melt_expressions cursrc rlist (+i depth 1))))
   ((is_object src)
    (list_append rlist src))
   ((is_closure src)
    (let ( (xsrc (src rlist (+i depth 1)))
	   )
      (debug "read_melt_expressions xsrc=" xsrc " depth=" depth)
      (if (null xsrc) (return))
      (assert_msg "check xsrc" (or (is_a xsrc class_sexpr) (is_a xsrc class_symbol)) xsrc)
      (list_append rlist xsrc)))
   (:else
    (error_strv () "invalid MELT expression to read, with discriminant" 
		(get_field :named_name (discrim src))))
   ))
    
;;;;;;;;;;;;;;;;
;;;;; utility function to translate to C++ some MELT sources
;;; modsrcname is the string for the module source file path; its
;;; basename should not contains any dots
(defun translate_to_cc_module_melt_sources (sources modsrcname curenv)
  (debug  "translate_to_cc_module_melt_sources sources=" sources " modsrcname=" modsrcname)
  (assert_msg "check curenv" (is_a curenv class_environment) curenv)
  (assert_msg "check modsrcname" (is_string modsrcname) modsrcname)
  (if (or (string_dynloaded_suffixed modsrcname)
	  (string_suffixed modsrcname ".melt")
	  (string_suffixed modsrcname ".c")
	  (string_suffixed modsrcname ".cc"))
      (errormsg_strv "invalid MELT source name - should not be suffixed"
		     modsrcname))
  (assert_msg "translate_to_cc_module_melt_sources modsrcname not ended with MELT_DYNLOADED_SUFFIX"
	      (not (string_dynloaded_suffixed modsrcname)) modsrcname)
  (assert_msg "translate_to_cc_module_melt_sources modulename not ended with .melt"
	      (not (string_suffixed modsrcname ".melt")) modsrcname)
  (assert_msg "translate_to_cc_module_melt_sources modulename not ended with .c"
	      (not (string_suffixed modsrcname ".c")) modsrcname)
  (assert_msg "translate_to_cc_module_melt_sources modulename not ended with .cc"
	      (not (string_suffixed modsrcname ".cc")) modsrcname)
  (let ( (:long isvalidmodsrc 0)
	 (rlist (make_list discr_list)) 
	 )
    (code_chunk 
     setisvalidmodsrcch 
     #{ /* translate_to_cc_module_melt_sources $SETISVALIDMODSRCCH */ {
     const char* modsrcstr = melt_string_str ((melt_ptr_t) $MODSRCNAME);
     const char* modsrcbase = modsrcstr ? (lbasename (modsrcstr)) : NULL;
     if (modsrcbase)
       $ISVALIDMODSRC =
       (strchr(modsrcbase,'.') == NULL) && (strchr(modsrcbase,'+') == NULL);
       } /* end translate_to_cc_module_melt_sources $SETISVALIDMODSRCCH */
     }#)
    (when (not isvalidmodsrc)
	  (debug "translate_to_cc_module_melt_sources bad generated modsrcname=" modsrcname)
	  (error_at ()
	   "invalid generated source name $1 [basename should have no dot or plus]" 
	   modsrcname)
	  (return)
	  )
    (read_melt_expressions sources rlist 0)
    (debug "after read translate_to_cc_module_melt_sources rlist=" rlist)
    (assert_msg "check non empty rlist" (>i (list_length rlist) 0) rlist)
    (compile_list_sexpr rlist curenv modsrcname)
    (debug "translate_to_cc_module_melt_sources done modsrcname=" modsrcname "\n")
    ))

;;;;;;;;;;;;;;;;
(defun eval (exp env)
  :doc #{$EVAL is evaluating $EXP -an s-expression or a list or tuple
  of s-expressions- inside environment $ENV or else the
  @code{($PARENT_MODULE_ENVIRONMENT)}. It works using
  $TRANSLATE_RUN_MELT_EXPRESSIONS so generate some C/C++ code then
  compiles and dynamically loads it.}#
  (debug "eval exp=" exp " env=" env)
  (if (null env)
      (setq env (parent_module_environment)))
  (when (is_not_a env class_environment)
    (debug "eval returns nil with bad env=" env)
    (warning_at () "EVAL got a bad environment of $1" 
		(get_field :named_name (discrim env)))
    (return ())
    )
  (let ( (listexps
	  (cond ((is_list exp)
		 exp)
		((is_multiple exp)
		 (multiple_to_list exp discr_list)
		 )
		(:else
		 (list exp))))
	 )
    (debug "eval listexps=" listexps " updated env=" env)
    (let ( (reseval (translate_run_melt_expressions listexps env))
	   )
      (debug "eval gives reseval=" reseval)
      reseval)
    ))
;;;;;;;;;;;;;;;;

(defun generate_gplv3plus_copyright_notice_c_comment (sbuf name)
  :doc #{Generate into stringbuffer $SBUF a C comment with GPLv3+
notice for file named $NAME.}#
  (assert_msg "check sbuf" (is_strbuf sbuf) sbuf)
  (add2sbuf_strconst sbuf "/** Copyright (C) ")
  (let ( (:long year 0)
	 )
    (code_chunk  getyear
     #{ /*+ generate_gplv3plus_copyright_notice_c_comment $GETYEAR*/ {
        time_t $GETYEAR#_now = 0;
	struct tm* $GETYEAR#_tm = NULL;
        $YEAR = atol (__DATE__ + 7);
	time (&$GETYEAR#_now);
	if ($GETYEAR#_now > 0)
	   $GETYEAR#_tm = localtime (&$GETYEAR#_now);
        if ($GETYEAR#_tm) 
	   $YEAR = $GETYEAR#_tm->tm_year + 1900;
        } /*- $GETYEAR*/}#)
    (add2sbuf_longdec sbuf year)
    )
  (add2sbuf_strconst sbuf " Free Software Foundation, Inc.")
  (add2sbuf_indentnl sbuf 0)
  (add2sbuf_strconst sbuf "  This generated file ")
  (if (is_string name)
      (code_chunk 
       addbasename
       #{ /*$ADDBASENAME +*/
       meltgc_add_strbuf( (melt_ptr_t)($SBUF), 
			  lbasename (melt_string_str((melt_ptr_t)($NAME))));
       /*$ADDBASENAME -*/ }#)
   )
  (add2sbuf_strconst sbuf " is part of GCC.")
  (add2sbuf_indentnl sbuf 0)
  (add2sbuf_indentnl sbuf 0)
  (add2sbuf_strconst sbuf "                  [DON'T EDIT THIS GENERATED FILE]

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
**/")
  (add2sbuf_indentnl sbuf 0)
  (add2sbuf_indentnl sbuf 0)
)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values 
 compile_list_sexpr
 compile_first_bootstrap_list_sexpr
 eval
 generate_gplv3plus_copyright_notice_c_comment 
 get_code_buffer_limit
 melt_translate_run_macroexpansions_list
 put_code_buffer_limit
 syntax_test_generator
 translate_run_melt_expressions
 translate_to_cc_module_melt_sources
 )

(export_class class_secondary_cc_file)

;; compatibility with old
(export_synonym class_secondary_c_file class_secondary_cc_file)
(export_synonym translate_to_c_module_melt_sources translate_to_cc_module_melt_sources)


;;;;;;;;;;;;;;;;




;;; eof warmelt-outobj.melt
